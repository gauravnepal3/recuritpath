
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model OrganizationUserRole
 * 
 */
export type OrganizationUserRole = $Result.DefaultSelection<Prisma.$OrganizationUserRolePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model TwoFactorToken
 * 
 */
export type TwoFactorToken = $Result.DefaultSelection<Prisma.$TwoFactorTokenPayload>
/**
 * Model TwoFactorConfirmation
 * 
 */
export type TwoFactorConfirmation = $Result.DefaultSelection<Prisma.$TwoFactorConfirmationPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model OrganizationSubscription
 * 
 */
export type OrganizationSubscription = $Result.DefaultSelection<Prisma.$OrganizationSubscriptionPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model OrganizationActivityLog
 * 
 */
export type OrganizationActivityLog = $Result.DefaultSelection<Prisma.$OrganizationActivityLogPayload>
/**
 * Model JobPost
 * 
 */
export type JobPost = $Result.DefaultSelection<Prisma.$JobPostPayload>
/**
 * Model JobApplication
 * 
 */
export type JobApplication = $Result.DefaultSelection<Prisma.$JobApplicationPayload>
/**
 * Model CandidateApplication
 * 
 */
export type CandidateApplication = $Result.DefaultSelection<Prisma.$CandidateApplicationPayload>
/**
 * Model CandidateReview
 * 
 */
export type CandidateReview = $Result.DefaultSelection<Prisma.$CandidateReviewPayload>
/**
 * Model CandidateTimeline
 * 
 */
export type CandidateTimeline = $Result.DefaultSelection<Prisma.$CandidateTimelinePayload>
/**
 * Model FormResponse
 * 
 */
export type FormResponse = $Result.DefaultSelection<Prisma.$FormResponsePayload>
/**
 * Model JobPreview
 * 
 */
export type JobPreview = $Result.DefaultSelection<Prisma.$JobPreviewPayload>
/**
 * Model JobStage
 * 
 */
export type JobStage = $Result.DefaultSelection<Prisma.$JobStagePayload>
/**
 * Model JobMailingTemplate
 * 
 */
export type JobMailingTemplate = $Result.DefaultSelection<Prisma.$JobMailingTemplatePayload>
/**
 * Model EmailMessage
 * 
 */
export type EmailMessage = $Result.DefaultSelection<Prisma.$EmailMessagePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationReceipt
 * 
 */
export type NotificationReceipt = $Result.DefaultSelection<Prisma.$NotificationReceiptPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const OrganizationRole: {
  OWNER: 'OWNER',
  INTERVIEWER: 'INTERVIEWER'
};

export type OrganizationRole = (typeof OrganizationRole)[keyof typeof OrganizationRole]


export const UserRole: {
  ADMIN: 'ADMIN',
  USER: 'USER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const SubscriptionStatus: {
  FREE: 'FREE',
  ACTIVE: 'ACTIVE',
  CANCELED: 'CANCELED',
  EXPIRED: 'EXPIRED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const PaymentStatus: {
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const EmailDirection: {
  SENT: 'SENT',
  RECEIVED: 'RECEIVED'
};

export type EmailDirection = (typeof EmailDirection)[keyof typeof EmailDirection]

}

export type OrganizationRole = $Enums.OrganizationRole

export const OrganizationRole: typeof $Enums.OrganizationRole

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type EmailDirection = $Enums.EmailDirection

export const EmailDirection: typeof $Enums.EmailDirection

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more OrganizationUserRoles
 * const organizationUserRoles = await prisma.organizationUserRole.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more OrganizationUserRoles
   * const organizationUserRoles = await prisma.organizationUserRole.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.organizationUserRole`: Exposes CRUD operations for the **OrganizationUserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationUserRoles
    * const organizationUserRoles = await prisma.organizationUserRole.findMany()
    * ```
    */
  get organizationUserRole(): Prisma.OrganizationUserRoleDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs>;

  /**
   * `prisma.twoFactorToken`: Exposes CRUD operations for the **TwoFactorToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwoFactorTokens
    * const twoFactorTokens = await prisma.twoFactorToken.findMany()
    * ```
    */
  get twoFactorToken(): Prisma.TwoFactorTokenDelegate<ExtArgs>;

  /**
   * `prisma.twoFactorConfirmation`: Exposes CRUD operations for the **TwoFactorConfirmation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwoFactorConfirmations
    * const twoFactorConfirmations = await prisma.twoFactorConfirmation.findMany()
    * ```
    */
  get twoFactorConfirmation(): Prisma.TwoFactorConfirmationDelegate<ExtArgs>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs>;

  /**
   * `prisma.organizationSubscription`: Exposes CRUD operations for the **OrganizationSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationSubscriptions
    * const organizationSubscriptions = await prisma.organizationSubscription.findMany()
    * ```
    */
  get organizationSubscription(): Prisma.OrganizationSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.organizationActivityLog`: Exposes CRUD operations for the **OrganizationActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationActivityLogs
    * const organizationActivityLogs = await prisma.organizationActivityLog.findMany()
    * ```
    */
  get organizationActivityLog(): Prisma.OrganizationActivityLogDelegate<ExtArgs>;

  /**
   * `prisma.jobPost`: Exposes CRUD operations for the **JobPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobPosts
    * const jobPosts = await prisma.jobPost.findMany()
    * ```
    */
  get jobPost(): Prisma.JobPostDelegate<ExtArgs>;

  /**
   * `prisma.jobApplication`: Exposes CRUD operations for the **JobApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobApplications
    * const jobApplications = await prisma.jobApplication.findMany()
    * ```
    */
  get jobApplication(): Prisma.JobApplicationDelegate<ExtArgs>;

  /**
   * `prisma.candidateApplication`: Exposes CRUD operations for the **CandidateApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CandidateApplications
    * const candidateApplications = await prisma.candidateApplication.findMany()
    * ```
    */
  get candidateApplication(): Prisma.CandidateApplicationDelegate<ExtArgs>;

  /**
   * `prisma.candidateReview`: Exposes CRUD operations for the **CandidateReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CandidateReviews
    * const candidateReviews = await prisma.candidateReview.findMany()
    * ```
    */
  get candidateReview(): Prisma.CandidateReviewDelegate<ExtArgs>;

  /**
   * `prisma.candidateTimeline`: Exposes CRUD operations for the **CandidateTimeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CandidateTimelines
    * const candidateTimelines = await prisma.candidateTimeline.findMany()
    * ```
    */
  get candidateTimeline(): Prisma.CandidateTimelineDelegate<ExtArgs>;

  /**
   * `prisma.formResponse`: Exposes CRUD operations for the **FormResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormResponses
    * const formResponses = await prisma.formResponse.findMany()
    * ```
    */
  get formResponse(): Prisma.FormResponseDelegate<ExtArgs>;

  /**
   * `prisma.jobPreview`: Exposes CRUD operations for the **JobPreview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobPreviews
    * const jobPreviews = await prisma.jobPreview.findMany()
    * ```
    */
  get jobPreview(): Prisma.JobPreviewDelegate<ExtArgs>;

  /**
   * `prisma.jobStage`: Exposes CRUD operations for the **JobStage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobStages
    * const jobStages = await prisma.jobStage.findMany()
    * ```
    */
  get jobStage(): Prisma.JobStageDelegate<ExtArgs>;

  /**
   * `prisma.jobMailingTemplate`: Exposes CRUD operations for the **JobMailingTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobMailingTemplates
    * const jobMailingTemplates = await prisma.jobMailingTemplate.findMany()
    * ```
    */
  get jobMailingTemplate(): Prisma.JobMailingTemplateDelegate<ExtArgs>;

  /**
   * `prisma.emailMessage`: Exposes CRUD operations for the **EmailMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailMessages
    * const emailMessages = await prisma.emailMessage.findMany()
    * ```
    */
  get emailMessage(): Prisma.EmailMessageDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.notificationReceipt`: Exposes CRUD operations for the **NotificationReceipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationReceipts
    * const notificationReceipts = await prisma.notificationReceipt.findMany()
    * ```
    */
  get notificationReceipt(): Prisma.NotificationReceiptDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.10.2
   * Query Engine version: 5a9203d0590c951969e85a7d07215503f4672eb9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    OrganizationUserRole: 'OrganizationUserRole',
    User: 'User',
    Account: 'Account',
    VerificationToken: 'VerificationToken',
    PasswordResetToken: 'PasswordResetToken',
    TwoFactorToken: 'TwoFactorToken',
    TwoFactorConfirmation: 'TwoFactorConfirmation',
    Organization: 'Organization',
    OrganizationSubscription: 'OrganizationSubscription',
    Payment: 'Payment',
    OrganizationActivityLog: 'OrganizationActivityLog',
    JobPost: 'JobPost',
    JobApplication: 'JobApplication',
    CandidateApplication: 'CandidateApplication',
    CandidateReview: 'CandidateReview',
    CandidateTimeline: 'CandidateTimeline',
    FormResponse: 'FormResponse',
    JobPreview: 'JobPreview',
    JobStage: 'JobStage',
    JobMailingTemplate: 'JobMailingTemplate',
    EmailMessage: 'EmailMessage',
    Notification: 'Notification',
    NotificationReceipt: 'NotificationReceipt'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'organizationUserRole' | 'user' | 'account' | 'verificationToken' | 'passwordResetToken' | 'twoFactorToken' | 'twoFactorConfirmation' | 'organization' | 'organizationSubscription' | 'payment' | 'organizationActivityLog' | 'jobPost' | 'jobApplication' | 'candidateApplication' | 'candidateReview' | 'candidateTimeline' | 'formResponse' | 'jobPreview' | 'jobStage' | 'jobMailingTemplate' | 'emailMessage' | 'notification' | 'notificationReceipt'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      OrganizationUserRole: {
        payload: Prisma.$OrganizationUserRolePayload<ExtArgs>
        fields: Prisma.OrganizationUserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationUserRoleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationUserRoleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserRolePayload>
          }
          findFirst: {
            args: Prisma.OrganizationUserRoleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationUserRoleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserRolePayload>
          }
          findMany: {
            args: Prisma.OrganizationUserRoleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserRolePayload>[]
          }
          create: {
            args: Prisma.OrganizationUserRoleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserRolePayload>
          }
          createMany: {
            args: Prisma.OrganizationUserRoleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrganizationUserRoleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserRolePayload>
          }
          update: {
            args: Prisma.OrganizationUserRoleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserRolePayload>
          }
          deleteMany: {
            args: Prisma.OrganizationUserRoleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUserRoleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUserRoleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserRolePayload>
          }
          aggregate: {
            args: Prisma.OrganizationUserRoleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrganizationUserRole>
          }
          groupBy: {
            args: Prisma.OrganizationUserRoleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationUserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationUserRoleCountArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationUserRoleCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      TwoFactorToken: {
        payload: Prisma.$TwoFactorTokenPayload<ExtArgs>
        fields: Prisma.TwoFactorTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TwoFactorTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwoFactorTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload>
          }
          findFirst: {
            args: Prisma.TwoFactorTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwoFactorTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload>
          }
          findMany: {
            args: Prisma.TwoFactorTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload>[]
          }
          create: {
            args: Prisma.TwoFactorTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload>
          }
          createMany: {
            args: Prisma.TwoFactorTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TwoFactorTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload>
          }
          update: {
            args: Prisma.TwoFactorTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload>
          }
          deleteMany: {
            args: Prisma.TwoFactorTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TwoFactorTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TwoFactorTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorTokenPayload>
          }
          aggregate: {
            args: Prisma.TwoFactorTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTwoFactorToken>
          }
          groupBy: {
            args: Prisma.TwoFactorTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TwoFactorTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TwoFactorTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<TwoFactorTokenCountAggregateOutputType> | number
          }
        }
      }
      TwoFactorConfirmation: {
        payload: Prisma.$TwoFactorConfirmationPayload<ExtArgs>
        fields: Prisma.TwoFactorConfirmationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TwoFactorConfirmationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwoFactorConfirmationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload>
          }
          findFirst: {
            args: Prisma.TwoFactorConfirmationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwoFactorConfirmationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload>
          }
          findMany: {
            args: Prisma.TwoFactorConfirmationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload>[]
          }
          create: {
            args: Prisma.TwoFactorConfirmationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload>
          }
          createMany: {
            args: Prisma.TwoFactorConfirmationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TwoFactorConfirmationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload>
          }
          update: {
            args: Prisma.TwoFactorConfirmationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload>
          }
          deleteMany: {
            args: Prisma.TwoFactorConfirmationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TwoFactorConfirmationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TwoFactorConfirmationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TwoFactorConfirmationPayload>
          }
          aggregate: {
            args: Prisma.TwoFactorConfirmationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTwoFactorConfirmation>
          }
          groupBy: {
            args: Prisma.TwoFactorConfirmationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TwoFactorConfirmationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TwoFactorConfirmationCountArgs<ExtArgs>,
            result: $Utils.Optional<TwoFactorConfirmationCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      OrganizationSubscription: {
        payload: Prisma.$OrganizationSubscriptionPayload<ExtArgs>
        fields: Prisma.OrganizationSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationSubscriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationSubscriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.OrganizationSubscriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationSubscriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationSubscriptionPayload>
          }
          findMany: {
            args: Prisma.OrganizationSubscriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationSubscriptionPayload>[]
          }
          create: {
            args: Prisma.OrganizationSubscriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationSubscriptionPayload>
          }
          createMany: {
            args: Prisma.OrganizationSubscriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrganizationSubscriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationSubscriptionPayload>
          }
          update: {
            args: Prisma.OrganizationSubscriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationSubscriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationSubscriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationSubscriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.OrganizationSubscriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrganizationSubscription>
          }
          groupBy: {
            args: Prisma.OrganizationSubscriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationSubscriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      OrganizationActivityLog: {
        payload: Prisma.$OrganizationActivityLogPayload<ExtArgs>
        fields: Prisma.OrganizationActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationActivityLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationActivityLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationActivityLogPayload>
          }
          findFirst: {
            args: Prisma.OrganizationActivityLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationActivityLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationActivityLogPayload>
          }
          findMany: {
            args: Prisma.OrganizationActivityLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationActivityLogPayload>[]
          }
          create: {
            args: Prisma.OrganizationActivityLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationActivityLogPayload>
          }
          createMany: {
            args: Prisma.OrganizationActivityLogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrganizationActivityLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationActivityLogPayload>
          }
          update: {
            args: Prisma.OrganizationActivityLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationActivityLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationActivityLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationActivityLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationActivityLogPayload>
          }
          aggregate: {
            args: Prisma.OrganizationActivityLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrganizationActivityLog>
          }
          groupBy: {
            args: Prisma.OrganizationActivityLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationActivityLogCountArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationActivityLogCountAggregateOutputType> | number
          }
        }
      }
      JobPost: {
        payload: Prisma.$JobPostPayload<ExtArgs>
        fields: Prisma.JobPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobPostFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobPostFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          findFirst: {
            args: Prisma.JobPostFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobPostFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          findMany: {
            args: Prisma.JobPostFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>[]
          }
          create: {
            args: Prisma.JobPostCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          createMany: {
            args: Prisma.JobPostCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.JobPostDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          update: {
            args: Prisma.JobPostUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          deleteMany: {
            args: Prisma.JobPostDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.JobPostUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.JobPostUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPostPayload>
          }
          aggregate: {
            args: Prisma.JobPostAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJobPost>
          }
          groupBy: {
            args: Prisma.JobPostGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JobPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobPostCountArgs<ExtArgs>,
            result: $Utils.Optional<JobPostCountAggregateOutputType> | number
          }
        }
      }
      JobApplication: {
        payload: Prisma.$JobApplicationPayload<ExtArgs>
        fields: Prisma.JobApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobApplicationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobApplicationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          findFirst: {
            args: Prisma.JobApplicationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobApplicationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          findMany: {
            args: Prisma.JobApplicationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>[]
          }
          create: {
            args: Prisma.JobApplicationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          createMany: {
            args: Prisma.JobApplicationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.JobApplicationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          update: {
            args: Prisma.JobApplicationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          deleteMany: {
            args: Prisma.JobApplicationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.JobApplicationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.JobApplicationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          aggregate: {
            args: Prisma.JobApplicationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJobApplication>
          }
          groupBy: {
            args: Prisma.JobApplicationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JobApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobApplicationCountArgs<ExtArgs>,
            result: $Utils.Optional<JobApplicationCountAggregateOutputType> | number
          }
        }
      }
      CandidateApplication: {
        payload: Prisma.$CandidateApplicationPayload<ExtArgs>
        fields: Prisma.CandidateApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CandidateApplicationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CandidateApplicationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateApplicationPayload>
          }
          findFirst: {
            args: Prisma.CandidateApplicationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CandidateApplicationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateApplicationPayload>
          }
          findMany: {
            args: Prisma.CandidateApplicationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateApplicationPayload>[]
          }
          create: {
            args: Prisma.CandidateApplicationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateApplicationPayload>
          }
          createMany: {
            args: Prisma.CandidateApplicationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CandidateApplicationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateApplicationPayload>
          }
          update: {
            args: Prisma.CandidateApplicationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateApplicationPayload>
          }
          deleteMany: {
            args: Prisma.CandidateApplicationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CandidateApplicationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CandidateApplicationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateApplicationPayload>
          }
          aggregate: {
            args: Prisma.CandidateApplicationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCandidateApplication>
          }
          groupBy: {
            args: Prisma.CandidateApplicationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CandidateApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CandidateApplicationCountArgs<ExtArgs>,
            result: $Utils.Optional<CandidateApplicationCountAggregateOutputType> | number
          }
        }
      }
      CandidateReview: {
        payload: Prisma.$CandidateReviewPayload<ExtArgs>
        fields: Prisma.CandidateReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CandidateReviewFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CandidateReviewFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateReviewPayload>
          }
          findFirst: {
            args: Prisma.CandidateReviewFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CandidateReviewFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateReviewPayload>
          }
          findMany: {
            args: Prisma.CandidateReviewFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateReviewPayload>[]
          }
          create: {
            args: Prisma.CandidateReviewCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateReviewPayload>
          }
          createMany: {
            args: Prisma.CandidateReviewCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CandidateReviewDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateReviewPayload>
          }
          update: {
            args: Prisma.CandidateReviewUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateReviewPayload>
          }
          deleteMany: {
            args: Prisma.CandidateReviewDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CandidateReviewUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CandidateReviewUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateReviewPayload>
          }
          aggregate: {
            args: Prisma.CandidateReviewAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCandidateReview>
          }
          groupBy: {
            args: Prisma.CandidateReviewGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CandidateReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.CandidateReviewCountArgs<ExtArgs>,
            result: $Utils.Optional<CandidateReviewCountAggregateOutputType> | number
          }
        }
      }
      CandidateTimeline: {
        payload: Prisma.$CandidateTimelinePayload<ExtArgs>
        fields: Prisma.CandidateTimelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CandidateTimelineFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateTimelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CandidateTimelineFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateTimelinePayload>
          }
          findFirst: {
            args: Prisma.CandidateTimelineFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateTimelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CandidateTimelineFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateTimelinePayload>
          }
          findMany: {
            args: Prisma.CandidateTimelineFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateTimelinePayload>[]
          }
          create: {
            args: Prisma.CandidateTimelineCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateTimelinePayload>
          }
          createMany: {
            args: Prisma.CandidateTimelineCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CandidateTimelineDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateTimelinePayload>
          }
          update: {
            args: Prisma.CandidateTimelineUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateTimelinePayload>
          }
          deleteMany: {
            args: Prisma.CandidateTimelineDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CandidateTimelineUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CandidateTimelineUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidateTimelinePayload>
          }
          aggregate: {
            args: Prisma.CandidateTimelineAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCandidateTimeline>
          }
          groupBy: {
            args: Prisma.CandidateTimelineGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CandidateTimelineGroupByOutputType>[]
          }
          count: {
            args: Prisma.CandidateTimelineCountArgs<ExtArgs>,
            result: $Utils.Optional<CandidateTimelineCountAggregateOutputType> | number
          }
        }
      }
      FormResponse: {
        payload: Prisma.$FormResponsePayload<ExtArgs>
        fields: Prisma.FormResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormResponseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormResponseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          findFirst: {
            args: Prisma.FormResponseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormResponseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          findMany: {
            args: Prisma.FormResponseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>[]
          }
          create: {
            args: Prisma.FormResponseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          createMany: {
            args: Prisma.FormResponseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FormResponseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          update: {
            args: Prisma.FormResponseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          deleteMany: {
            args: Prisma.FormResponseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FormResponseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FormResponseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          aggregate: {
            args: Prisma.FormResponseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFormResponse>
          }
          groupBy: {
            args: Prisma.FormResponseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FormResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormResponseCountArgs<ExtArgs>,
            result: $Utils.Optional<FormResponseCountAggregateOutputType> | number
          }
        }
      }
      JobPreview: {
        payload: Prisma.$JobPreviewPayload<ExtArgs>
        fields: Prisma.JobPreviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobPreviewFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPreviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobPreviewFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPreviewPayload>
          }
          findFirst: {
            args: Prisma.JobPreviewFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPreviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobPreviewFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPreviewPayload>
          }
          findMany: {
            args: Prisma.JobPreviewFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPreviewPayload>[]
          }
          create: {
            args: Prisma.JobPreviewCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPreviewPayload>
          }
          createMany: {
            args: Prisma.JobPreviewCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.JobPreviewDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPreviewPayload>
          }
          update: {
            args: Prisma.JobPreviewUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPreviewPayload>
          }
          deleteMany: {
            args: Prisma.JobPreviewDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.JobPreviewUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.JobPreviewUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobPreviewPayload>
          }
          aggregate: {
            args: Prisma.JobPreviewAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJobPreview>
          }
          groupBy: {
            args: Prisma.JobPreviewGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JobPreviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobPreviewCountArgs<ExtArgs>,
            result: $Utils.Optional<JobPreviewCountAggregateOutputType> | number
          }
        }
      }
      JobStage: {
        payload: Prisma.$JobStagePayload<ExtArgs>
        fields: Prisma.JobStageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobStageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobStagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobStageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobStagePayload>
          }
          findFirst: {
            args: Prisma.JobStageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobStagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobStageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobStagePayload>
          }
          findMany: {
            args: Prisma.JobStageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobStagePayload>[]
          }
          create: {
            args: Prisma.JobStageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobStagePayload>
          }
          createMany: {
            args: Prisma.JobStageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.JobStageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobStagePayload>
          }
          update: {
            args: Prisma.JobStageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobStagePayload>
          }
          deleteMany: {
            args: Prisma.JobStageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.JobStageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.JobStageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobStagePayload>
          }
          aggregate: {
            args: Prisma.JobStageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJobStage>
          }
          groupBy: {
            args: Prisma.JobStageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JobStageGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobStageCountArgs<ExtArgs>,
            result: $Utils.Optional<JobStageCountAggregateOutputType> | number
          }
        }
      }
      JobMailingTemplate: {
        payload: Prisma.$JobMailingTemplatePayload<ExtArgs>
        fields: Prisma.JobMailingTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobMailingTemplateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobMailingTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobMailingTemplateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobMailingTemplatePayload>
          }
          findFirst: {
            args: Prisma.JobMailingTemplateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobMailingTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobMailingTemplateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobMailingTemplatePayload>
          }
          findMany: {
            args: Prisma.JobMailingTemplateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobMailingTemplatePayload>[]
          }
          create: {
            args: Prisma.JobMailingTemplateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobMailingTemplatePayload>
          }
          createMany: {
            args: Prisma.JobMailingTemplateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.JobMailingTemplateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobMailingTemplatePayload>
          }
          update: {
            args: Prisma.JobMailingTemplateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobMailingTemplatePayload>
          }
          deleteMany: {
            args: Prisma.JobMailingTemplateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.JobMailingTemplateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.JobMailingTemplateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$JobMailingTemplatePayload>
          }
          aggregate: {
            args: Prisma.JobMailingTemplateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJobMailingTemplate>
          }
          groupBy: {
            args: Prisma.JobMailingTemplateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JobMailingTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobMailingTemplateCountArgs<ExtArgs>,
            result: $Utils.Optional<JobMailingTemplateCountAggregateOutputType> | number
          }
        }
      }
      EmailMessage: {
        payload: Prisma.$EmailMessagePayload<ExtArgs>
        fields: Prisma.EmailMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailMessageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailMessageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          findFirst: {
            args: Prisma.EmailMessageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailMessageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          findMany: {
            args: Prisma.EmailMessageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>[]
          }
          create: {
            args: Prisma.EmailMessageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          createMany: {
            args: Prisma.EmailMessageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailMessageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          update: {
            args: Prisma.EmailMessageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          deleteMany: {
            args: Prisma.EmailMessageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailMessageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailMessageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailMessagePayload>
          }
          aggregate: {
            args: Prisma.EmailMessageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailMessage>
          }
          groupBy: {
            args: Prisma.EmailMessageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailMessageCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailMessageCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationReceipt: {
        payload: Prisma.$NotificationReceiptPayload<ExtArgs>
        fields: Prisma.NotificationReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationReceiptFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationReceiptFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiptPayload>
          }
          findFirst: {
            args: Prisma.NotificationReceiptFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationReceiptFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiptPayload>
          }
          findMany: {
            args: Prisma.NotificationReceiptFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiptPayload>[]
          }
          create: {
            args: Prisma.NotificationReceiptCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiptPayload>
          }
          createMany: {
            args: Prisma.NotificationReceiptCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NotificationReceiptDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiptPayload>
          }
          update: {
            args: Prisma.NotificationReceiptUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiptPayload>
          }
          deleteMany: {
            args: Prisma.NotificationReceiptDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationReceiptUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationReceiptUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationReceiptPayload>
          }
          aggregate: {
            args: Prisma.NotificationReceiptAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotificationReceipt>
          }
          groupBy: {
            args: Prisma.NotificationReceiptGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationReceiptCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationReceiptCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    organizations: number
    candidateTimeline: number
    emailMessage: number
    organizationSubscription: number
    NotificationReceipt: number
    Notification: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    organizations?: boolean | UserCountOutputTypeCountOrganizationsArgs
    candidateTimeline?: boolean | UserCountOutputTypeCountCandidateTimelineArgs
    emailMessage?: boolean | UserCountOutputTypeCountEmailMessageArgs
    organizationSubscription?: boolean | UserCountOutputTypeCountOrganizationSubscriptionArgs
    NotificationReceipt?: boolean | UserCountOutputTypeCountNotificationReceiptArgs
    Notification?: boolean | UserCountOutputTypeCountNotificationArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrganizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationUserRoleWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCandidateTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidateTimelineWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailMessageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrganizationSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationSubscriptionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationReceiptWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }



  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    organizationRole: number
    organizationActionLog: number
    jobPost: number
    payment: number
    jobPreview: number
    organizationSubscription: number
    Notification: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizationRole?: boolean | OrganizationCountOutputTypeCountOrganizationRoleArgs
    organizationActionLog?: boolean | OrganizationCountOutputTypeCountOrganizationActionLogArgs
    jobPost?: boolean | OrganizationCountOutputTypeCountJobPostArgs
    payment?: boolean | OrganizationCountOutputTypeCountPaymentArgs
    jobPreview?: boolean | OrganizationCountOutputTypeCountJobPreviewArgs
    organizationSubscription?: boolean | OrganizationCountOutputTypeCountOrganizationSubscriptionArgs
    Notification?: boolean | OrganizationCountOutputTypeCountNotificationArgs
  }

  // Custom InputTypes

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountOrganizationRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationUserRoleWhereInput
  }


  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountOrganizationActionLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationActivityLogWhereInput
  }


  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountJobPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostWhereInput
  }


  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountJobPreviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPreviewWhereInput
  }


  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountOrganizationSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationSubscriptionWhereInput
  }


  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }



  /**
   * Count Type JobPostCountOutputType
   */

  export type JobPostCountOutputType = {
    jobApplication: number
    jobStage: number
    jobPreview: number
    candidateApplication: number
    CandidateTimeline: number
    JobMailingTemplate: number
  }

  export type JobPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobApplication?: boolean | JobPostCountOutputTypeCountJobApplicationArgs
    jobStage?: boolean | JobPostCountOutputTypeCountJobStageArgs
    jobPreview?: boolean | JobPostCountOutputTypeCountJobPreviewArgs
    candidateApplication?: boolean | JobPostCountOutputTypeCountCandidateApplicationArgs
    CandidateTimeline?: boolean | JobPostCountOutputTypeCountCandidateTimelineArgs
    JobMailingTemplate?: boolean | JobPostCountOutputTypeCountJobMailingTemplateArgs
  }

  // Custom InputTypes

  /**
   * JobPostCountOutputType without action
   */
  export type JobPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostCountOutputType
     */
    select?: JobPostCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * JobPostCountOutputType without action
   */
  export type JobPostCountOutputTypeCountJobApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicationWhereInput
  }


  /**
   * JobPostCountOutputType without action
   */
  export type JobPostCountOutputTypeCountJobStageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobStageWhereInput
  }


  /**
   * JobPostCountOutputType without action
   */
  export type JobPostCountOutputTypeCountJobPreviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPreviewWhereInput
  }


  /**
   * JobPostCountOutputType without action
   */
  export type JobPostCountOutputTypeCountCandidateApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidateApplicationWhereInput
  }


  /**
   * JobPostCountOutputType without action
   */
  export type JobPostCountOutputTypeCountCandidateTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidateTimelineWhereInput
  }


  /**
   * JobPostCountOutputType without action
   */
  export type JobPostCountOutputTypeCountJobMailingTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobMailingTemplateWhereInput
  }



  /**
   * Count Type JobApplicationCountOutputType
   */

  export type JobApplicationCountOutputType = {
    formResponse: number
  }

  export type JobApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formResponse?: boolean | JobApplicationCountOutputTypeCountFormResponseArgs
  }

  // Custom InputTypes

  /**
   * JobApplicationCountOutputType without action
   */
  export type JobApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicationCountOutputType
     */
    select?: JobApplicationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * JobApplicationCountOutputType without action
   */
  export type JobApplicationCountOutputTypeCountFormResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormResponseWhereInput
  }



  /**
   * Count Type CandidateApplicationCountOutputType
   */

  export type CandidateApplicationCountOutputType = {
    formResponses: number
    emailMessage: number
    CandidateTimeline: number
  }

  export type CandidateApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formResponses?: boolean | CandidateApplicationCountOutputTypeCountFormResponsesArgs
    emailMessage?: boolean | CandidateApplicationCountOutputTypeCountEmailMessageArgs
    CandidateTimeline?: boolean | CandidateApplicationCountOutputTypeCountCandidateTimelineArgs
  }

  // Custom InputTypes

  /**
   * CandidateApplicationCountOutputType without action
   */
  export type CandidateApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateApplicationCountOutputType
     */
    select?: CandidateApplicationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CandidateApplicationCountOutputType without action
   */
  export type CandidateApplicationCountOutputTypeCountFormResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormResponseWhereInput
  }


  /**
   * CandidateApplicationCountOutputType without action
   */
  export type CandidateApplicationCountOutputTypeCountEmailMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailMessageWhereInput
  }


  /**
   * CandidateApplicationCountOutputType without action
   */
  export type CandidateApplicationCountOutputTypeCountCandidateTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidateTimelineWhereInput
  }



  /**
   * Count Type CandidateReviewCountOutputType
   */

  export type CandidateReviewCountOutputType = {
    candidateTimeline: number
  }

  export type CandidateReviewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidateTimeline?: boolean | CandidateReviewCountOutputTypeCountCandidateTimelineArgs
  }

  // Custom InputTypes

  /**
   * CandidateReviewCountOutputType without action
   */
  export type CandidateReviewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateReviewCountOutputType
     */
    select?: CandidateReviewCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CandidateReviewCountOutputType without action
   */
  export type CandidateReviewCountOutputTypeCountCandidateTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidateTimelineWhereInput
  }



  /**
   * Count Type JobStageCountOutputType
   */

  export type JobStageCountOutputType = {
    candidateStage: number
  }

  export type JobStageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidateStage?: boolean | JobStageCountOutputTypeCountCandidateStageArgs
  }

  // Custom InputTypes

  /**
   * JobStageCountOutputType without action
   */
  export type JobStageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStageCountOutputType
     */
    select?: JobStageCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * JobStageCountOutputType without action
   */
  export type JobStageCountOutputTypeCountCandidateStageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidateApplicationWhereInput
  }



  /**
   * Count Type EmailMessageCountOutputType
   */

  export type EmailMessageCountOutputType = {
    replies: number
  }

  export type EmailMessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | EmailMessageCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes

  /**
   * EmailMessageCountOutputType without action
   */
  export type EmailMessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessageCountOutputType
     */
    select?: EmailMessageCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EmailMessageCountOutputType without action
   */
  export type EmailMessageCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailMessageWhereInput
  }



  /**
   * Count Type NotificationCountOutputType
   */

  export type NotificationCountOutputType = {
    receipts: number
  }

  export type NotificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receipts?: boolean | NotificationCountOutputTypeCountReceiptsArgs
  }

  // Custom InputTypes

  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCountOutputType
     */
    select?: NotificationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeCountReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationReceiptWhereInput
  }



  /**
   * Models
   */

  /**
   * Model OrganizationUserRole
   */

  export type AggregateOrganizationUserRole = {
    _count: OrganizationUserRoleCountAggregateOutputType | null
    _min: OrganizationUserRoleMinAggregateOutputType | null
    _max: OrganizationUserRoleMaxAggregateOutputType | null
  }

  export type OrganizationUserRoleMinAggregateOutputType = {
    id: string | null
    role: $Enums.OrganizationRole | null
    organizationId: string | null
    email: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type OrganizationUserRoleMaxAggregateOutputType = {
    id: string | null
    role: $Enums.OrganizationRole | null
    organizationId: string | null
    email: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type OrganizationUserRoleCountAggregateOutputType = {
    id: number
    role: number
    organizationId: number
    email: number
    userId: number
    status: number
    createdAt: number
    _all: number
  }


  export type OrganizationUserRoleMinAggregateInputType = {
    id?: true
    role?: true
    organizationId?: true
    email?: true
    userId?: true
    status?: true
    createdAt?: true
  }

  export type OrganizationUserRoleMaxAggregateInputType = {
    id?: true
    role?: true
    organizationId?: true
    email?: true
    userId?: true
    status?: true
    createdAt?: true
  }

  export type OrganizationUserRoleCountAggregateInputType = {
    id?: true
    role?: true
    organizationId?: true
    email?: true
    userId?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type OrganizationUserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationUserRole to aggregate.
     */
    where?: OrganizationUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationUserRoles to fetch.
     */
    orderBy?: OrganizationUserRoleOrderByWithRelationInput | OrganizationUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationUserRoles
    **/
    _count?: true | OrganizationUserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationUserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationUserRoleMaxAggregateInputType
  }

  export type GetOrganizationUserRoleAggregateType<T extends OrganizationUserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationUserRole[P]>
      : GetScalarType<T[P], AggregateOrganizationUserRole[P]>
  }




  export type OrganizationUserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationUserRoleWhereInput
    orderBy?: OrganizationUserRoleOrderByWithAggregationInput | OrganizationUserRoleOrderByWithAggregationInput[]
    by: OrganizationUserRoleScalarFieldEnum[] | OrganizationUserRoleScalarFieldEnum
    having?: OrganizationUserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationUserRoleCountAggregateInputType | true
    _min?: OrganizationUserRoleMinAggregateInputType
    _max?: OrganizationUserRoleMaxAggregateInputType
  }

  export type OrganizationUserRoleGroupByOutputType = {
    id: string
    role: $Enums.OrganizationRole
    organizationId: string
    email: string
    userId: string | null
    status: string
    createdAt: Date
    _count: OrganizationUserRoleCountAggregateOutputType | null
    _min: OrganizationUserRoleMinAggregateOutputType | null
    _max: OrganizationUserRoleMaxAggregateOutputType | null
  }

  type GetOrganizationUserRoleGroupByPayload<T extends OrganizationUserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationUserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationUserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationUserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationUserRoleGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationUserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    organizationId?: boolean
    email?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationUserRole$organizationArgs<ExtArgs>
    user?: boolean | OrganizationUserRole$userArgs<ExtArgs>
  }, ExtArgs["result"]["organizationUserRole"]>

  export type OrganizationUserRoleSelectScalar = {
    id?: boolean
    role?: boolean
    organizationId?: boolean
    email?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type OrganizationUserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationUserRole$organizationArgs<ExtArgs>
    user?: boolean | OrganizationUserRole$userArgs<ExtArgs>
  }


  export type $OrganizationUserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationUserRole"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: $Enums.OrganizationRole
      organizationId: string
      email: string
      userId: string | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["organizationUserRole"]>
    composites: {}
  }


  type OrganizationUserRoleGetPayload<S extends boolean | null | undefined | OrganizationUserRoleDefaultArgs> = $Result.GetResult<Prisma.$OrganizationUserRolePayload, S>

  type OrganizationUserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationUserRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizationUserRoleCountAggregateInputType | true
    }

  export interface OrganizationUserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationUserRole'], meta: { name: 'OrganizationUserRole' } }
    /**
     * Find zero or one OrganizationUserRole that matches the filter.
     * @param {OrganizationUserRoleFindUniqueArgs} args - Arguments to find a OrganizationUserRole
     * @example
     * // Get one OrganizationUserRole
     * const organizationUserRole = await prisma.organizationUserRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrganizationUserRoleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUserRoleFindUniqueArgs<ExtArgs>>
    ): Prisma__OrganizationUserRoleClient<$Result.GetResult<Prisma.$OrganizationUserRolePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrganizationUserRole that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrganizationUserRoleFindUniqueOrThrowArgs} args - Arguments to find a OrganizationUserRole
     * @example
     * // Get one OrganizationUserRole
     * const organizationUserRole = await prisma.organizationUserRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrganizationUserRoleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationUserRoleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationUserRoleClient<$Result.GetResult<Prisma.$OrganizationUserRolePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrganizationUserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUserRoleFindFirstArgs} args - Arguments to find a OrganizationUserRole
     * @example
     * // Get one OrganizationUserRole
     * const organizationUserRole = await prisma.organizationUserRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrganizationUserRoleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationUserRoleFindFirstArgs<ExtArgs>>
    ): Prisma__OrganizationUserRoleClient<$Result.GetResult<Prisma.$OrganizationUserRolePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrganizationUserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUserRoleFindFirstOrThrowArgs} args - Arguments to find a OrganizationUserRole
     * @example
     * // Get one OrganizationUserRole
     * const organizationUserRole = await prisma.organizationUserRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrganizationUserRoleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationUserRoleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationUserRoleClient<$Result.GetResult<Prisma.$OrganizationUserRolePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrganizationUserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUserRoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationUserRoles
     * const organizationUserRoles = await prisma.organizationUserRole.findMany()
     * 
     * // Get first 10 OrganizationUserRoles
     * const organizationUserRoles = await prisma.organizationUserRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationUserRoleWithIdOnly = await prisma.organizationUserRole.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrganizationUserRoleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationUserRoleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationUserRolePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrganizationUserRole.
     * @param {OrganizationUserRoleCreateArgs} args - Arguments to create a OrganizationUserRole.
     * @example
     * // Create one OrganizationUserRole
     * const OrganizationUserRole = await prisma.organizationUserRole.create({
     *   data: {
     *     // ... data to create a OrganizationUserRole
     *   }
     * })
     * 
    **/
    create<T extends OrganizationUserRoleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUserRoleCreateArgs<ExtArgs>>
    ): Prisma__OrganizationUserRoleClient<$Result.GetResult<Prisma.$OrganizationUserRolePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrganizationUserRoles.
     *     @param {OrganizationUserRoleCreateManyArgs} args - Arguments to create many OrganizationUserRoles.
     *     @example
     *     // Create many OrganizationUserRoles
     *     const organizationUserRole = await prisma.organizationUserRole.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrganizationUserRoleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationUserRoleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrganizationUserRole.
     * @param {OrganizationUserRoleDeleteArgs} args - Arguments to delete one OrganizationUserRole.
     * @example
     * // Delete one OrganizationUserRole
     * const OrganizationUserRole = await prisma.organizationUserRole.delete({
     *   where: {
     *     // ... filter to delete one OrganizationUserRole
     *   }
     * })
     * 
    **/
    delete<T extends OrganizationUserRoleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUserRoleDeleteArgs<ExtArgs>>
    ): Prisma__OrganizationUserRoleClient<$Result.GetResult<Prisma.$OrganizationUserRolePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrganizationUserRole.
     * @param {OrganizationUserRoleUpdateArgs} args - Arguments to update one OrganizationUserRole.
     * @example
     * // Update one OrganizationUserRole
     * const organizationUserRole = await prisma.organizationUserRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrganizationUserRoleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUserRoleUpdateArgs<ExtArgs>>
    ): Prisma__OrganizationUserRoleClient<$Result.GetResult<Prisma.$OrganizationUserRolePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrganizationUserRoles.
     * @param {OrganizationUserRoleDeleteManyArgs} args - Arguments to filter OrganizationUserRoles to delete.
     * @example
     * // Delete a few OrganizationUserRoles
     * const { count } = await prisma.organizationUserRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrganizationUserRoleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationUserRoleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationUserRoles
     * const organizationUserRole = await prisma.organizationUserRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrganizationUserRoleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUserRoleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrganizationUserRole.
     * @param {OrganizationUserRoleUpsertArgs} args - Arguments to update or create a OrganizationUserRole.
     * @example
     * // Update or create a OrganizationUserRole
     * const organizationUserRole = await prisma.organizationUserRole.upsert({
     *   create: {
     *     // ... data to create a OrganizationUserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationUserRole we want to update
     *   }
     * })
    **/
    upsert<T extends OrganizationUserRoleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUserRoleUpsertArgs<ExtArgs>>
    ): Prisma__OrganizationUserRoleClient<$Result.GetResult<Prisma.$OrganizationUserRolePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrganizationUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUserRoleCountArgs} args - Arguments to filter OrganizationUserRoles to count.
     * @example
     * // Count the number of OrganizationUserRoles
     * const count = await prisma.organizationUserRole.count({
     *   where: {
     *     // ... the filter for the OrganizationUserRoles we want to count
     *   }
     * })
    **/
    count<T extends OrganizationUserRoleCountArgs>(
      args?: Subset<T, OrganizationUserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationUserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationUserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationUserRoleAggregateArgs>(args: Subset<T, OrganizationUserRoleAggregateArgs>): Prisma.PrismaPromise<GetOrganizationUserRoleAggregateType<T>>

    /**
     * Group by OrganizationUserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationUserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationUserRoleGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationUserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationUserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationUserRole model
   */
  readonly fields: OrganizationUserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationUserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationUserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    organization<T extends OrganizationUserRole$organizationArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationUserRole$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    user<T extends OrganizationUserRole$userArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationUserRole$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OrganizationUserRole model
   */ 
  interface OrganizationUserRoleFieldRefs {
    readonly id: FieldRef<"OrganizationUserRole", 'String'>
    readonly role: FieldRef<"OrganizationUserRole", 'OrganizationRole'>
    readonly organizationId: FieldRef<"OrganizationUserRole", 'String'>
    readonly email: FieldRef<"OrganizationUserRole", 'String'>
    readonly userId: FieldRef<"OrganizationUserRole", 'String'>
    readonly status: FieldRef<"OrganizationUserRole", 'String'>
    readonly createdAt: FieldRef<"OrganizationUserRole", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * OrganizationUserRole findUnique
   */
  export type OrganizationUserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUserRole
     */
    select?: OrganizationUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationUserRole to fetch.
     */
    where: OrganizationUserRoleWhereUniqueInput
  }


  /**
   * OrganizationUserRole findUniqueOrThrow
   */
  export type OrganizationUserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUserRole
     */
    select?: OrganizationUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationUserRole to fetch.
     */
    where: OrganizationUserRoleWhereUniqueInput
  }


  /**
   * OrganizationUserRole findFirst
   */
  export type OrganizationUserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUserRole
     */
    select?: OrganizationUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationUserRole to fetch.
     */
    where?: OrganizationUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationUserRoles to fetch.
     */
    orderBy?: OrganizationUserRoleOrderByWithRelationInput | OrganizationUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationUserRoles.
     */
    cursor?: OrganizationUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationUserRoles.
     */
    distinct?: OrganizationUserRoleScalarFieldEnum | OrganizationUserRoleScalarFieldEnum[]
  }


  /**
   * OrganizationUserRole findFirstOrThrow
   */
  export type OrganizationUserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUserRole
     */
    select?: OrganizationUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationUserRole to fetch.
     */
    where?: OrganizationUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationUserRoles to fetch.
     */
    orderBy?: OrganizationUserRoleOrderByWithRelationInput | OrganizationUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationUserRoles.
     */
    cursor?: OrganizationUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationUserRoles.
     */
    distinct?: OrganizationUserRoleScalarFieldEnum | OrganizationUserRoleScalarFieldEnum[]
  }


  /**
   * OrganizationUserRole findMany
   */
  export type OrganizationUserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUserRole
     */
    select?: OrganizationUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationUserRoles to fetch.
     */
    where?: OrganizationUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationUserRoles to fetch.
     */
    orderBy?: OrganizationUserRoleOrderByWithRelationInput | OrganizationUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationUserRoles.
     */
    cursor?: OrganizationUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationUserRoles.
     */
    skip?: number
    distinct?: OrganizationUserRoleScalarFieldEnum | OrganizationUserRoleScalarFieldEnum[]
  }


  /**
   * OrganizationUserRole create
   */
  export type OrganizationUserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUserRole
     */
    select?: OrganizationUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationUserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationUserRole.
     */
    data: XOR<OrganizationUserRoleCreateInput, OrganizationUserRoleUncheckedCreateInput>
  }


  /**
   * OrganizationUserRole createMany
   */
  export type OrganizationUserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationUserRoles.
     */
    data: OrganizationUserRoleCreateManyInput | OrganizationUserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OrganizationUserRole update
   */
  export type OrganizationUserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUserRole
     */
    select?: OrganizationUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationUserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationUserRole.
     */
    data: XOR<OrganizationUserRoleUpdateInput, OrganizationUserRoleUncheckedUpdateInput>
    /**
     * Choose, which OrganizationUserRole to update.
     */
    where: OrganizationUserRoleWhereUniqueInput
  }


  /**
   * OrganizationUserRole updateMany
   */
  export type OrganizationUserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationUserRoles.
     */
    data: XOR<OrganizationUserRoleUpdateManyMutationInput, OrganizationUserRoleUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationUserRoles to update
     */
    where?: OrganizationUserRoleWhereInput
  }


  /**
   * OrganizationUserRole upsert
   */
  export type OrganizationUserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUserRole
     */
    select?: OrganizationUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationUserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationUserRole to update in case it exists.
     */
    where: OrganizationUserRoleWhereUniqueInput
    /**
     * In case the OrganizationUserRole found by the `where` argument doesn't exist, create a new OrganizationUserRole with this data.
     */
    create: XOR<OrganizationUserRoleCreateInput, OrganizationUserRoleUncheckedCreateInput>
    /**
     * In case the OrganizationUserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUserRoleUpdateInput, OrganizationUserRoleUncheckedUpdateInput>
  }


  /**
   * OrganizationUserRole delete
   */
  export type OrganizationUserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUserRole
     */
    select?: OrganizationUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationUserRoleInclude<ExtArgs> | null
    /**
     * Filter which OrganizationUserRole to delete.
     */
    where: OrganizationUserRoleWhereUniqueInput
  }


  /**
   * OrganizationUserRole deleteMany
   */
  export type OrganizationUserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationUserRoles to delete
     */
    where?: OrganizationUserRoleWhereInput
  }


  /**
   * OrganizationUserRole.organization
   */
  export type OrganizationUserRole$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }


  /**
   * OrganizationUserRole.user
   */
  export type OrganizationUserRole$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * OrganizationUserRole without action
   */
  export type OrganizationUserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUserRole
     */
    select?: OrganizationUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationUserRoleInclude<ExtArgs> | null
  }



  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: $Enums.UserRole | null
    isTwoFactorEnabled: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: $Enums.UserRole | null
    isTwoFactorEnabled: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    password: number
    role: number
    isTwoFactorEnabled: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    isTwoFactorEnabled?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    isTwoFactorEnabled?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    isTwoFactorEnabled?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: $Enums.UserRole
    isTwoFactorEnabled: boolean
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    isTwoFactorEnabled?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    organizations?: boolean | User$organizationsArgs<ExtArgs>
    twoFactorConfirmation?: boolean | User$twoFactorConfirmationArgs<ExtArgs>
    candidateTimeline?: boolean | User$candidateTimelineArgs<ExtArgs>
    emailMessage?: boolean | User$emailMessageArgs<ExtArgs>
    organizationSubscription?: boolean | User$organizationSubscriptionArgs<ExtArgs>
    NotificationReceipt?: boolean | User$NotificationReceiptArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    isTwoFactorEnabled?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    organizations?: boolean | User$organizationsArgs<ExtArgs>
    twoFactorConfirmation?: boolean | User$twoFactorConfirmationArgs<ExtArgs>
    candidateTimeline?: boolean | User$candidateTimelineArgs<ExtArgs>
    emailMessage?: boolean | User$emailMessageArgs<ExtArgs>
    organizationSubscription?: boolean | User$organizationSubscriptionArgs<ExtArgs>
    NotificationReceipt?: boolean | User$NotificationReceiptArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      organizations: Prisma.$OrganizationUserRolePayload<ExtArgs>[]
      twoFactorConfirmation: Prisma.$TwoFactorConfirmationPayload<ExtArgs> | null
      candidateTimeline: Prisma.$CandidateTimelinePayload<ExtArgs>[]
      emailMessage: Prisma.$EmailMessagePayload<ExtArgs>[]
      organizationSubscription: Prisma.$OrganizationSubscriptionPayload<ExtArgs>[]
      NotificationReceipt: Prisma.$NotificationReceiptPayload<ExtArgs>[]
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      emailVerified: Date | null
      image: string | null
      password: string | null
      role: $Enums.UserRole
      isTwoFactorEnabled: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'> | Null>;

    organizations<T extends User$organizationsArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationUserRolePayload<ExtArgs>, T, 'findMany'> | Null>;

    twoFactorConfirmation<T extends User$twoFactorConfirmationArgs<ExtArgs> = {}>(args?: Subset<T, User$twoFactorConfirmationArgs<ExtArgs>>): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    candidateTimeline<T extends User$candidateTimelineArgs<ExtArgs> = {}>(args?: Subset<T, User$candidateTimelineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidateTimelinePayload<ExtArgs>, T, 'findMany'> | Null>;

    emailMessage<T extends User$emailMessageArgs<ExtArgs> = {}>(args?: Subset<T, User$emailMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    organizationSubscription<T extends User$organizationSubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationSubscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationSubscriptionPayload<ExtArgs>, T, 'findMany'> | Null>;

    NotificationReceipt<T extends User$NotificationReceiptArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationReceiptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationReceiptPayload<ExtArgs>, T, 'findMany'> | Null>;

    Notification<T extends User$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isTwoFactorEnabled: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * User.organizations
   */
  export type User$organizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUserRole
     */
    select?: OrganizationUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationUserRoleInclude<ExtArgs> | null
    where?: OrganizationUserRoleWhereInput
    orderBy?: OrganizationUserRoleOrderByWithRelationInput | OrganizationUserRoleOrderByWithRelationInput[]
    cursor?: OrganizationUserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationUserRoleScalarFieldEnum | OrganizationUserRoleScalarFieldEnum[]
  }


  /**
   * User.twoFactorConfirmation
   */
  export type User$twoFactorConfirmationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    where?: TwoFactorConfirmationWhereInput
  }


  /**
   * User.candidateTimeline
   */
  export type User$candidateTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateTimeline
     */
    select?: CandidateTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateTimelineInclude<ExtArgs> | null
    where?: CandidateTimelineWhereInput
    orderBy?: CandidateTimelineOrderByWithRelationInput | CandidateTimelineOrderByWithRelationInput[]
    cursor?: CandidateTimelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CandidateTimelineScalarFieldEnum | CandidateTimelineScalarFieldEnum[]
  }


  /**
   * User.emailMessage
   */
  export type User$emailMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailMessageInclude<ExtArgs> | null
    where?: EmailMessageWhereInput
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    cursor?: EmailMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }


  /**
   * User.organizationSubscription
   */
  export type User$organizationSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSubscription
     */
    select?: OrganizationSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSubscriptionInclude<ExtArgs> | null
    where?: OrganizationSubscriptionWhereInput
    orderBy?: OrganizationSubscriptionOrderByWithRelationInput | OrganizationSubscriptionOrderByWithRelationInput[]
    cursor?: OrganizationSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationSubscriptionScalarFieldEnum | OrganizationSubscriptionScalarFieldEnum[]
  }


  /**
   * User.NotificationReceipt
   */
  export type User$NotificationReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationReceipt
     */
    select?: NotificationReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationReceiptInclude<ExtArgs> | null
    where?: NotificationReceiptWhereInput
    orderBy?: NotificationReceiptOrderByWithRelationInput | NotificationReceiptOrderByWithRelationInput[]
    cursor?: NotificationReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationReceiptScalarFieldEnum | NotificationReceiptScalarFieldEnum[]
  }


  /**
   * User.Notification
   */
  export type User$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }


  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }


  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
  }



  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }


  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }


  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VerificationTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one VerificationToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VerificationTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VerificationTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
    **/
    create<T extends VerificationTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many VerificationTokens.
     *     @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     *     @example
     *     // Create many VerificationTokens
     *     const verificationToken = await prisma.verificationToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VerificationTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
    **/
    delete<T extends VerificationTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VerificationTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VerificationTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VerificationTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
    **/
    upsert<T extends VerificationTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the VerificationToken model
   */ 
  interface VerificationTokenFieldRefs {
    readonly id: FieldRef<"VerificationToken", 'String'>
    readonly email: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }


  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }


  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }


  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }


  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }


  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
  }



  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }


  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }


  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PasswordResetTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PasswordResetTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>
    ): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PasswordResetTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
    **/
    create<T extends PasswordResetTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>
    ): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PasswordResetTokens.
     *     @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     *     @example
     *     // Create many PasswordResetTokens
     *     const passwordResetToken = await prisma.passwordResetToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PasswordResetTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
    **/
    delete<T extends PasswordResetTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>
    ): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PasswordResetTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>
    ): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PasswordResetTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PasswordResetTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
    **/
    upsert<T extends PasswordResetTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>
    ): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PasswordResetToken model
   */ 
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly email: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expires: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }


  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }


  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }


  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }


  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }


  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }


  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }


  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
  }


  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }


  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }


  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
  }


  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
  }



  /**
   * Model TwoFactorToken
   */

  export type AggregateTwoFactorToken = {
    _count: TwoFactorTokenCountAggregateOutputType | null
    _min: TwoFactorTokenMinAggregateOutputType | null
    _max: TwoFactorTokenMaxAggregateOutputType | null
  }

  export type TwoFactorTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type TwoFactorTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type TwoFactorTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    _all: number
  }


  export type TwoFactorTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type TwoFactorTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type TwoFactorTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type TwoFactorTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorToken to aggregate.
     */
    where?: TwoFactorTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorTokens to fetch.
     */
    orderBy?: TwoFactorTokenOrderByWithRelationInput | TwoFactorTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwoFactorTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwoFactorTokens
    **/
    _count?: true | TwoFactorTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwoFactorTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwoFactorTokenMaxAggregateInputType
  }

  export type GetTwoFactorTokenAggregateType<T extends TwoFactorTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateTwoFactorToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwoFactorToken[P]>
      : GetScalarType<T[P], AggregateTwoFactorToken[P]>
  }




  export type TwoFactorTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorTokenWhereInput
    orderBy?: TwoFactorTokenOrderByWithAggregationInput | TwoFactorTokenOrderByWithAggregationInput[]
    by: TwoFactorTokenScalarFieldEnum[] | TwoFactorTokenScalarFieldEnum
    having?: TwoFactorTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwoFactorTokenCountAggregateInputType | true
    _min?: TwoFactorTokenMinAggregateInputType
    _max?: TwoFactorTokenMaxAggregateInputType
  }

  export type TwoFactorTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    _count: TwoFactorTokenCountAggregateOutputType | null
    _min: TwoFactorTokenMinAggregateOutputType | null
    _max: TwoFactorTokenMaxAggregateOutputType | null
  }

  type GetTwoFactorTokenGroupByPayload<T extends TwoFactorTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TwoFactorTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwoFactorTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwoFactorTokenGroupByOutputType[P]>
            : GetScalarType<T[P], TwoFactorTokenGroupByOutputType[P]>
        }
      >
    >


  export type TwoFactorTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["twoFactorToken"]>

  export type TwoFactorTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }


  export type $TwoFactorTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TwoFactorToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
    }, ExtArgs["result"]["twoFactorToken"]>
    composites: {}
  }


  type TwoFactorTokenGetPayload<S extends boolean | null | undefined | TwoFactorTokenDefaultArgs> = $Result.GetResult<Prisma.$TwoFactorTokenPayload, S>

  type TwoFactorTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TwoFactorTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TwoFactorTokenCountAggregateInputType | true
    }

  export interface TwoFactorTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwoFactorToken'], meta: { name: 'TwoFactorToken' } }
    /**
     * Find zero or one TwoFactorToken that matches the filter.
     * @param {TwoFactorTokenFindUniqueArgs} args - Arguments to find a TwoFactorToken
     * @example
     * // Get one TwoFactorToken
     * const twoFactorToken = await prisma.twoFactorToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwoFactorTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFactorTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__TwoFactorTokenClient<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TwoFactorToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwoFactorTokenFindUniqueOrThrowArgs} args - Arguments to find a TwoFactorToken
     * @example
     * // Get one TwoFactorToken
     * const twoFactorToken = await prisma.twoFactorToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwoFactorTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFactorTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TwoFactorTokenClient<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TwoFactorToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorTokenFindFirstArgs} args - Arguments to find a TwoFactorToken
     * @example
     * // Get one TwoFactorToken
     * const twoFactorToken = await prisma.twoFactorToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwoFactorTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFactorTokenFindFirstArgs<ExtArgs>>
    ): Prisma__TwoFactorTokenClient<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TwoFactorToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorTokenFindFirstOrThrowArgs} args - Arguments to find a TwoFactorToken
     * @example
     * // Get one TwoFactorToken
     * const twoFactorToken = await prisma.twoFactorToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwoFactorTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFactorTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TwoFactorTokenClient<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TwoFactorTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwoFactorTokens
     * const twoFactorTokens = await prisma.twoFactorToken.findMany()
     * 
     * // Get first 10 TwoFactorTokens
     * const twoFactorTokens = await prisma.twoFactorToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twoFactorTokenWithIdOnly = await prisma.twoFactorToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwoFactorTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFactorTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TwoFactorToken.
     * @param {TwoFactorTokenCreateArgs} args - Arguments to create a TwoFactorToken.
     * @example
     * // Create one TwoFactorToken
     * const TwoFactorToken = await prisma.twoFactorToken.create({
     *   data: {
     *     // ... data to create a TwoFactorToken
     *   }
     * })
     * 
    **/
    create<T extends TwoFactorTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFactorTokenCreateArgs<ExtArgs>>
    ): Prisma__TwoFactorTokenClient<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TwoFactorTokens.
     *     @param {TwoFactorTokenCreateManyArgs} args - Arguments to create many TwoFactorTokens.
     *     @example
     *     // Create many TwoFactorTokens
     *     const twoFactorToken = await prisma.twoFactorToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwoFactorTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFactorTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwoFactorToken.
     * @param {TwoFactorTokenDeleteArgs} args - Arguments to delete one TwoFactorToken.
     * @example
     * // Delete one TwoFactorToken
     * const TwoFactorToken = await prisma.twoFactorToken.delete({
     *   where: {
     *     // ... filter to delete one TwoFactorToken
     *   }
     * })
     * 
    **/
    delete<T extends TwoFactorTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFactorTokenDeleteArgs<ExtArgs>>
    ): Prisma__TwoFactorTokenClient<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TwoFactorToken.
     * @param {TwoFactorTokenUpdateArgs} args - Arguments to update one TwoFactorToken.
     * @example
     * // Update one TwoFactorToken
     * const twoFactorToken = await prisma.twoFactorToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwoFactorTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFactorTokenUpdateArgs<ExtArgs>>
    ): Prisma__TwoFactorTokenClient<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TwoFactorTokens.
     * @param {TwoFactorTokenDeleteManyArgs} args - Arguments to filter TwoFactorTokens to delete.
     * @example
     * // Delete a few TwoFactorTokens
     * const { count } = await prisma.twoFactorToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwoFactorTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFactorTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwoFactorTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwoFactorTokens
     * const twoFactorToken = await prisma.twoFactorToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwoFactorTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFactorTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwoFactorToken.
     * @param {TwoFactorTokenUpsertArgs} args - Arguments to update or create a TwoFactorToken.
     * @example
     * // Update or create a TwoFactorToken
     * const twoFactorToken = await prisma.twoFactorToken.upsert({
     *   create: {
     *     // ... data to create a TwoFactorToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwoFactorToken we want to update
     *   }
     * })
    **/
    upsert<T extends TwoFactorTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFactorTokenUpsertArgs<ExtArgs>>
    ): Prisma__TwoFactorTokenClient<$Result.GetResult<Prisma.$TwoFactorTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TwoFactorTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorTokenCountArgs} args - Arguments to filter TwoFactorTokens to count.
     * @example
     * // Count the number of TwoFactorTokens
     * const count = await prisma.twoFactorToken.count({
     *   where: {
     *     // ... the filter for the TwoFactorTokens we want to count
     *   }
     * })
    **/
    count<T extends TwoFactorTokenCountArgs>(
      args?: Subset<T, TwoFactorTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwoFactorTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwoFactorToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwoFactorTokenAggregateArgs>(args: Subset<T, TwoFactorTokenAggregateArgs>): Prisma.PrismaPromise<GetTwoFactorTokenAggregateType<T>>

    /**
     * Group by TwoFactorToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwoFactorTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwoFactorTokenGroupByArgs['orderBy'] }
        : { orderBy?: TwoFactorTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwoFactorTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwoFactorTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TwoFactorToken model
   */
  readonly fields: TwoFactorTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TwoFactorToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TwoFactorTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TwoFactorToken model
   */ 
  interface TwoFactorTokenFieldRefs {
    readonly id: FieldRef<"TwoFactorToken", 'String'>
    readonly email: FieldRef<"TwoFactorToken", 'String'>
    readonly token: FieldRef<"TwoFactorToken", 'String'>
    readonly expires: FieldRef<"TwoFactorToken", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * TwoFactorToken findUnique
   */
  export type TwoFactorTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * Filter, which TwoFactorToken to fetch.
     */
    where: TwoFactorTokenWhereUniqueInput
  }


  /**
   * TwoFactorToken findUniqueOrThrow
   */
  export type TwoFactorTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * Filter, which TwoFactorToken to fetch.
     */
    where: TwoFactorTokenWhereUniqueInput
  }


  /**
   * TwoFactorToken findFirst
   */
  export type TwoFactorTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * Filter, which TwoFactorToken to fetch.
     */
    where?: TwoFactorTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorTokens to fetch.
     */
    orderBy?: TwoFactorTokenOrderByWithRelationInput | TwoFactorTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorTokens.
     */
    cursor?: TwoFactorTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorTokens.
     */
    distinct?: TwoFactorTokenScalarFieldEnum | TwoFactorTokenScalarFieldEnum[]
  }


  /**
   * TwoFactorToken findFirstOrThrow
   */
  export type TwoFactorTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * Filter, which TwoFactorToken to fetch.
     */
    where?: TwoFactorTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorTokens to fetch.
     */
    orderBy?: TwoFactorTokenOrderByWithRelationInput | TwoFactorTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorTokens.
     */
    cursor?: TwoFactorTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorTokens.
     */
    distinct?: TwoFactorTokenScalarFieldEnum | TwoFactorTokenScalarFieldEnum[]
  }


  /**
   * TwoFactorToken findMany
   */
  export type TwoFactorTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * Filter, which TwoFactorTokens to fetch.
     */
    where?: TwoFactorTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorTokens to fetch.
     */
    orderBy?: TwoFactorTokenOrderByWithRelationInput | TwoFactorTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwoFactorTokens.
     */
    cursor?: TwoFactorTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorTokens.
     */
    skip?: number
    distinct?: TwoFactorTokenScalarFieldEnum | TwoFactorTokenScalarFieldEnum[]
  }


  /**
   * TwoFactorToken create
   */
  export type TwoFactorTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a TwoFactorToken.
     */
    data: XOR<TwoFactorTokenCreateInput, TwoFactorTokenUncheckedCreateInput>
  }


  /**
   * TwoFactorToken createMany
   */
  export type TwoFactorTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwoFactorTokens.
     */
    data: TwoFactorTokenCreateManyInput | TwoFactorTokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TwoFactorToken update
   */
  export type TwoFactorTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a TwoFactorToken.
     */
    data: XOR<TwoFactorTokenUpdateInput, TwoFactorTokenUncheckedUpdateInput>
    /**
     * Choose, which TwoFactorToken to update.
     */
    where: TwoFactorTokenWhereUniqueInput
  }


  /**
   * TwoFactorToken updateMany
   */
  export type TwoFactorTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwoFactorTokens.
     */
    data: XOR<TwoFactorTokenUpdateManyMutationInput, TwoFactorTokenUncheckedUpdateManyInput>
    /**
     * Filter which TwoFactorTokens to update
     */
    where?: TwoFactorTokenWhereInput
  }


  /**
   * TwoFactorToken upsert
   */
  export type TwoFactorTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the TwoFactorToken to update in case it exists.
     */
    where: TwoFactorTokenWhereUniqueInput
    /**
     * In case the TwoFactorToken found by the `where` argument doesn't exist, create a new TwoFactorToken with this data.
     */
    create: XOR<TwoFactorTokenCreateInput, TwoFactorTokenUncheckedCreateInput>
    /**
     * In case the TwoFactorToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwoFactorTokenUpdateInput, TwoFactorTokenUncheckedUpdateInput>
  }


  /**
   * TwoFactorToken delete
   */
  export type TwoFactorTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
    /**
     * Filter which TwoFactorToken to delete.
     */
    where: TwoFactorTokenWhereUniqueInput
  }


  /**
   * TwoFactorToken deleteMany
   */
  export type TwoFactorTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorTokens to delete
     */
    where?: TwoFactorTokenWhereInput
  }


  /**
   * TwoFactorToken without action
   */
  export type TwoFactorTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorToken
     */
    select?: TwoFactorTokenSelect<ExtArgs> | null
  }



  /**
   * Model TwoFactorConfirmation
   */

  export type AggregateTwoFactorConfirmation = {
    _count: TwoFactorConfirmationCountAggregateOutputType | null
    _min: TwoFactorConfirmationMinAggregateOutputType | null
    _max: TwoFactorConfirmationMaxAggregateOutputType | null
  }

  export type TwoFactorConfirmationMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type TwoFactorConfirmationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type TwoFactorConfirmationCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type TwoFactorConfirmationMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TwoFactorConfirmationMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TwoFactorConfirmationCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type TwoFactorConfirmationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorConfirmation to aggregate.
     */
    where?: TwoFactorConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorConfirmations to fetch.
     */
    orderBy?: TwoFactorConfirmationOrderByWithRelationInput | TwoFactorConfirmationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwoFactorConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorConfirmations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorConfirmations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwoFactorConfirmations
    **/
    _count?: true | TwoFactorConfirmationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwoFactorConfirmationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwoFactorConfirmationMaxAggregateInputType
  }

  export type GetTwoFactorConfirmationAggregateType<T extends TwoFactorConfirmationAggregateArgs> = {
        [P in keyof T & keyof AggregateTwoFactorConfirmation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwoFactorConfirmation[P]>
      : GetScalarType<T[P], AggregateTwoFactorConfirmation[P]>
  }




  export type TwoFactorConfirmationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorConfirmationWhereInput
    orderBy?: TwoFactorConfirmationOrderByWithAggregationInput | TwoFactorConfirmationOrderByWithAggregationInput[]
    by: TwoFactorConfirmationScalarFieldEnum[] | TwoFactorConfirmationScalarFieldEnum
    having?: TwoFactorConfirmationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwoFactorConfirmationCountAggregateInputType | true
    _min?: TwoFactorConfirmationMinAggregateInputType
    _max?: TwoFactorConfirmationMaxAggregateInputType
  }

  export type TwoFactorConfirmationGroupByOutputType = {
    id: string
    userId: string
    _count: TwoFactorConfirmationCountAggregateOutputType | null
    _min: TwoFactorConfirmationMinAggregateOutputType | null
    _max: TwoFactorConfirmationMaxAggregateOutputType | null
  }

  type GetTwoFactorConfirmationGroupByPayload<T extends TwoFactorConfirmationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TwoFactorConfirmationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwoFactorConfirmationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwoFactorConfirmationGroupByOutputType[P]>
            : GetScalarType<T[P], TwoFactorConfirmationGroupByOutputType[P]>
        }
      >
    >


  export type TwoFactorConfirmationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactorConfirmation"]>

  export type TwoFactorConfirmationSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type TwoFactorConfirmationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $TwoFactorConfirmationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TwoFactorConfirmation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
    }, ExtArgs["result"]["twoFactorConfirmation"]>
    composites: {}
  }


  type TwoFactorConfirmationGetPayload<S extends boolean | null | undefined | TwoFactorConfirmationDefaultArgs> = $Result.GetResult<Prisma.$TwoFactorConfirmationPayload, S>

  type TwoFactorConfirmationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TwoFactorConfirmationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TwoFactorConfirmationCountAggregateInputType | true
    }

  export interface TwoFactorConfirmationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwoFactorConfirmation'], meta: { name: 'TwoFactorConfirmation' } }
    /**
     * Find zero or one TwoFactorConfirmation that matches the filter.
     * @param {TwoFactorConfirmationFindUniqueArgs} args - Arguments to find a TwoFactorConfirmation
     * @example
     * // Get one TwoFactorConfirmation
     * const twoFactorConfirmation = await prisma.twoFactorConfirmation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwoFactorConfirmationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFactorConfirmationFindUniqueArgs<ExtArgs>>
    ): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TwoFactorConfirmation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwoFactorConfirmationFindUniqueOrThrowArgs} args - Arguments to find a TwoFactorConfirmation
     * @example
     * // Get one TwoFactorConfirmation
     * const twoFactorConfirmation = await prisma.twoFactorConfirmation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwoFactorConfirmationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFactorConfirmationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TwoFactorConfirmation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorConfirmationFindFirstArgs} args - Arguments to find a TwoFactorConfirmation
     * @example
     * // Get one TwoFactorConfirmation
     * const twoFactorConfirmation = await prisma.twoFactorConfirmation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwoFactorConfirmationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFactorConfirmationFindFirstArgs<ExtArgs>>
    ): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TwoFactorConfirmation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorConfirmationFindFirstOrThrowArgs} args - Arguments to find a TwoFactorConfirmation
     * @example
     * // Get one TwoFactorConfirmation
     * const twoFactorConfirmation = await prisma.twoFactorConfirmation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwoFactorConfirmationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFactorConfirmationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TwoFactorConfirmations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorConfirmationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwoFactorConfirmations
     * const twoFactorConfirmations = await prisma.twoFactorConfirmation.findMany()
     * 
     * // Get first 10 TwoFactorConfirmations
     * const twoFactorConfirmations = await prisma.twoFactorConfirmation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twoFactorConfirmationWithIdOnly = await prisma.twoFactorConfirmation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwoFactorConfirmationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFactorConfirmationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TwoFactorConfirmation.
     * @param {TwoFactorConfirmationCreateArgs} args - Arguments to create a TwoFactorConfirmation.
     * @example
     * // Create one TwoFactorConfirmation
     * const TwoFactorConfirmation = await prisma.twoFactorConfirmation.create({
     *   data: {
     *     // ... data to create a TwoFactorConfirmation
     *   }
     * })
     * 
    **/
    create<T extends TwoFactorConfirmationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFactorConfirmationCreateArgs<ExtArgs>>
    ): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TwoFactorConfirmations.
     *     @param {TwoFactorConfirmationCreateManyArgs} args - Arguments to create many TwoFactorConfirmations.
     *     @example
     *     // Create many TwoFactorConfirmations
     *     const twoFactorConfirmation = await prisma.twoFactorConfirmation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwoFactorConfirmationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFactorConfirmationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwoFactorConfirmation.
     * @param {TwoFactorConfirmationDeleteArgs} args - Arguments to delete one TwoFactorConfirmation.
     * @example
     * // Delete one TwoFactorConfirmation
     * const TwoFactorConfirmation = await prisma.twoFactorConfirmation.delete({
     *   where: {
     *     // ... filter to delete one TwoFactorConfirmation
     *   }
     * })
     * 
    **/
    delete<T extends TwoFactorConfirmationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFactorConfirmationDeleteArgs<ExtArgs>>
    ): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TwoFactorConfirmation.
     * @param {TwoFactorConfirmationUpdateArgs} args - Arguments to update one TwoFactorConfirmation.
     * @example
     * // Update one TwoFactorConfirmation
     * const twoFactorConfirmation = await prisma.twoFactorConfirmation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwoFactorConfirmationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFactorConfirmationUpdateArgs<ExtArgs>>
    ): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TwoFactorConfirmations.
     * @param {TwoFactorConfirmationDeleteManyArgs} args - Arguments to filter TwoFactorConfirmations to delete.
     * @example
     * // Delete a few TwoFactorConfirmations
     * const { count } = await prisma.twoFactorConfirmation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwoFactorConfirmationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFactorConfirmationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwoFactorConfirmations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorConfirmationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwoFactorConfirmations
     * const twoFactorConfirmation = await prisma.twoFactorConfirmation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwoFactorConfirmationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFactorConfirmationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwoFactorConfirmation.
     * @param {TwoFactorConfirmationUpsertArgs} args - Arguments to update or create a TwoFactorConfirmation.
     * @example
     * // Update or create a TwoFactorConfirmation
     * const twoFactorConfirmation = await prisma.twoFactorConfirmation.upsert({
     *   create: {
     *     // ... data to create a TwoFactorConfirmation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwoFactorConfirmation we want to update
     *   }
     * })
    **/
    upsert<T extends TwoFactorConfirmationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFactorConfirmationUpsertArgs<ExtArgs>>
    ): Prisma__TwoFactorConfirmationClient<$Result.GetResult<Prisma.$TwoFactorConfirmationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TwoFactorConfirmations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorConfirmationCountArgs} args - Arguments to filter TwoFactorConfirmations to count.
     * @example
     * // Count the number of TwoFactorConfirmations
     * const count = await prisma.twoFactorConfirmation.count({
     *   where: {
     *     // ... the filter for the TwoFactorConfirmations we want to count
     *   }
     * })
    **/
    count<T extends TwoFactorConfirmationCountArgs>(
      args?: Subset<T, TwoFactorConfirmationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwoFactorConfirmationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwoFactorConfirmation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorConfirmationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwoFactorConfirmationAggregateArgs>(args: Subset<T, TwoFactorConfirmationAggregateArgs>): Prisma.PrismaPromise<GetTwoFactorConfirmationAggregateType<T>>

    /**
     * Group by TwoFactorConfirmation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorConfirmationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwoFactorConfirmationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwoFactorConfirmationGroupByArgs['orderBy'] }
        : { orderBy?: TwoFactorConfirmationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwoFactorConfirmationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwoFactorConfirmationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TwoFactorConfirmation model
   */
  readonly fields: TwoFactorConfirmationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TwoFactorConfirmation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TwoFactorConfirmationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TwoFactorConfirmation model
   */ 
  interface TwoFactorConfirmationFieldRefs {
    readonly id: FieldRef<"TwoFactorConfirmation", 'String'>
    readonly userId: FieldRef<"TwoFactorConfirmation", 'String'>
  }
    

  // Custom InputTypes

  /**
   * TwoFactorConfirmation findUnique
   */
  export type TwoFactorConfirmationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorConfirmation to fetch.
     */
    where: TwoFactorConfirmationWhereUniqueInput
  }


  /**
   * TwoFactorConfirmation findUniqueOrThrow
   */
  export type TwoFactorConfirmationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorConfirmation to fetch.
     */
    where: TwoFactorConfirmationWhereUniqueInput
  }


  /**
   * TwoFactorConfirmation findFirst
   */
  export type TwoFactorConfirmationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorConfirmation to fetch.
     */
    where?: TwoFactorConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorConfirmations to fetch.
     */
    orderBy?: TwoFactorConfirmationOrderByWithRelationInput | TwoFactorConfirmationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorConfirmations.
     */
    cursor?: TwoFactorConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorConfirmations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorConfirmations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorConfirmations.
     */
    distinct?: TwoFactorConfirmationScalarFieldEnum | TwoFactorConfirmationScalarFieldEnum[]
  }


  /**
   * TwoFactorConfirmation findFirstOrThrow
   */
  export type TwoFactorConfirmationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorConfirmation to fetch.
     */
    where?: TwoFactorConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorConfirmations to fetch.
     */
    orderBy?: TwoFactorConfirmationOrderByWithRelationInput | TwoFactorConfirmationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorConfirmations.
     */
    cursor?: TwoFactorConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorConfirmations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorConfirmations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorConfirmations.
     */
    distinct?: TwoFactorConfirmationScalarFieldEnum | TwoFactorConfirmationScalarFieldEnum[]
  }


  /**
   * TwoFactorConfirmation findMany
   */
  export type TwoFactorConfirmationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorConfirmations to fetch.
     */
    where?: TwoFactorConfirmationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorConfirmations to fetch.
     */
    orderBy?: TwoFactorConfirmationOrderByWithRelationInput | TwoFactorConfirmationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwoFactorConfirmations.
     */
    cursor?: TwoFactorConfirmationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorConfirmations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorConfirmations.
     */
    skip?: number
    distinct?: TwoFactorConfirmationScalarFieldEnum | TwoFactorConfirmationScalarFieldEnum[]
  }


  /**
   * TwoFactorConfirmation create
   */
  export type TwoFactorConfirmationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * The data needed to create a TwoFactorConfirmation.
     */
    data: XOR<TwoFactorConfirmationCreateInput, TwoFactorConfirmationUncheckedCreateInput>
  }


  /**
   * TwoFactorConfirmation createMany
   */
  export type TwoFactorConfirmationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwoFactorConfirmations.
     */
    data: TwoFactorConfirmationCreateManyInput | TwoFactorConfirmationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TwoFactorConfirmation update
   */
  export type TwoFactorConfirmationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * The data needed to update a TwoFactorConfirmation.
     */
    data: XOR<TwoFactorConfirmationUpdateInput, TwoFactorConfirmationUncheckedUpdateInput>
    /**
     * Choose, which TwoFactorConfirmation to update.
     */
    where: TwoFactorConfirmationWhereUniqueInput
  }


  /**
   * TwoFactorConfirmation updateMany
   */
  export type TwoFactorConfirmationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwoFactorConfirmations.
     */
    data: XOR<TwoFactorConfirmationUpdateManyMutationInput, TwoFactorConfirmationUncheckedUpdateManyInput>
    /**
     * Filter which TwoFactorConfirmations to update
     */
    where?: TwoFactorConfirmationWhereInput
  }


  /**
   * TwoFactorConfirmation upsert
   */
  export type TwoFactorConfirmationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * The filter to search for the TwoFactorConfirmation to update in case it exists.
     */
    where: TwoFactorConfirmationWhereUniqueInput
    /**
     * In case the TwoFactorConfirmation found by the `where` argument doesn't exist, create a new TwoFactorConfirmation with this data.
     */
    create: XOR<TwoFactorConfirmationCreateInput, TwoFactorConfirmationUncheckedCreateInput>
    /**
     * In case the TwoFactorConfirmation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwoFactorConfirmationUpdateInput, TwoFactorConfirmationUncheckedUpdateInput>
  }


  /**
   * TwoFactorConfirmation delete
   */
  export type TwoFactorConfirmationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
    /**
     * Filter which TwoFactorConfirmation to delete.
     */
    where: TwoFactorConfirmationWhereUniqueInput
  }


  /**
   * TwoFactorConfirmation deleteMany
   */
  export type TwoFactorConfirmationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorConfirmations to delete
     */
    where?: TwoFactorConfirmationWhereInput
  }


  /**
   * TwoFactorConfirmation without action
   */
  export type TwoFactorConfirmationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorConfirmation
     */
    select?: TwoFactorConfirmationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorConfirmationInclude<ExtArgs> | null
  }



  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    logo: string | null
    assignedDomain: string | null
    customDomain: string | null
    createdAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    logo: string | null
    assignedDomain: string | null
    customDomain: string | null
    createdAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    url: number
    logo: number
    assignedDomain: number
    customDomain: number
    createdAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    logo?: true
    assignedDomain?: true
    customDomain?: true
    createdAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    logo?: true
    assignedDomain?: true
    customDomain?: true
    createdAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    logo?: true
    assignedDomain?: true
    customDomain?: true
    createdAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    url: string | null
    logo: string | null
    assignedDomain: string | null
    customDomain: string | null
    createdAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    logo?: boolean
    assignedDomain?: boolean
    customDomain?: boolean
    createdAt?: boolean
    organizationRole?: boolean | Organization$organizationRoleArgs<ExtArgs>
    organizationActionLog?: boolean | Organization$organizationActionLogArgs<ExtArgs>
    jobPost?: boolean | Organization$jobPostArgs<ExtArgs>
    payment?: boolean | Organization$paymentArgs<ExtArgs>
    jobPreview?: boolean | Organization$jobPreviewArgs<ExtArgs>
    organizationSubscription?: boolean | Organization$organizationSubscriptionArgs<ExtArgs>
    Notification?: boolean | Organization$NotificationArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    logo?: boolean
    assignedDomain?: boolean
    customDomain?: boolean
    createdAt?: boolean
  }

  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizationRole?: boolean | Organization$organizationRoleArgs<ExtArgs>
    organizationActionLog?: boolean | Organization$organizationActionLogArgs<ExtArgs>
    jobPost?: boolean | Organization$jobPostArgs<ExtArgs>
    payment?: boolean | Organization$paymentArgs<ExtArgs>
    jobPreview?: boolean | Organization$jobPreviewArgs<ExtArgs>
    organizationSubscription?: boolean | Organization$organizationSubscriptionArgs<ExtArgs>
    Notification?: boolean | Organization$NotificationArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      organizationRole: Prisma.$OrganizationUserRolePayload<ExtArgs>[]
      organizationActionLog: Prisma.$OrganizationActivityLogPayload<ExtArgs>[]
      jobPost: Prisma.$JobPostPayload<ExtArgs>[]
      payment: Prisma.$PaymentPayload<ExtArgs>[]
      jobPreview: Prisma.$JobPreviewPayload<ExtArgs>[]
      organizationSubscription: Prisma.$OrganizationSubscriptionPayload<ExtArgs>[]
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string | null
      logo: string | null
      assignedDomain: string | null
      customDomain: string | null
      createdAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }


  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrganizationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Organization that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrganizationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrganizationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
    **/
    create<T extends OrganizationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Organizations.
     *     @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     *     @example
     *     // Create many Organizations
     *     const organization = await prisma.organization.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrganizationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
    **/
    delete<T extends OrganizationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrganizationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrganizationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrganizationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
    **/
    upsert<T extends OrganizationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    organizationRole<T extends Organization$organizationRoleArgs<ExtArgs> = {}>(args?: Subset<T, Organization$organizationRoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationUserRolePayload<ExtArgs>, T, 'findMany'> | Null>;

    organizationActionLog<T extends Organization$organizationActionLogArgs<ExtArgs> = {}>(args?: Subset<T, Organization$organizationActionLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationActivityLogPayload<ExtArgs>, T, 'findMany'> | Null>;

    jobPost<T extends Organization$jobPostArgs<ExtArgs> = {}>(args?: Subset<T, Organization$jobPostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, 'findMany'> | Null>;

    payment<T extends Organization$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Organization$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    jobPreview<T extends Organization$jobPreviewArgs<ExtArgs> = {}>(args?: Subset<T, Organization$jobPreviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPreviewPayload<ExtArgs>, T, 'findMany'> | Null>;

    organizationSubscription<T extends Organization$organizationSubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Organization$organizationSubscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationSubscriptionPayload<ExtArgs>, T, 'findMany'> | Null>;

    Notification<T extends Organization$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, Organization$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly url: FieldRef<"Organization", 'String'>
    readonly logo: FieldRef<"Organization", 'String'>
    readonly assignedDomain: FieldRef<"Organization", 'String'>
    readonly customDomain: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }


  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }


  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }


  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }


  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }


  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }


  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }


  /**
   * Organization.organizationRole
   */
  export type Organization$organizationRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUserRole
     */
    select?: OrganizationUserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationUserRoleInclude<ExtArgs> | null
    where?: OrganizationUserRoleWhereInput
    orderBy?: OrganizationUserRoleOrderByWithRelationInput | OrganizationUserRoleOrderByWithRelationInput[]
    cursor?: OrganizationUserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationUserRoleScalarFieldEnum | OrganizationUserRoleScalarFieldEnum[]
  }


  /**
   * Organization.organizationActionLog
   */
  export type Organization$organizationActionLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationActivityLog
     */
    select?: OrganizationActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationActivityLogInclude<ExtArgs> | null
    where?: OrganizationActivityLogWhereInput
    orderBy?: OrganizationActivityLogOrderByWithRelationInput | OrganizationActivityLogOrderByWithRelationInput[]
    cursor?: OrganizationActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationActivityLogScalarFieldEnum | OrganizationActivityLogScalarFieldEnum[]
  }


  /**
   * Organization.jobPost
   */
  export type Organization$jobPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPostInclude<ExtArgs> | null
    where?: JobPostWhereInput
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    cursor?: JobPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobPostScalarFieldEnum | JobPostScalarFieldEnum[]
  }


  /**
   * Organization.payment
   */
  export type Organization$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * Organization.jobPreview
   */
  export type Organization$jobPreviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPreview
     */
    select?: JobPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPreviewInclude<ExtArgs> | null
    where?: JobPreviewWhereInput
    orderBy?: JobPreviewOrderByWithRelationInput | JobPreviewOrderByWithRelationInput[]
    cursor?: JobPreviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobPreviewScalarFieldEnum | JobPreviewScalarFieldEnum[]
  }


  /**
   * Organization.organizationSubscription
   */
  export type Organization$organizationSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSubscription
     */
    select?: OrganizationSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSubscriptionInclude<ExtArgs> | null
    where?: OrganizationSubscriptionWhereInput
    orderBy?: OrganizationSubscriptionOrderByWithRelationInput | OrganizationSubscriptionOrderByWithRelationInput[]
    cursor?: OrganizationSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationSubscriptionScalarFieldEnum | OrganizationSubscriptionScalarFieldEnum[]
  }


  /**
   * Organization.Notification
   */
  export type Organization$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
  }



  /**
   * Model OrganizationSubscription
   */

  export type AggregateOrganizationSubscription = {
    _count: OrganizationSubscriptionCountAggregateOutputType | null
    _min: OrganizationSubscriptionMinAggregateOutputType | null
    _max: OrganizationSubscriptionMaxAggregateOutputType | null
  }

  export type OrganizationSubscriptionMinAggregateOutputType = {
    id: string | null
    referalId: string | null
    paymentHandler: string | null
    organizationId: string | null
    status: $Enums.SubscriptionStatus | null
    subscriptionType: string | null
    userId: string | null
    createdAt: Date | null
    expiresOn: Date | null
  }

  export type OrganizationSubscriptionMaxAggregateOutputType = {
    id: string | null
    referalId: string | null
    paymentHandler: string | null
    organizationId: string | null
    status: $Enums.SubscriptionStatus | null
    subscriptionType: string | null
    userId: string | null
    createdAt: Date | null
    expiresOn: Date | null
  }

  export type OrganizationSubscriptionCountAggregateOutputType = {
    id: number
    referalId: number
    paymentHandler: number
    organizationId: number
    status: number
    subscriptionType: number
    userId: number
    createdAt: number
    expiresOn: number
    _all: number
  }


  export type OrganizationSubscriptionMinAggregateInputType = {
    id?: true
    referalId?: true
    paymentHandler?: true
    organizationId?: true
    status?: true
    subscriptionType?: true
    userId?: true
    createdAt?: true
    expiresOn?: true
  }

  export type OrganizationSubscriptionMaxAggregateInputType = {
    id?: true
    referalId?: true
    paymentHandler?: true
    organizationId?: true
    status?: true
    subscriptionType?: true
    userId?: true
    createdAt?: true
    expiresOn?: true
  }

  export type OrganizationSubscriptionCountAggregateInputType = {
    id?: true
    referalId?: true
    paymentHandler?: true
    organizationId?: true
    status?: true
    subscriptionType?: true
    userId?: true
    createdAt?: true
    expiresOn?: true
    _all?: true
  }

  export type OrganizationSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationSubscription to aggregate.
     */
    where?: OrganizationSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationSubscriptions to fetch.
     */
    orderBy?: OrganizationSubscriptionOrderByWithRelationInput | OrganizationSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationSubscriptions
    **/
    _count?: true | OrganizationSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationSubscriptionMaxAggregateInputType
  }

  export type GetOrganizationSubscriptionAggregateType<T extends OrganizationSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationSubscription[P]>
      : GetScalarType<T[P], AggregateOrganizationSubscription[P]>
  }




  export type OrganizationSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationSubscriptionWhereInput
    orderBy?: OrganizationSubscriptionOrderByWithAggregationInput | OrganizationSubscriptionOrderByWithAggregationInput[]
    by: OrganizationSubscriptionScalarFieldEnum[] | OrganizationSubscriptionScalarFieldEnum
    having?: OrganizationSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationSubscriptionCountAggregateInputType | true
    _min?: OrganizationSubscriptionMinAggregateInputType
    _max?: OrganizationSubscriptionMaxAggregateInputType
  }

  export type OrganizationSubscriptionGroupByOutputType = {
    id: string
    referalId: string | null
    paymentHandler: string
    organizationId: string
    status: $Enums.SubscriptionStatus
    subscriptionType: string
    userId: string
    createdAt: Date
    expiresOn: Date
    _count: OrganizationSubscriptionCountAggregateOutputType | null
    _min: OrganizationSubscriptionMinAggregateOutputType | null
    _max: OrganizationSubscriptionMaxAggregateOutputType | null
  }

  type GetOrganizationSubscriptionGroupByPayload<T extends OrganizationSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referalId?: boolean
    paymentHandler?: boolean
    organizationId?: boolean
    status?: boolean
    subscriptionType?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresOn?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationSubscription"]>

  export type OrganizationSubscriptionSelectScalar = {
    id?: boolean
    referalId?: boolean
    paymentHandler?: boolean
    organizationId?: boolean
    status?: boolean
    subscriptionType?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresOn?: boolean
  }

  export type OrganizationSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $OrganizationSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationSubscription"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referalId: string | null
      paymentHandler: string
      organizationId: string
      status: $Enums.SubscriptionStatus
      subscriptionType: string
      userId: string
      createdAt: Date
      expiresOn: Date
    }, ExtArgs["result"]["organizationSubscription"]>
    composites: {}
  }


  type OrganizationSubscriptionGetPayload<S extends boolean | null | undefined | OrganizationSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$OrganizationSubscriptionPayload, S>

  type OrganizationSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizationSubscriptionCountAggregateInputType | true
    }

  export interface OrganizationSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationSubscription'], meta: { name: 'OrganizationSubscription' } }
    /**
     * Find zero or one OrganizationSubscription that matches the filter.
     * @param {OrganizationSubscriptionFindUniqueArgs} args - Arguments to find a OrganizationSubscription
     * @example
     * // Get one OrganizationSubscription
     * const organizationSubscription = await prisma.organizationSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrganizationSubscriptionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationSubscriptionFindUniqueArgs<ExtArgs>>
    ): Prisma__OrganizationSubscriptionClient<$Result.GetResult<Prisma.$OrganizationSubscriptionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrganizationSubscription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrganizationSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a OrganizationSubscription
     * @example
     * // Get one OrganizationSubscription
     * const organizationSubscription = await prisma.organizationSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrganizationSubscriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationSubscriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationSubscriptionClient<$Result.GetResult<Prisma.$OrganizationSubscriptionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrganizationSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSubscriptionFindFirstArgs} args - Arguments to find a OrganizationSubscription
     * @example
     * // Get one OrganizationSubscription
     * const organizationSubscription = await prisma.organizationSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrganizationSubscriptionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationSubscriptionFindFirstArgs<ExtArgs>>
    ): Prisma__OrganizationSubscriptionClient<$Result.GetResult<Prisma.$OrganizationSubscriptionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrganizationSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSubscriptionFindFirstOrThrowArgs} args - Arguments to find a OrganizationSubscription
     * @example
     * // Get one OrganizationSubscription
     * const organizationSubscription = await prisma.organizationSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrganizationSubscriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationSubscriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationSubscriptionClient<$Result.GetResult<Prisma.$OrganizationSubscriptionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrganizationSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSubscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationSubscriptions
     * const organizationSubscriptions = await prisma.organizationSubscription.findMany()
     * 
     * // Get first 10 OrganizationSubscriptions
     * const organizationSubscriptions = await prisma.organizationSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationSubscriptionWithIdOnly = await prisma.organizationSubscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrganizationSubscriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationSubscriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationSubscriptionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrganizationSubscription.
     * @param {OrganizationSubscriptionCreateArgs} args - Arguments to create a OrganizationSubscription.
     * @example
     * // Create one OrganizationSubscription
     * const OrganizationSubscription = await prisma.organizationSubscription.create({
     *   data: {
     *     // ... data to create a OrganizationSubscription
     *   }
     * })
     * 
    **/
    create<T extends OrganizationSubscriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationSubscriptionCreateArgs<ExtArgs>>
    ): Prisma__OrganizationSubscriptionClient<$Result.GetResult<Prisma.$OrganizationSubscriptionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrganizationSubscriptions.
     *     @param {OrganizationSubscriptionCreateManyArgs} args - Arguments to create many OrganizationSubscriptions.
     *     @example
     *     // Create many OrganizationSubscriptions
     *     const organizationSubscription = await prisma.organizationSubscription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrganizationSubscriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationSubscriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrganizationSubscription.
     * @param {OrganizationSubscriptionDeleteArgs} args - Arguments to delete one OrganizationSubscription.
     * @example
     * // Delete one OrganizationSubscription
     * const OrganizationSubscription = await prisma.organizationSubscription.delete({
     *   where: {
     *     // ... filter to delete one OrganizationSubscription
     *   }
     * })
     * 
    **/
    delete<T extends OrganizationSubscriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationSubscriptionDeleteArgs<ExtArgs>>
    ): Prisma__OrganizationSubscriptionClient<$Result.GetResult<Prisma.$OrganizationSubscriptionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrganizationSubscription.
     * @param {OrganizationSubscriptionUpdateArgs} args - Arguments to update one OrganizationSubscription.
     * @example
     * // Update one OrganizationSubscription
     * const organizationSubscription = await prisma.organizationSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrganizationSubscriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationSubscriptionUpdateArgs<ExtArgs>>
    ): Prisma__OrganizationSubscriptionClient<$Result.GetResult<Prisma.$OrganizationSubscriptionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrganizationSubscriptions.
     * @param {OrganizationSubscriptionDeleteManyArgs} args - Arguments to filter OrganizationSubscriptions to delete.
     * @example
     * // Delete a few OrganizationSubscriptions
     * const { count } = await prisma.organizationSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrganizationSubscriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationSubscriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationSubscriptions
     * const organizationSubscription = await prisma.organizationSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrganizationSubscriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationSubscriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrganizationSubscription.
     * @param {OrganizationSubscriptionUpsertArgs} args - Arguments to update or create a OrganizationSubscription.
     * @example
     * // Update or create a OrganizationSubscription
     * const organizationSubscription = await prisma.organizationSubscription.upsert({
     *   create: {
     *     // ... data to create a OrganizationSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationSubscription we want to update
     *   }
     * })
    **/
    upsert<T extends OrganizationSubscriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationSubscriptionUpsertArgs<ExtArgs>>
    ): Prisma__OrganizationSubscriptionClient<$Result.GetResult<Prisma.$OrganizationSubscriptionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrganizationSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSubscriptionCountArgs} args - Arguments to filter OrganizationSubscriptions to count.
     * @example
     * // Count the number of OrganizationSubscriptions
     * const count = await prisma.organizationSubscription.count({
     *   where: {
     *     // ... the filter for the OrganizationSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends OrganizationSubscriptionCountArgs>(
      args?: Subset<T, OrganizationSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationSubscriptionAggregateArgs>(args: Subset<T, OrganizationSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetOrganizationSubscriptionAggregateType<T>>

    /**
     * Group by OrganizationSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationSubscription model
   */
  readonly fields: OrganizationSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OrganizationSubscription model
   */ 
  interface OrganizationSubscriptionFieldRefs {
    readonly id: FieldRef<"OrganizationSubscription", 'String'>
    readonly referalId: FieldRef<"OrganizationSubscription", 'String'>
    readonly paymentHandler: FieldRef<"OrganizationSubscription", 'String'>
    readonly organizationId: FieldRef<"OrganizationSubscription", 'String'>
    readonly status: FieldRef<"OrganizationSubscription", 'SubscriptionStatus'>
    readonly subscriptionType: FieldRef<"OrganizationSubscription", 'String'>
    readonly userId: FieldRef<"OrganizationSubscription", 'String'>
    readonly createdAt: FieldRef<"OrganizationSubscription", 'DateTime'>
    readonly expiresOn: FieldRef<"OrganizationSubscription", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * OrganizationSubscription findUnique
   */
  export type OrganizationSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSubscription
     */
    select?: OrganizationSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationSubscription to fetch.
     */
    where: OrganizationSubscriptionWhereUniqueInput
  }


  /**
   * OrganizationSubscription findUniqueOrThrow
   */
  export type OrganizationSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSubscription
     */
    select?: OrganizationSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationSubscription to fetch.
     */
    where: OrganizationSubscriptionWhereUniqueInput
  }


  /**
   * OrganizationSubscription findFirst
   */
  export type OrganizationSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSubscription
     */
    select?: OrganizationSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationSubscription to fetch.
     */
    where?: OrganizationSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationSubscriptions to fetch.
     */
    orderBy?: OrganizationSubscriptionOrderByWithRelationInput | OrganizationSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationSubscriptions.
     */
    cursor?: OrganizationSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationSubscriptions.
     */
    distinct?: OrganizationSubscriptionScalarFieldEnum | OrganizationSubscriptionScalarFieldEnum[]
  }


  /**
   * OrganizationSubscription findFirstOrThrow
   */
  export type OrganizationSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSubscription
     */
    select?: OrganizationSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationSubscription to fetch.
     */
    where?: OrganizationSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationSubscriptions to fetch.
     */
    orderBy?: OrganizationSubscriptionOrderByWithRelationInput | OrganizationSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationSubscriptions.
     */
    cursor?: OrganizationSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationSubscriptions.
     */
    distinct?: OrganizationSubscriptionScalarFieldEnum | OrganizationSubscriptionScalarFieldEnum[]
  }


  /**
   * OrganizationSubscription findMany
   */
  export type OrganizationSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSubscription
     */
    select?: OrganizationSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationSubscriptions to fetch.
     */
    where?: OrganizationSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationSubscriptions to fetch.
     */
    orderBy?: OrganizationSubscriptionOrderByWithRelationInput | OrganizationSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationSubscriptions.
     */
    cursor?: OrganizationSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationSubscriptions.
     */
    skip?: number
    distinct?: OrganizationSubscriptionScalarFieldEnum | OrganizationSubscriptionScalarFieldEnum[]
  }


  /**
   * OrganizationSubscription create
   */
  export type OrganizationSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSubscription
     */
    select?: OrganizationSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationSubscription.
     */
    data: XOR<OrganizationSubscriptionCreateInput, OrganizationSubscriptionUncheckedCreateInput>
  }


  /**
   * OrganizationSubscription createMany
   */
  export type OrganizationSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationSubscriptions.
     */
    data: OrganizationSubscriptionCreateManyInput | OrganizationSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OrganizationSubscription update
   */
  export type OrganizationSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSubscription
     */
    select?: OrganizationSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationSubscription.
     */
    data: XOR<OrganizationSubscriptionUpdateInput, OrganizationSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which OrganizationSubscription to update.
     */
    where: OrganizationSubscriptionWhereUniqueInput
  }


  /**
   * OrganizationSubscription updateMany
   */
  export type OrganizationSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationSubscriptions.
     */
    data: XOR<OrganizationSubscriptionUpdateManyMutationInput, OrganizationSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationSubscriptions to update
     */
    where?: OrganizationSubscriptionWhereInput
  }


  /**
   * OrganizationSubscription upsert
   */
  export type OrganizationSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSubscription
     */
    select?: OrganizationSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationSubscription to update in case it exists.
     */
    where: OrganizationSubscriptionWhereUniqueInput
    /**
     * In case the OrganizationSubscription found by the `where` argument doesn't exist, create a new OrganizationSubscription with this data.
     */
    create: XOR<OrganizationSubscriptionCreateInput, OrganizationSubscriptionUncheckedCreateInput>
    /**
     * In case the OrganizationSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationSubscriptionUpdateInput, OrganizationSubscriptionUncheckedUpdateInput>
  }


  /**
   * OrganizationSubscription delete
   */
  export type OrganizationSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSubscription
     */
    select?: OrganizationSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which OrganizationSubscription to delete.
     */
    where: OrganizationSubscriptionWhereUniqueInput
  }


  /**
   * OrganizationSubscription deleteMany
   */
  export type OrganizationSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationSubscriptions to delete
     */
    where?: OrganizationSubscriptionWhereInput
  }


  /**
   * OrganizationSubscription without action
   */
  export type OrganizationSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationSubscription
     */
    select?: OrganizationSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationSubscriptionInclude<ExtArgs> | null
  }



  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    paddlePaymentId: string | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    paddlePaymentId: string | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    organizationId: number
    paddlePaymentId: number
    amount: number
    currency: number
    status: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    organizationId?: true
    paddlePaymentId?: true
    amount?: true
    currency?: true
    status?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    organizationId?: true
    paddlePaymentId?: true
    amount?: true
    currency?: true
    status?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    organizationId?: true
    paddlePaymentId?: true
    amount?: true
    currency?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    organizationId: string
    paddlePaymentId: string
    amount: number
    currency: string
    status: $Enums.PaymentStatus
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    paddlePaymentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    organizationId?: boolean
    paddlePaymentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }


  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      paddlePaymentId: string
      amount: number
      currency: string
      status: $Enums.PaymentStatus
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }


  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends PaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Payments.
     *     @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends PaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly organizationId: FieldRef<"Payment", 'String'>
    readonly paddlePaymentId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }


  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }


  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }


  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }


  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
  }



  /**
   * Model OrganizationActivityLog
   */

  export type AggregateOrganizationActivityLog = {
    _count: OrganizationActivityLogCountAggregateOutputType | null
    _min: OrganizationActivityLogMinAggregateOutputType | null
    _max: OrganizationActivityLogMaxAggregateOutputType | null
  }

  export type OrganizationActivityLogMinAggregateOutputType = {
    id: string | null
    action: string | null
    organizationId: string | null
    createdAt: Date | null
  }

  export type OrganizationActivityLogMaxAggregateOutputType = {
    id: string | null
    action: string | null
    organizationId: string | null
    createdAt: Date | null
  }

  export type OrganizationActivityLogCountAggregateOutputType = {
    id: number
    action: number
    organizationId: number
    createdAt: number
    _all: number
  }


  export type OrganizationActivityLogMinAggregateInputType = {
    id?: true
    action?: true
    organizationId?: true
    createdAt?: true
  }

  export type OrganizationActivityLogMaxAggregateInputType = {
    id?: true
    action?: true
    organizationId?: true
    createdAt?: true
  }

  export type OrganizationActivityLogCountAggregateInputType = {
    id?: true
    action?: true
    organizationId?: true
    createdAt?: true
    _all?: true
  }

  export type OrganizationActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationActivityLog to aggregate.
     */
    where?: OrganizationActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationActivityLogs to fetch.
     */
    orderBy?: OrganizationActivityLogOrderByWithRelationInput | OrganizationActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationActivityLogs
    **/
    _count?: true | OrganizationActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationActivityLogMaxAggregateInputType
  }

  export type GetOrganizationActivityLogAggregateType<T extends OrganizationActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationActivityLog[P]>
      : GetScalarType<T[P], AggregateOrganizationActivityLog[P]>
  }




  export type OrganizationActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationActivityLogWhereInput
    orderBy?: OrganizationActivityLogOrderByWithAggregationInput | OrganizationActivityLogOrderByWithAggregationInput[]
    by: OrganizationActivityLogScalarFieldEnum[] | OrganizationActivityLogScalarFieldEnum
    having?: OrganizationActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationActivityLogCountAggregateInputType | true
    _min?: OrganizationActivityLogMinAggregateInputType
    _max?: OrganizationActivityLogMaxAggregateInputType
  }

  export type OrganizationActivityLogGroupByOutputType = {
    id: string
    action: string
    organizationId: string
    createdAt: Date
    _count: OrganizationActivityLogCountAggregateOutputType | null
    _min: OrganizationActivityLogMinAggregateOutputType | null
    _max: OrganizationActivityLogMaxAggregateOutputType | null
  }

  type GetOrganizationActivityLogGroupByPayload<T extends OrganizationActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    organizationId?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationActivityLog$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["organizationActivityLog"]>

  export type OrganizationActivityLogSelectScalar = {
    id?: boolean
    action?: boolean
    organizationId?: boolean
    createdAt?: boolean
  }

  export type OrganizationActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationActivityLog$organizationArgs<ExtArgs>
  }


  export type $OrganizationActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationActivityLog"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      organizationId: string
      createdAt: Date
    }, ExtArgs["result"]["organizationActivityLog"]>
    composites: {}
  }


  type OrganizationActivityLogGetPayload<S extends boolean | null | undefined | OrganizationActivityLogDefaultArgs> = $Result.GetResult<Prisma.$OrganizationActivityLogPayload, S>

  type OrganizationActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationActivityLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizationActivityLogCountAggregateInputType | true
    }

  export interface OrganizationActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationActivityLog'], meta: { name: 'OrganizationActivityLog' } }
    /**
     * Find zero or one OrganizationActivityLog that matches the filter.
     * @param {OrganizationActivityLogFindUniqueArgs} args - Arguments to find a OrganizationActivityLog
     * @example
     * // Get one OrganizationActivityLog
     * const organizationActivityLog = await prisma.organizationActivityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrganizationActivityLogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationActivityLogFindUniqueArgs<ExtArgs>>
    ): Prisma__OrganizationActivityLogClient<$Result.GetResult<Prisma.$OrganizationActivityLogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrganizationActivityLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrganizationActivityLogFindUniqueOrThrowArgs} args - Arguments to find a OrganizationActivityLog
     * @example
     * // Get one OrganizationActivityLog
     * const organizationActivityLog = await prisma.organizationActivityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrganizationActivityLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationActivityLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationActivityLogClient<$Result.GetResult<Prisma.$OrganizationActivityLogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrganizationActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationActivityLogFindFirstArgs} args - Arguments to find a OrganizationActivityLog
     * @example
     * // Get one OrganizationActivityLog
     * const organizationActivityLog = await prisma.organizationActivityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrganizationActivityLogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationActivityLogFindFirstArgs<ExtArgs>>
    ): Prisma__OrganizationActivityLogClient<$Result.GetResult<Prisma.$OrganizationActivityLogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrganizationActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationActivityLogFindFirstOrThrowArgs} args - Arguments to find a OrganizationActivityLog
     * @example
     * // Get one OrganizationActivityLog
     * const organizationActivityLog = await prisma.organizationActivityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrganizationActivityLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationActivityLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationActivityLogClient<$Result.GetResult<Prisma.$OrganizationActivityLogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrganizationActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationActivityLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationActivityLogs
     * const organizationActivityLogs = await prisma.organizationActivityLog.findMany()
     * 
     * // Get first 10 OrganizationActivityLogs
     * const organizationActivityLogs = await prisma.organizationActivityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationActivityLogWithIdOnly = await prisma.organizationActivityLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrganizationActivityLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationActivityLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationActivityLogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrganizationActivityLog.
     * @param {OrganizationActivityLogCreateArgs} args - Arguments to create a OrganizationActivityLog.
     * @example
     * // Create one OrganizationActivityLog
     * const OrganizationActivityLog = await prisma.organizationActivityLog.create({
     *   data: {
     *     // ... data to create a OrganizationActivityLog
     *   }
     * })
     * 
    **/
    create<T extends OrganizationActivityLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationActivityLogCreateArgs<ExtArgs>>
    ): Prisma__OrganizationActivityLogClient<$Result.GetResult<Prisma.$OrganizationActivityLogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrganizationActivityLogs.
     *     @param {OrganizationActivityLogCreateManyArgs} args - Arguments to create many OrganizationActivityLogs.
     *     @example
     *     // Create many OrganizationActivityLogs
     *     const organizationActivityLog = await prisma.organizationActivityLog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrganizationActivityLogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationActivityLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrganizationActivityLog.
     * @param {OrganizationActivityLogDeleteArgs} args - Arguments to delete one OrganizationActivityLog.
     * @example
     * // Delete one OrganizationActivityLog
     * const OrganizationActivityLog = await prisma.organizationActivityLog.delete({
     *   where: {
     *     // ... filter to delete one OrganizationActivityLog
     *   }
     * })
     * 
    **/
    delete<T extends OrganizationActivityLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationActivityLogDeleteArgs<ExtArgs>>
    ): Prisma__OrganizationActivityLogClient<$Result.GetResult<Prisma.$OrganizationActivityLogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrganizationActivityLog.
     * @param {OrganizationActivityLogUpdateArgs} args - Arguments to update one OrganizationActivityLog.
     * @example
     * // Update one OrganizationActivityLog
     * const organizationActivityLog = await prisma.organizationActivityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrganizationActivityLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationActivityLogUpdateArgs<ExtArgs>>
    ): Prisma__OrganizationActivityLogClient<$Result.GetResult<Prisma.$OrganizationActivityLogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrganizationActivityLogs.
     * @param {OrganizationActivityLogDeleteManyArgs} args - Arguments to filter OrganizationActivityLogs to delete.
     * @example
     * // Delete a few OrganizationActivityLogs
     * const { count } = await prisma.organizationActivityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrganizationActivityLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationActivityLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationActivityLogs
     * const organizationActivityLog = await prisma.organizationActivityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrganizationActivityLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationActivityLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrganizationActivityLog.
     * @param {OrganizationActivityLogUpsertArgs} args - Arguments to update or create a OrganizationActivityLog.
     * @example
     * // Update or create a OrganizationActivityLog
     * const organizationActivityLog = await prisma.organizationActivityLog.upsert({
     *   create: {
     *     // ... data to create a OrganizationActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationActivityLog we want to update
     *   }
     * })
    **/
    upsert<T extends OrganizationActivityLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationActivityLogUpsertArgs<ExtArgs>>
    ): Prisma__OrganizationActivityLogClient<$Result.GetResult<Prisma.$OrganizationActivityLogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrganizationActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationActivityLogCountArgs} args - Arguments to filter OrganizationActivityLogs to count.
     * @example
     * // Count the number of OrganizationActivityLogs
     * const count = await prisma.organizationActivityLog.count({
     *   where: {
     *     // ... the filter for the OrganizationActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends OrganizationActivityLogCountArgs>(
      args?: Subset<T, OrganizationActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationActivityLogAggregateArgs>(args: Subset<T, OrganizationActivityLogAggregateArgs>): Prisma.PrismaPromise<GetOrganizationActivityLogAggregateType<T>>

    /**
     * Group by OrganizationActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationActivityLog model
   */
  readonly fields: OrganizationActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    organization<T extends OrganizationActivityLog$organizationArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationActivityLog$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OrganizationActivityLog model
   */ 
  interface OrganizationActivityLogFieldRefs {
    readonly id: FieldRef<"OrganizationActivityLog", 'String'>
    readonly action: FieldRef<"OrganizationActivityLog", 'String'>
    readonly organizationId: FieldRef<"OrganizationActivityLog", 'String'>
    readonly createdAt: FieldRef<"OrganizationActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * OrganizationActivityLog findUnique
   */
  export type OrganizationActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationActivityLog
     */
    select?: OrganizationActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationActivityLog to fetch.
     */
    where: OrganizationActivityLogWhereUniqueInput
  }


  /**
   * OrganizationActivityLog findUniqueOrThrow
   */
  export type OrganizationActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationActivityLog
     */
    select?: OrganizationActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationActivityLog to fetch.
     */
    where: OrganizationActivityLogWhereUniqueInput
  }


  /**
   * OrganizationActivityLog findFirst
   */
  export type OrganizationActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationActivityLog
     */
    select?: OrganizationActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationActivityLog to fetch.
     */
    where?: OrganizationActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationActivityLogs to fetch.
     */
    orderBy?: OrganizationActivityLogOrderByWithRelationInput | OrganizationActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationActivityLogs.
     */
    cursor?: OrganizationActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationActivityLogs.
     */
    distinct?: OrganizationActivityLogScalarFieldEnum | OrganizationActivityLogScalarFieldEnum[]
  }


  /**
   * OrganizationActivityLog findFirstOrThrow
   */
  export type OrganizationActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationActivityLog
     */
    select?: OrganizationActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationActivityLog to fetch.
     */
    where?: OrganizationActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationActivityLogs to fetch.
     */
    orderBy?: OrganizationActivityLogOrderByWithRelationInput | OrganizationActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationActivityLogs.
     */
    cursor?: OrganizationActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationActivityLogs.
     */
    distinct?: OrganizationActivityLogScalarFieldEnum | OrganizationActivityLogScalarFieldEnum[]
  }


  /**
   * OrganizationActivityLog findMany
   */
  export type OrganizationActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationActivityLog
     */
    select?: OrganizationActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationActivityLogs to fetch.
     */
    where?: OrganizationActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationActivityLogs to fetch.
     */
    orderBy?: OrganizationActivityLogOrderByWithRelationInput | OrganizationActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationActivityLogs.
     */
    cursor?: OrganizationActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationActivityLogs.
     */
    skip?: number
    distinct?: OrganizationActivityLogScalarFieldEnum | OrganizationActivityLogScalarFieldEnum[]
  }


  /**
   * OrganizationActivityLog create
   */
  export type OrganizationActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationActivityLog
     */
    select?: OrganizationActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationActivityLog.
     */
    data: XOR<OrganizationActivityLogCreateInput, OrganizationActivityLogUncheckedCreateInput>
  }


  /**
   * OrganizationActivityLog createMany
   */
  export type OrganizationActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationActivityLogs.
     */
    data: OrganizationActivityLogCreateManyInput | OrganizationActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OrganizationActivityLog update
   */
  export type OrganizationActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationActivityLog
     */
    select?: OrganizationActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationActivityLog.
     */
    data: XOR<OrganizationActivityLogUpdateInput, OrganizationActivityLogUncheckedUpdateInput>
    /**
     * Choose, which OrganizationActivityLog to update.
     */
    where: OrganizationActivityLogWhereUniqueInput
  }


  /**
   * OrganizationActivityLog updateMany
   */
  export type OrganizationActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationActivityLogs.
     */
    data: XOR<OrganizationActivityLogUpdateManyMutationInput, OrganizationActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationActivityLogs to update
     */
    where?: OrganizationActivityLogWhereInput
  }


  /**
   * OrganizationActivityLog upsert
   */
  export type OrganizationActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationActivityLog
     */
    select?: OrganizationActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationActivityLog to update in case it exists.
     */
    where: OrganizationActivityLogWhereUniqueInput
    /**
     * In case the OrganizationActivityLog found by the `where` argument doesn't exist, create a new OrganizationActivityLog with this data.
     */
    create: XOR<OrganizationActivityLogCreateInput, OrganizationActivityLogUncheckedCreateInput>
    /**
     * In case the OrganizationActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationActivityLogUpdateInput, OrganizationActivityLogUncheckedUpdateInput>
  }


  /**
   * OrganizationActivityLog delete
   */
  export type OrganizationActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationActivityLog
     */
    select?: OrganizationActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationActivityLogInclude<ExtArgs> | null
    /**
     * Filter which OrganizationActivityLog to delete.
     */
    where: OrganizationActivityLogWhereUniqueInput
  }


  /**
   * OrganizationActivityLog deleteMany
   */
  export type OrganizationActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationActivityLogs to delete
     */
    where?: OrganizationActivityLogWhereInput
  }


  /**
   * OrganizationActivityLog.organization
   */
  export type OrganizationActivityLog$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }


  /**
   * OrganizationActivityLog without action
   */
  export type OrganizationActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationActivityLog
     */
    select?: OrganizationActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationActivityLogInclude<ExtArgs> | null
  }



  /**
   * Model JobPost
   */

  export type AggregateJobPost = {
    _count: JobPostCountAggregateOutputType | null
    _avg: JobPostAvgAggregateOutputType | null
    _sum: JobPostSumAggregateOutputType | null
    _min: JobPostMinAggregateOutputType | null
    _max: JobPostMaxAggregateOutputType | null
  }

  export type JobPostAvgAggregateOutputType = {
    salaryAmount: number | null
    minimumAmount: number | null
    maximumAmount: number | null
  }

  export type JobPostSumAggregateOutputType = {
    salaryAmount: number | null
    minimumAmount: number | null
    maximumAmount: number | null
  }

  export type JobPostMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    employmentType: string | null
    country: string | null
    city: string | null
    remoteOption: string | null
    countryResidence: string | null
    displaySalary: string | null
    currency: string | null
    salaryAmount: number | null
    minimumAmount: number | null
    maximumAmount: number | null
    isPublished: boolean | null
    isScheduled: boolean | null
    isArchived: boolean | null
    dateStart: Date | null
    dateEnd: Date | null
    organizationId: string | null
    createdAt: Date | null
  }

  export type JobPostMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    employmentType: string | null
    country: string | null
    city: string | null
    remoteOption: string | null
    countryResidence: string | null
    displaySalary: string | null
    currency: string | null
    salaryAmount: number | null
    minimumAmount: number | null
    maximumAmount: number | null
    isPublished: boolean | null
    isScheduled: boolean | null
    isArchived: boolean | null
    dateStart: Date | null
    dateEnd: Date | null
    organizationId: string | null
    createdAt: Date | null
  }

  export type JobPostCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    employmentType: number
    country: number
    city: number
    remoteOption: number
    countryResidence: number
    countryListResidence: number
    displaySalary: number
    currency: number
    salaryAmount: number
    minimumAmount: number
    maximumAmount: number
    isPublished: number
    isScheduled: number
    isArchived: number
    dateStart: number
    dateEnd: number
    organizationId: number
    createdAt: number
    _all: number
  }


  export type JobPostAvgAggregateInputType = {
    salaryAmount?: true
    minimumAmount?: true
    maximumAmount?: true
  }

  export type JobPostSumAggregateInputType = {
    salaryAmount?: true
    minimumAmount?: true
    maximumAmount?: true
  }

  export type JobPostMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    employmentType?: true
    country?: true
    city?: true
    remoteOption?: true
    countryResidence?: true
    displaySalary?: true
    currency?: true
    salaryAmount?: true
    minimumAmount?: true
    maximumAmount?: true
    isPublished?: true
    isScheduled?: true
    isArchived?: true
    dateStart?: true
    dateEnd?: true
    organizationId?: true
    createdAt?: true
  }

  export type JobPostMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    employmentType?: true
    country?: true
    city?: true
    remoteOption?: true
    countryResidence?: true
    displaySalary?: true
    currency?: true
    salaryAmount?: true
    minimumAmount?: true
    maximumAmount?: true
    isPublished?: true
    isScheduled?: true
    isArchived?: true
    dateStart?: true
    dateEnd?: true
    organizationId?: true
    createdAt?: true
  }

  export type JobPostCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    employmentType?: true
    country?: true
    city?: true
    remoteOption?: true
    countryResidence?: true
    countryListResidence?: true
    displaySalary?: true
    currency?: true
    salaryAmount?: true
    minimumAmount?: true
    maximumAmount?: true
    isPublished?: true
    isScheduled?: true
    isArchived?: true
    dateStart?: true
    dateEnd?: true
    organizationId?: true
    createdAt?: true
    _all?: true
  }

  export type JobPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPost to aggregate.
     */
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     */
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobPosts
    **/
    _count?: true | JobPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobPostMaxAggregateInputType
  }

  export type GetJobPostAggregateType<T extends JobPostAggregateArgs> = {
        [P in keyof T & keyof AggregateJobPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobPost[P]>
      : GetScalarType<T[P], AggregateJobPost[P]>
  }




  export type JobPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostWhereInput
    orderBy?: JobPostOrderByWithAggregationInput | JobPostOrderByWithAggregationInput[]
    by: JobPostScalarFieldEnum[] | JobPostScalarFieldEnum
    having?: JobPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobPostCountAggregateInputType | true
    _avg?: JobPostAvgAggregateInputType
    _sum?: JobPostSumAggregateInputType
    _min?: JobPostMinAggregateInputType
    _max?: JobPostMaxAggregateInputType
  }

  export type JobPostGroupByOutputType = {
    id: string
    title: string
    description: string | null
    category: string | null
    employmentType: string | null
    country: string | null
    city: string | null
    remoteOption: string | null
    countryResidence: string | null
    countryListResidence: string[]
    displaySalary: string | null
    currency: string | null
    salaryAmount: number | null
    minimumAmount: number | null
    maximumAmount: number | null
    isPublished: boolean
    isScheduled: boolean
    isArchived: boolean
    dateStart: Date | null
    dateEnd: Date | null
    organizationId: string
    createdAt: Date
    _count: JobPostCountAggregateOutputType | null
    _avg: JobPostAvgAggregateOutputType | null
    _sum: JobPostSumAggregateOutputType | null
    _min: JobPostMinAggregateOutputType | null
    _max: JobPostMaxAggregateOutputType | null
  }

  type GetJobPostGroupByPayload<T extends JobPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobPostGroupByOutputType[P]>
            : GetScalarType<T[P], JobPostGroupByOutputType[P]>
        }
      >
    >


  export type JobPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    employmentType?: boolean
    country?: boolean
    city?: boolean
    remoteOption?: boolean
    countryResidence?: boolean
    countryListResidence?: boolean
    displaySalary?: boolean
    currency?: boolean
    salaryAmount?: boolean
    minimumAmount?: boolean
    maximumAmount?: boolean
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    organizationId?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    jobApplication?: boolean | JobPost$jobApplicationArgs<ExtArgs>
    jobStage?: boolean | JobPost$jobStageArgs<ExtArgs>
    jobPreview?: boolean | JobPost$jobPreviewArgs<ExtArgs>
    candidateApplication?: boolean | JobPost$candidateApplicationArgs<ExtArgs>
    CandidateTimeline?: boolean | JobPost$CandidateTimelineArgs<ExtArgs>
    JobMailingTemplate?: boolean | JobPost$JobMailingTemplateArgs<ExtArgs>
    _count?: boolean | JobPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPost"]>

  export type JobPostSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    employmentType?: boolean
    country?: boolean
    city?: boolean
    remoteOption?: boolean
    countryResidence?: boolean
    countryListResidence?: boolean
    displaySalary?: boolean
    currency?: boolean
    salaryAmount?: boolean
    minimumAmount?: boolean
    maximumAmount?: boolean
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    organizationId?: boolean
    createdAt?: boolean
  }

  export type JobPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    jobApplication?: boolean | JobPost$jobApplicationArgs<ExtArgs>
    jobStage?: boolean | JobPost$jobStageArgs<ExtArgs>
    jobPreview?: boolean | JobPost$jobPreviewArgs<ExtArgs>
    candidateApplication?: boolean | JobPost$candidateApplicationArgs<ExtArgs>
    CandidateTimeline?: boolean | JobPost$CandidateTimelineArgs<ExtArgs>
    JobMailingTemplate?: boolean | JobPost$JobMailingTemplateArgs<ExtArgs>
    _count?: boolean | JobPostCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $JobPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobPost"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      jobApplication: Prisma.$JobApplicationPayload<ExtArgs>[]
      jobStage: Prisma.$JobStagePayload<ExtArgs>[]
      jobPreview: Prisma.$JobPreviewPayload<ExtArgs>[]
      candidateApplication: Prisma.$CandidateApplicationPayload<ExtArgs>[]
      CandidateTimeline: Prisma.$CandidateTimelinePayload<ExtArgs>[]
      JobMailingTemplate: Prisma.$JobMailingTemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      category: string | null
      employmentType: string | null
      country: string | null
      city: string | null
      remoteOption: string | null
      countryResidence: string | null
      countryListResidence: string[]
      displaySalary: string | null
      currency: string | null
      salaryAmount: number | null
      minimumAmount: number | null
      maximumAmount: number | null
      isPublished: boolean
      isScheduled: boolean
      isArchived: boolean
      dateStart: Date | null
      dateEnd: Date | null
      organizationId: string
      createdAt: Date
    }, ExtArgs["result"]["jobPost"]>
    composites: {}
  }


  type JobPostGetPayload<S extends boolean | null | undefined | JobPostDefaultArgs> = $Result.GetResult<Prisma.$JobPostPayload, S>

  type JobPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobPostCountAggregateInputType | true
    }

  export interface JobPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobPost'], meta: { name: 'JobPost' } }
    /**
     * Find zero or one JobPost that matches the filter.
     * @param {JobPostFindUniqueArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobPostFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, JobPostFindUniqueArgs<ExtArgs>>
    ): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one JobPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JobPostFindUniqueOrThrowArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JobPostFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobPostFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first JobPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostFindFirstArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobPostFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, JobPostFindFirstArgs<ExtArgs>>
    ): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first JobPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostFindFirstOrThrowArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JobPostFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobPostFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more JobPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobPosts
     * const jobPosts = await prisma.jobPost.findMany()
     * 
     * // Get first 10 JobPosts
     * const jobPosts = await prisma.jobPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobPostWithIdOnly = await prisma.jobPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends JobPostFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobPostFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a JobPost.
     * @param {JobPostCreateArgs} args - Arguments to create a JobPost.
     * @example
     * // Create one JobPost
     * const JobPost = await prisma.jobPost.create({
     *   data: {
     *     // ... data to create a JobPost
     *   }
     * })
     * 
    **/
    create<T extends JobPostCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JobPostCreateArgs<ExtArgs>>
    ): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many JobPosts.
     *     @param {JobPostCreateManyArgs} args - Arguments to create many JobPosts.
     *     @example
     *     // Create many JobPosts
     *     const jobPost = await prisma.jobPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobPostCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobPostCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JobPost.
     * @param {JobPostDeleteArgs} args - Arguments to delete one JobPost.
     * @example
     * // Delete one JobPost
     * const JobPost = await prisma.jobPost.delete({
     *   where: {
     *     // ... filter to delete one JobPost
     *   }
     * })
     * 
    **/
    delete<T extends JobPostDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JobPostDeleteArgs<ExtArgs>>
    ): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one JobPost.
     * @param {JobPostUpdateArgs} args - Arguments to update one JobPost.
     * @example
     * // Update one JobPost
     * const jobPost = await prisma.jobPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobPostUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JobPostUpdateArgs<ExtArgs>>
    ): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more JobPosts.
     * @param {JobPostDeleteManyArgs} args - Arguments to filter JobPosts to delete.
     * @example
     * // Delete a few JobPosts
     * const { count } = await prisma.jobPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobPostDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobPostDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobPosts
     * const jobPost = await prisma.jobPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobPostUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JobPostUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobPost.
     * @param {JobPostUpsertArgs} args - Arguments to update or create a JobPost.
     * @example
     * // Update or create a JobPost
     * const jobPost = await prisma.jobPost.upsert({
     *   create: {
     *     // ... data to create a JobPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobPost we want to update
     *   }
     * })
    **/
    upsert<T extends JobPostUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JobPostUpsertArgs<ExtArgs>>
    ): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of JobPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostCountArgs} args - Arguments to filter JobPosts to count.
     * @example
     * // Count the number of JobPosts
     * const count = await prisma.jobPost.count({
     *   where: {
     *     // ... the filter for the JobPosts we want to count
     *   }
     * })
    **/
    count<T extends JobPostCountArgs>(
      args?: Subset<T, JobPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobPostAggregateArgs>(args: Subset<T, JobPostAggregateArgs>): Prisma.PrismaPromise<GetJobPostAggregateType<T>>

    /**
     * Group by JobPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobPostGroupByArgs['orderBy'] }
        : { orderBy?: JobPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobPost model
   */
  readonly fields: JobPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    jobApplication<T extends JobPost$jobApplicationArgs<ExtArgs> = {}>(args?: Subset<T, JobPost$jobApplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'findMany'> | Null>;

    jobStage<T extends JobPost$jobStageArgs<ExtArgs> = {}>(args?: Subset<T, JobPost$jobStageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobStagePayload<ExtArgs>, T, 'findMany'> | Null>;

    jobPreview<T extends JobPost$jobPreviewArgs<ExtArgs> = {}>(args?: Subset<T, JobPost$jobPreviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPreviewPayload<ExtArgs>, T, 'findMany'> | Null>;

    candidateApplication<T extends JobPost$candidateApplicationArgs<ExtArgs> = {}>(args?: Subset<T, JobPost$candidateApplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidateApplicationPayload<ExtArgs>, T, 'findMany'> | Null>;

    CandidateTimeline<T extends JobPost$CandidateTimelineArgs<ExtArgs> = {}>(args?: Subset<T, JobPost$CandidateTimelineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidateTimelinePayload<ExtArgs>, T, 'findMany'> | Null>;

    JobMailingTemplate<T extends JobPost$JobMailingTemplateArgs<ExtArgs> = {}>(args?: Subset<T, JobPost$JobMailingTemplateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobMailingTemplatePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the JobPost model
   */ 
  interface JobPostFieldRefs {
    readonly id: FieldRef<"JobPost", 'String'>
    readonly title: FieldRef<"JobPost", 'String'>
    readonly description: FieldRef<"JobPost", 'String'>
    readonly category: FieldRef<"JobPost", 'String'>
    readonly employmentType: FieldRef<"JobPost", 'String'>
    readonly country: FieldRef<"JobPost", 'String'>
    readonly city: FieldRef<"JobPost", 'String'>
    readonly remoteOption: FieldRef<"JobPost", 'String'>
    readonly countryResidence: FieldRef<"JobPost", 'String'>
    readonly countryListResidence: FieldRef<"JobPost", 'String[]'>
    readonly displaySalary: FieldRef<"JobPost", 'String'>
    readonly currency: FieldRef<"JobPost", 'String'>
    readonly salaryAmount: FieldRef<"JobPost", 'Float'>
    readonly minimumAmount: FieldRef<"JobPost", 'Float'>
    readonly maximumAmount: FieldRef<"JobPost", 'Float'>
    readonly isPublished: FieldRef<"JobPost", 'Boolean'>
    readonly isScheduled: FieldRef<"JobPost", 'Boolean'>
    readonly isArchived: FieldRef<"JobPost", 'Boolean'>
    readonly dateStart: FieldRef<"JobPost", 'DateTime'>
    readonly dateEnd: FieldRef<"JobPost", 'DateTime'>
    readonly organizationId: FieldRef<"JobPost", 'String'>
    readonly createdAt: FieldRef<"JobPost", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * JobPost findUnique
   */
  export type JobPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPost to fetch.
     */
    where: JobPostWhereUniqueInput
  }


  /**
   * JobPost findUniqueOrThrow
   */
  export type JobPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPost to fetch.
     */
    where: JobPostWhereUniqueInput
  }


  /**
   * JobPost findFirst
   */
  export type JobPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPost to fetch.
     */
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     */
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPosts.
     */
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPosts.
     */
    distinct?: JobPostScalarFieldEnum | JobPostScalarFieldEnum[]
  }


  /**
   * JobPost findFirstOrThrow
   */
  export type JobPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPost to fetch.
     */
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     */
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPosts.
     */
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPosts.
     */
    distinct?: JobPostScalarFieldEnum | JobPostScalarFieldEnum[]
  }


  /**
   * JobPost findMany
   */
  export type JobPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter, which JobPosts to fetch.
     */
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     */
    orderBy?: JobPostOrderByWithRelationInput | JobPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobPosts.
     */
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     */
    skip?: number
    distinct?: JobPostScalarFieldEnum | JobPostScalarFieldEnum[]
  }


  /**
   * JobPost create
   */
  export type JobPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * The data needed to create a JobPost.
     */
    data: XOR<JobPostCreateInput, JobPostUncheckedCreateInput>
  }


  /**
   * JobPost createMany
   */
  export type JobPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobPosts.
     */
    data: JobPostCreateManyInput | JobPostCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * JobPost update
   */
  export type JobPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * The data needed to update a JobPost.
     */
    data: XOR<JobPostUpdateInput, JobPostUncheckedUpdateInput>
    /**
     * Choose, which JobPost to update.
     */
    where: JobPostWhereUniqueInput
  }


  /**
   * JobPost updateMany
   */
  export type JobPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobPosts.
     */
    data: XOR<JobPostUpdateManyMutationInput, JobPostUncheckedUpdateManyInput>
    /**
     * Filter which JobPosts to update
     */
    where?: JobPostWhereInput
  }


  /**
   * JobPost upsert
   */
  export type JobPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * The filter to search for the JobPost to update in case it exists.
     */
    where: JobPostWhereUniqueInput
    /**
     * In case the JobPost found by the `where` argument doesn't exist, create a new JobPost with this data.
     */
    create: XOR<JobPostCreateInput, JobPostUncheckedCreateInput>
    /**
     * In case the JobPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobPostUpdateInput, JobPostUncheckedUpdateInput>
  }


  /**
   * JobPost delete
   */
  export type JobPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPostInclude<ExtArgs> | null
    /**
     * Filter which JobPost to delete.
     */
    where: JobPostWhereUniqueInput
  }


  /**
   * JobPost deleteMany
   */
  export type JobPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPosts to delete
     */
    where?: JobPostWhereInput
  }


  /**
   * JobPost.jobApplication
   */
  export type JobPost$jobApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    where?: JobApplicationWhereInput
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    cursor?: JobApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }


  /**
   * JobPost.jobStage
   */
  export type JobPost$jobStageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStage
     */
    select?: JobStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobStageInclude<ExtArgs> | null
    where?: JobStageWhereInput
    orderBy?: JobStageOrderByWithRelationInput | JobStageOrderByWithRelationInput[]
    cursor?: JobStageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobStageScalarFieldEnum | JobStageScalarFieldEnum[]
  }


  /**
   * JobPost.jobPreview
   */
  export type JobPost$jobPreviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPreview
     */
    select?: JobPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPreviewInclude<ExtArgs> | null
    where?: JobPreviewWhereInput
    orderBy?: JobPreviewOrderByWithRelationInput | JobPreviewOrderByWithRelationInput[]
    cursor?: JobPreviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobPreviewScalarFieldEnum | JobPreviewScalarFieldEnum[]
  }


  /**
   * JobPost.candidateApplication
   */
  export type JobPost$candidateApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateApplication
     */
    select?: CandidateApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateApplicationInclude<ExtArgs> | null
    where?: CandidateApplicationWhereInput
    orderBy?: CandidateApplicationOrderByWithRelationInput | CandidateApplicationOrderByWithRelationInput[]
    cursor?: CandidateApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CandidateApplicationScalarFieldEnum | CandidateApplicationScalarFieldEnum[]
  }


  /**
   * JobPost.CandidateTimeline
   */
  export type JobPost$CandidateTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateTimeline
     */
    select?: CandidateTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateTimelineInclude<ExtArgs> | null
    where?: CandidateTimelineWhereInput
    orderBy?: CandidateTimelineOrderByWithRelationInput | CandidateTimelineOrderByWithRelationInput[]
    cursor?: CandidateTimelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CandidateTimelineScalarFieldEnum | CandidateTimelineScalarFieldEnum[]
  }


  /**
   * JobPost.JobMailingTemplate
   */
  export type JobPost$JobMailingTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobMailingTemplate
     */
    select?: JobMailingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobMailingTemplateInclude<ExtArgs> | null
    where?: JobMailingTemplateWhereInput
    orderBy?: JobMailingTemplateOrderByWithRelationInput | JobMailingTemplateOrderByWithRelationInput[]
    cursor?: JobMailingTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobMailingTemplateScalarFieldEnum | JobMailingTemplateScalarFieldEnum[]
  }


  /**
   * JobPost without action
   */
  export type JobPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPost
     */
    select?: JobPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPostInclude<ExtArgs> | null
  }



  /**
   * Model JobApplication
   */

  export type AggregateJobApplication = {
    _count: JobApplicationCountAggregateOutputType | null
    _min: JobApplicationMinAggregateOutputType | null
    _max: JobApplicationMaxAggregateOutputType | null
  }

  export type JobApplicationMinAggregateOutputType = {
    id: string | null
    label: string | null
    dataType: string | null
    rule: string | null
    questionType: string | null
    isDeleted: boolean | null
    jobId: string | null
    createdAt: Date | null
  }

  export type JobApplicationMaxAggregateOutputType = {
    id: string | null
    label: string | null
    dataType: string | null
    rule: string | null
    questionType: string | null
    isDeleted: boolean | null
    jobId: string | null
    createdAt: Date | null
  }

  export type JobApplicationCountAggregateOutputType = {
    id: number
    label: number
    dataType: number
    option: number
    rule: number
    questionType: number
    isDeleted: number
    jobId: number
    createdAt: number
    _all: number
  }


  export type JobApplicationMinAggregateInputType = {
    id?: true
    label?: true
    dataType?: true
    rule?: true
    questionType?: true
    isDeleted?: true
    jobId?: true
    createdAt?: true
  }

  export type JobApplicationMaxAggregateInputType = {
    id?: true
    label?: true
    dataType?: true
    rule?: true
    questionType?: true
    isDeleted?: true
    jobId?: true
    createdAt?: true
  }

  export type JobApplicationCountAggregateInputType = {
    id?: true
    label?: true
    dataType?: true
    option?: true
    rule?: true
    questionType?: true
    isDeleted?: true
    jobId?: true
    createdAt?: true
    _all?: true
  }

  export type JobApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobApplication to aggregate.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobApplications
    **/
    _count?: true | JobApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobApplicationMaxAggregateInputType
  }

  export type GetJobApplicationAggregateType<T extends JobApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateJobApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobApplication[P]>
      : GetScalarType<T[P], AggregateJobApplication[P]>
  }




  export type JobApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicationWhereInput
    orderBy?: JobApplicationOrderByWithAggregationInput | JobApplicationOrderByWithAggregationInput[]
    by: JobApplicationScalarFieldEnum[] | JobApplicationScalarFieldEnum
    having?: JobApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobApplicationCountAggregateInputType | true
    _min?: JobApplicationMinAggregateInputType
    _max?: JobApplicationMaxAggregateInputType
  }

  export type JobApplicationGroupByOutputType = {
    id: string
    label: string
    dataType: string
    option: string[]
    rule: string
    questionType: string
    isDeleted: boolean
    jobId: string
    createdAt: Date
    _count: JobApplicationCountAggregateOutputType | null
    _min: JobApplicationMinAggregateOutputType | null
    _max: JobApplicationMaxAggregateOutputType | null
  }

  type GetJobApplicationGroupByPayload<T extends JobApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], JobApplicationGroupByOutputType[P]>
        }
      >
    >


  export type JobApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    dataType?: boolean
    option?: boolean
    rule?: boolean
    questionType?: boolean
    isDeleted?: boolean
    jobId?: boolean
    createdAt?: boolean
    jobPost?: boolean | JobPostDefaultArgs<ExtArgs>
    formResponse?: boolean | JobApplication$formResponseArgs<ExtArgs>
    _count?: boolean | JobApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobApplication"]>

  export type JobApplicationSelectScalar = {
    id?: boolean
    label?: boolean
    dataType?: boolean
    option?: boolean
    rule?: boolean
    questionType?: boolean
    isDeleted?: boolean
    jobId?: boolean
    createdAt?: boolean
  }

  export type JobApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPost?: boolean | JobPostDefaultArgs<ExtArgs>
    formResponse?: boolean | JobApplication$formResponseArgs<ExtArgs>
    _count?: boolean | JobApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $JobApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobApplication"
    objects: {
      jobPost: Prisma.$JobPostPayload<ExtArgs>
      formResponse: Prisma.$FormResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string
      dataType: string
      option: string[]
      rule: string
      questionType: string
      isDeleted: boolean
      jobId: string
      createdAt: Date
    }, ExtArgs["result"]["jobApplication"]>
    composites: {}
  }


  type JobApplicationGetPayload<S extends boolean | null | undefined | JobApplicationDefaultArgs> = $Result.GetResult<Prisma.$JobApplicationPayload, S>

  type JobApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobApplicationCountAggregateInputType | true
    }

  export interface JobApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobApplication'], meta: { name: 'JobApplication' } }
    /**
     * Find zero or one JobApplication that matches the filter.
     * @param {JobApplicationFindUniqueArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobApplicationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, JobApplicationFindUniqueArgs<ExtArgs>>
    ): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one JobApplication that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JobApplicationFindUniqueOrThrowArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JobApplicationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobApplicationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first JobApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationFindFirstArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobApplicationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, JobApplicationFindFirstArgs<ExtArgs>>
    ): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first JobApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationFindFirstOrThrowArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JobApplicationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobApplicationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more JobApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobApplications
     * const jobApplications = await prisma.jobApplication.findMany()
     * 
     * // Get first 10 JobApplications
     * const jobApplications = await prisma.jobApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobApplicationWithIdOnly = await prisma.jobApplication.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends JobApplicationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobApplicationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a JobApplication.
     * @param {JobApplicationCreateArgs} args - Arguments to create a JobApplication.
     * @example
     * // Create one JobApplication
     * const JobApplication = await prisma.jobApplication.create({
     *   data: {
     *     // ... data to create a JobApplication
     *   }
     * })
     * 
    **/
    create<T extends JobApplicationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JobApplicationCreateArgs<ExtArgs>>
    ): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many JobApplications.
     *     @param {JobApplicationCreateManyArgs} args - Arguments to create many JobApplications.
     *     @example
     *     // Create many JobApplications
     *     const jobApplication = await prisma.jobApplication.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobApplicationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobApplicationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JobApplication.
     * @param {JobApplicationDeleteArgs} args - Arguments to delete one JobApplication.
     * @example
     * // Delete one JobApplication
     * const JobApplication = await prisma.jobApplication.delete({
     *   where: {
     *     // ... filter to delete one JobApplication
     *   }
     * })
     * 
    **/
    delete<T extends JobApplicationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JobApplicationDeleteArgs<ExtArgs>>
    ): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one JobApplication.
     * @param {JobApplicationUpdateArgs} args - Arguments to update one JobApplication.
     * @example
     * // Update one JobApplication
     * const jobApplication = await prisma.jobApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobApplicationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JobApplicationUpdateArgs<ExtArgs>>
    ): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more JobApplications.
     * @param {JobApplicationDeleteManyArgs} args - Arguments to filter JobApplications to delete.
     * @example
     * // Delete a few JobApplications
     * const { count } = await prisma.jobApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobApplicationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobApplicationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobApplications
     * const jobApplication = await prisma.jobApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobApplicationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JobApplicationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobApplication.
     * @param {JobApplicationUpsertArgs} args - Arguments to update or create a JobApplication.
     * @example
     * // Update or create a JobApplication
     * const jobApplication = await prisma.jobApplication.upsert({
     *   create: {
     *     // ... data to create a JobApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobApplication we want to update
     *   }
     * })
    **/
    upsert<T extends JobApplicationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JobApplicationUpsertArgs<ExtArgs>>
    ): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of JobApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationCountArgs} args - Arguments to filter JobApplications to count.
     * @example
     * // Count the number of JobApplications
     * const count = await prisma.jobApplication.count({
     *   where: {
     *     // ... the filter for the JobApplications we want to count
     *   }
     * })
    **/
    count<T extends JobApplicationCountArgs>(
      args?: Subset<T, JobApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobApplicationAggregateArgs>(args: Subset<T, JobApplicationAggregateArgs>): Prisma.PrismaPromise<GetJobApplicationAggregateType<T>>

    /**
     * Group by JobApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobApplicationGroupByArgs['orderBy'] }
        : { orderBy?: JobApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobApplication model
   */
  readonly fields: JobApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    jobPost<T extends JobPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostDefaultArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    formResponse<T extends JobApplication$formResponseArgs<ExtArgs> = {}>(args?: Subset<T, JobApplication$formResponseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the JobApplication model
   */ 
  interface JobApplicationFieldRefs {
    readonly id: FieldRef<"JobApplication", 'String'>
    readonly label: FieldRef<"JobApplication", 'String'>
    readonly dataType: FieldRef<"JobApplication", 'String'>
    readonly option: FieldRef<"JobApplication", 'String[]'>
    readonly rule: FieldRef<"JobApplication", 'String'>
    readonly questionType: FieldRef<"JobApplication", 'String'>
    readonly isDeleted: FieldRef<"JobApplication", 'Boolean'>
    readonly jobId: FieldRef<"JobApplication", 'String'>
    readonly createdAt: FieldRef<"JobApplication", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * JobApplication findUnique
   */
  export type JobApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where: JobApplicationWhereUniqueInput
  }


  /**
   * JobApplication findUniqueOrThrow
   */
  export type JobApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where: JobApplicationWhereUniqueInput
  }


  /**
   * JobApplication findFirst
   */
  export type JobApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobApplications.
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobApplications.
     */
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }


  /**
   * JobApplication findFirstOrThrow
   */
  export type JobApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobApplications.
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobApplications.
     */
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }


  /**
   * JobApplication findMany
   */
  export type JobApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplications to fetch.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobApplications.
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }


  /**
   * JobApplication create
   */
  export type JobApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a JobApplication.
     */
    data: XOR<JobApplicationCreateInput, JobApplicationUncheckedCreateInput>
  }


  /**
   * JobApplication createMany
   */
  export type JobApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobApplications.
     */
    data: JobApplicationCreateManyInput | JobApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * JobApplication update
   */
  export type JobApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a JobApplication.
     */
    data: XOR<JobApplicationUpdateInput, JobApplicationUncheckedUpdateInput>
    /**
     * Choose, which JobApplication to update.
     */
    where: JobApplicationWhereUniqueInput
  }


  /**
   * JobApplication updateMany
   */
  export type JobApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobApplications.
     */
    data: XOR<JobApplicationUpdateManyMutationInput, JobApplicationUncheckedUpdateManyInput>
    /**
     * Filter which JobApplications to update
     */
    where?: JobApplicationWhereInput
  }


  /**
   * JobApplication upsert
   */
  export type JobApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the JobApplication to update in case it exists.
     */
    where: JobApplicationWhereUniqueInput
    /**
     * In case the JobApplication found by the `where` argument doesn't exist, create a new JobApplication with this data.
     */
    create: XOR<JobApplicationCreateInput, JobApplicationUncheckedCreateInput>
    /**
     * In case the JobApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobApplicationUpdateInput, JobApplicationUncheckedUpdateInput>
  }


  /**
   * JobApplication delete
   */
  export type JobApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter which JobApplication to delete.
     */
    where: JobApplicationWhereUniqueInput
  }


  /**
   * JobApplication deleteMany
   */
  export type JobApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobApplications to delete
     */
    where?: JobApplicationWhereInput
  }


  /**
   * JobApplication.formResponse
   */
  export type JobApplication$formResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormResponseInclude<ExtArgs> | null
    where?: FormResponseWhereInput
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    cursor?: FormResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormResponseScalarFieldEnum | FormResponseScalarFieldEnum[]
  }


  /**
   * JobApplication without action
   */
  export type JobApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobApplicationInclude<ExtArgs> | null
  }



  /**
   * Model CandidateApplication
   */

  export type AggregateCandidateApplication = {
    _count: CandidateApplicationCountAggregateOutputType | null
    _min: CandidateApplicationMinAggregateOutputType | null
    _max: CandidateApplicationMaxAggregateOutputType | null
  }

  export type CandidateApplicationMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    createdAt: Date | null
    stageId: string | null
  }

  export type CandidateApplicationMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    createdAt: Date | null
    stageId: string | null
  }

  export type CandidateApplicationCountAggregateOutputType = {
    id: number
    jobId: number
    createdAt: number
    stageId: number
    _all: number
  }


  export type CandidateApplicationMinAggregateInputType = {
    id?: true
    jobId?: true
    createdAt?: true
    stageId?: true
  }

  export type CandidateApplicationMaxAggregateInputType = {
    id?: true
    jobId?: true
    createdAt?: true
    stageId?: true
  }

  export type CandidateApplicationCountAggregateInputType = {
    id?: true
    jobId?: true
    createdAt?: true
    stageId?: true
    _all?: true
  }

  export type CandidateApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CandidateApplication to aggregate.
     */
    where?: CandidateApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateApplications to fetch.
     */
    orderBy?: CandidateApplicationOrderByWithRelationInput | CandidateApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CandidateApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CandidateApplications
    **/
    _count?: true | CandidateApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CandidateApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CandidateApplicationMaxAggregateInputType
  }

  export type GetCandidateApplicationAggregateType<T extends CandidateApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateCandidateApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCandidateApplication[P]>
      : GetScalarType<T[P], AggregateCandidateApplication[P]>
  }




  export type CandidateApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidateApplicationWhereInput
    orderBy?: CandidateApplicationOrderByWithAggregationInput | CandidateApplicationOrderByWithAggregationInput[]
    by: CandidateApplicationScalarFieldEnum[] | CandidateApplicationScalarFieldEnum
    having?: CandidateApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CandidateApplicationCountAggregateInputType | true
    _min?: CandidateApplicationMinAggregateInputType
    _max?: CandidateApplicationMaxAggregateInputType
  }

  export type CandidateApplicationGroupByOutputType = {
    id: string
    jobId: string
    createdAt: Date
    stageId: string
    _count: CandidateApplicationCountAggregateOutputType | null
    _min: CandidateApplicationMinAggregateOutputType | null
    _max: CandidateApplicationMaxAggregateOutputType | null
  }

  type GetCandidateApplicationGroupByPayload<T extends CandidateApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CandidateApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CandidateApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CandidateApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], CandidateApplicationGroupByOutputType[P]>
        }
      >
    >


  export type CandidateApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    createdAt?: boolean
    stageId?: boolean
    jobPost?: boolean | JobPostDefaultArgs<ExtArgs>
    jobStage?: boolean | JobStageDefaultArgs<ExtArgs>
    formResponses?: boolean | CandidateApplication$formResponsesArgs<ExtArgs>
    emailMessage?: boolean | CandidateApplication$emailMessageArgs<ExtArgs>
    CandidateTimeline?: boolean | CandidateApplication$CandidateTimelineArgs<ExtArgs>
    _count?: boolean | CandidateApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candidateApplication"]>

  export type CandidateApplicationSelectScalar = {
    id?: boolean
    jobId?: boolean
    createdAt?: boolean
    stageId?: boolean
  }

  export type CandidateApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPost?: boolean | JobPostDefaultArgs<ExtArgs>
    jobStage?: boolean | JobStageDefaultArgs<ExtArgs>
    formResponses?: boolean | CandidateApplication$formResponsesArgs<ExtArgs>
    emailMessage?: boolean | CandidateApplication$emailMessageArgs<ExtArgs>
    CandidateTimeline?: boolean | CandidateApplication$CandidateTimelineArgs<ExtArgs>
    _count?: boolean | CandidateApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CandidateApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CandidateApplication"
    objects: {
      jobPost: Prisma.$JobPostPayload<ExtArgs>
      jobStage: Prisma.$JobStagePayload<ExtArgs>
      formResponses: Prisma.$FormResponsePayload<ExtArgs>[]
      emailMessage: Prisma.$EmailMessagePayload<ExtArgs>[]
      CandidateTimeline: Prisma.$CandidateTimelinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      createdAt: Date
      stageId: string
    }, ExtArgs["result"]["candidateApplication"]>
    composites: {}
  }


  type CandidateApplicationGetPayload<S extends boolean | null | undefined | CandidateApplicationDefaultArgs> = $Result.GetResult<Prisma.$CandidateApplicationPayload, S>

  type CandidateApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CandidateApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CandidateApplicationCountAggregateInputType | true
    }

  export interface CandidateApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CandidateApplication'], meta: { name: 'CandidateApplication' } }
    /**
     * Find zero or one CandidateApplication that matches the filter.
     * @param {CandidateApplicationFindUniqueArgs} args - Arguments to find a CandidateApplication
     * @example
     * // Get one CandidateApplication
     * const candidateApplication = await prisma.candidateApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CandidateApplicationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateApplicationFindUniqueArgs<ExtArgs>>
    ): Prisma__CandidateApplicationClient<$Result.GetResult<Prisma.$CandidateApplicationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CandidateApplication that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CandidateApplicationFindUniqueOrThrowArgs} args - Arguments to find a CandidateApplication
     * @example
     * // Get one CandidateApplication
     * const candidateApplication = await prisma.candidateApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CandidateApplicationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateApplicationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CandidateApplicationClient<$Result.GetResult<Prisma.$CandidateApplicationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CandidateApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateApplicationFindFirstArgs} args - Arguments to find a CandidateApplication
     * @example
     * // Get one CandidateApplication
     * const candidateApplication = await prisma.candidateApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CandidateApplicationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateApplicationFindFirstArgs<ExtArgs>>
    ): Prisma__CandidateApplicationClient<$Result.GetResult<Prisma.$CandidateApplicationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CandidateApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateApplicationFindFirstOrThrowArgs} args - Arguments to find a CandidateApplication
     * @example
     * // Get one CandidateApplication
     * const candidateApplication = await prisma.candidateApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CandidateApplicationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateApplicationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CandidateApplicationClient<$Result.GetResult<Prisma.$CandidateApplicationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CandidateApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateApplicationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CandidateApplications
     * const candidateApplications = await prisma.candidateApplication.findMany()
     * 
     * // Get first 10 CandidateApplications
     * const candidateApplications = await prisma.candidateApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const candidateApplicationWithIdOnly = await prisma.candidateApplication.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CandidateApplicationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateApplicationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidateApplicationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CandidateApplication.
     * @param {CandidateApplicationCreateArgs} args - Arguments to create a CandidateApplication.
     * @example
     * // Create one CandidateApplication
     * const CandidateApplication = await prisma.candidateApplication.create({
     *   data: {
     *     // ... data to create a CandidateApplication
     *   }
     * })
     * 
    **/
    create<T extends CandidateApplicationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateApplicationCreateArgs<ExtArgs>>
    ): Prisma__CandidateApplicationClient<$Result.GetResult<Prisma.$CandidateApplicationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CandidateApplications.
     *     @param {CandidateApplicationCreateManyArgs} args - Arguments to create many CandidateApplications.
     *     @example
     *     // Create many CandidateApplications
     *     const candidateApplication = await prisma.candidateApplication.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CandidateApplicationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateApplicationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CandidateApplication.
     * @param {CandidateApplicationDeleteArgs} args - Arguments to delete one CandidateApplication.
     * @example
     * // Delete one CandidateApplication
     * const CandidateApplication = await prisma.candidateApplication.delete({
     *   where: {
     *     // ... filter to delete one CandidateApplication
     *   }
     * })
     * 
    **/
    delete<T extends CandidateApplicationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateApplicationDeleteArgs<ExtArgs>>
    ): Prisma__CandidateApplicationClient<$Result.GetResult<Prisma.$CandidateApplicationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CandidateApplication.
     * @param {CandidateApplicationUpdateArgs} args - Arguments to update one CandidateApplication.
     * @example
     * // Update one CandidateApplication
     * const candidateApplication = await prisma.candidateApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CandidateApplicationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateApplicationUpdateArgs<ExtArgs>>
    ): Prisma__CandidateApplicationClient<$Result.GetResult<Prisma.$CandidateApplicationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CandidateApplications.
     * @param {CandidateApplicationDeleteManyArgs} args - Arguments to filter CandidateApplications to delete.
     * @example
     * // Delete a few CandidateApplications
     * const { count } = await prisma.candidateApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CandidateApplicationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateApplicationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CandidateApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CandidateApplications
     * const candidateApplication = await prisma.candidateApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CandidateApplicationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateApplicationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CandidateApplication.
     * @param {CandidateApplicationUpsertArgs} args - Arguments to update or create a CandidateApplication.
     * @example
     * // Update or create a CandidateApplication
     * const candidateApplication = await prisma.candidateApplication.upsert({
     *   create: {
     *     // ... data to create a CandidateApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CandidateApplication we want to update
     *   }
     * })
    **/
    upsert<T extends CandidateApplicationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateApplicationUpsertArgs<ExtArgs>>
    ): Prisma__CandidateApplicationClient<$Result.GetResult<Prisma.$CandidateApplicationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CandidateApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateApplicationCountArgs} args - Arguments to filter CandidateApplications to count.
     * @example
     * // Count the number of CandidateApplications
     * const count = await prisma.candidateApplication.count({
     *   where: {
     *     // ... the filter for the CandidateApplications we want to count
     *   }
     * })
    **/
    count<T extends CandidateApplicationCountArgs>(
      args?: Subset<T, CandidateApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CandidateApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CandidateApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CandidateApplicationAggregateArgs>(args: Subset<T, CandidateApplicationAggregateArgs>): Prisma.PrismaPromise<GetCandidateApplicationAggregateType<T>>

    /**
     * Group by CandidateApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CandidateApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CandidateApplicationGroupByArgs['orderBy'] }
        : { orderBy?: CandidateApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CandidateApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCandidateApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CandidateApplication model
   */
  readonly fields: CandidateApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CandidateApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CandidateApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    jobPost<T extends JobPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostDefaultArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    jobStage<T extends JobStageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobStageDefaultArgs<ExtArgs>>): Prisma__JobStageClient<$Result.GetResult<Prisma.$JobStagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    formResponses<T extends CandidateApplication$formResponsesArgs<ExtArgs> = {}>(args?: Subset<T, CandidateApplication$formResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, 'findMany'> | Null>;

    emailMessage<T extends CandidateApplication$emailMessageArgs<ExtArgs> = {}>(args?: Subset<T, CandidateApplication$emailMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    CandidateTimeline<T extends CandidateApplication$CandidateTimelineArgs<ExtArgs> = {}>(args?: Subset<T, CandidateApplication$CandidateTimelineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidateTimelinePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CandidateApplication model
   */ 
  interface CandidateApplicationFieldRefs {
    readonly id: FieldRef<"CandidateApplication", 'String'>
    readonly jobId: FieldRef<"CandidateApplication", 'String'>
    readonly createdAt: FieldRef<"CandidateApplication", 'DateTime'>
    readonly stageId: FieldRef<"CandidateApplication", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CandidateApplication findUnique
   */
  export type CandidateApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateApplication
     */
    select?: CandidateApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateApplicationInclude<ExtArgs> | null
    /**
     * Filter, which CandidateApplication to fetch.
     */
    where: CandidateApplicationWhereUniqueInput
  }


  /**
   * CandidateApplication findUniqueOrThrow
   */
  export type CandidateApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateApplication
     */
    select?: CandidateApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateApplicationInclude<ExtArgs> | null
    /**
     * Filter, which CandidateApplication to fetch.
     */
    where: CandidateApplicationWhereUniqueInput
  }


  /**
   * CandidateApplication findFirst
   */
  export type CandidateApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateApplication
     */
    select?: CandidateApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateApplicationInclude<ExtArgs> | null
    /**
     * Filter, which CandidateApplication to fetch.
     */
    where?: CandidateApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateApplications to fetch.
     */
    orderBy?: CandidateApplicationOrderByWithRelationInput | CandidateApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CandidateApplications.
     */
    cursor?: CandidateApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CandidateApplications.
     */
    distinct?: CandidateApplicationScalarFieldEnum | CandidateApplicationScalarFieldEnum[]
  }


  /**
   * CandidateApplication findFirstOrThrow
   */
  export type CandidateApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateApplication
     */
    select?: CandidateApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateApplicationInclude<ExtArgs> | null
    /**
     * Filter, which CandidateApplication to fetch.
     */
    where?: CandidateApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateApplications to fetch.
     */
    orderBy?: CandidateApplicationOrderByWithRelationInput | CandidateApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CandidateApplications.
     */
    cursor?: CandidateApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CandidateApplications.
     */
    distinct?: CandidateApplicationScalarFieldEnum | CandidateApplicationScalarFieldEnum[]
  }


  /**
   * CandidateApplication findMany
   */
  export type CandidateApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateApplication
     */
    select?: CandidateApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateApplicationInclude<ExtArgs> | null
    /**
     * Filter, which CandidateApplications to fetch.
     */
    where?: CandidateApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateApplications to fetch.
     */
    orderBy?: CandidateApplicationOrderByWithRelationInput | CandidateApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CandidateApplications.
     */
    cursor?: CandidateApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateApplications.
     */
    skip?: number
    distinct?: CandidateApplicationScalarFieldEnum | CandidateApplicationScalarFieldEnum[]
  }


  /**
   * CandidateApplication create
   */
  export type CandidateApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateApplication
     */
    select?: CandidateApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a CandidateApplication.
     */
    data: XOR<CandidateApplicationCreateInput, CandidateApplicationUncheckedCreateInput>
  }


  /**
   * CandidateApplication createMany
   */
  export type CandidateApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CandidateApplications.
     */
    data: CandidateApplicationCreateManyInput | CandidateApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CandidateApplication update
   */
  export type CandidateApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateApplication
     */
    select?: CandidateApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a CandidateApplication.
     */
    data: XOR<CandidateApplicationUpdateInput, CandidateApplicationUncheckedUpdateInput>
    /**
     * Choose, which CandidateApplication to update.
     */
    where: CandidateApplicationWhereUniqueInput
  }


  /**
   * CandidateApplication updateMany
   */
  export type CandidateApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CandidateApplications.
     */
    data: XOR<CandidateApplicationUpdateManyMutationInput, CandidateApplicationUncheckedUpdateManyInput>
    /**
     * Filter which CandidateApplications to update
     */
    where?: CandidateApplicationWhereInput
  }


  /**
   * CandidateApplication upsert
   */
  export type CandidateApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateApplication
     */
    select?: CandidateApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the CandidateApplication to update in case it exists.
     */
    where: CandidateApplicationWhereUniqueInput
    /**
     * In case the CandidateApplication found by the `where` argument doesn't exist, create a new CandidateApplication with this data.
     */
    create: XOR<CandidateApplicationCreateInput, CandidateApplicationUncheckedCreateInput>
    /**
     * In case the CandidateApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CandidateApplicationUpdateInput, CandidateApplicationUncheckedUpdateInput>
  }


  /**
   * CandidateApplication delete
   */
  export type CandidateApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateApplication
     */
    select?: CandidateApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateApplicationInclude<ExtArgs> | null
    /**
     * Filter which CandidateApplication to delete.
     */
    where: CandidateApplicationWhereUniqueInput
  }


  /**
   * CandidateApplication deleteMany
   */
  export type CandidateApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CandidateApplications to delete
     */
    where?: CandidateApplicationWhereInput
  }


  /**
   * CandidateApplication.formResponses
   */
  export type CandidateApplication$formResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormResponseInclude<ExtArgs> | null
    where?: FormResponseWhereInput
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    cursor?: FormResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormResponseScalarFieldEnum | FormResponseScalarFieldEnum[]
  }


  /**
   * CandidateApplication.emailMessage
   */
  export type CandidateApplication$emailMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailMessageInclude<ExtArgs> | null
    where?: EmailMessageWhereInput
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    cursor?: EmailMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }


  /**
   * CandidateApplication.CandidateTimeline
   */
  export type CandidateApplication$CandidateTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateTimeline
     */
    select?: CandidateTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateTimelineInclude<ExtArgs> | null
    where?: CandidateTimelineWhereInput
    orderBy?: CandidateTimelineOrderByWithRelationInput | CandidateTimelineOrderByWithRelationInput[]
    cursor?: CandidateTimelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CandidateTimelineScalarFieldEnum | CandidateTimelineScalarFieldEnum[]
  }


  /**
   * CandidateApplication without action
   */
  export type CandidateApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateApplication
     */
    select?: CandidateApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateApplicationInclude<ExtArgs> | null
  }



  /**
   * Model CandidateReview
   */

  export type AggregateCandidateReview = {
    _count: CandidateReviewCountAggregateOutputType | null
    _min: CandidateReviewMinAggregateOutputType | null
    _max: CandidateReviewMaxAggregateOutputType | null
  }

  export type CandidateReviewMinAggregateOutputType = {
    id: string | null
    description: string | null
    verdict: string | null
    createdAt: Date | null
  }

  export type CandidateReviewMaxAggregateOutputType = {
    id: string | null
    description: string | null
    verdict: string | null
    createdAt: Date | null
  }

  export type CandidateReviewCountAggregateOutputType = {
    id: number
    description: number
    verdict: number
    createdAt: number
    _all: number
  }


  export type CandidateReviewMinAggregateInputType = {
    id?: true
    description?: true
    verdict?: true
    createdAt?: true
  }

  export type CandidateReviewMaxAggregateInputType = {
    id?: true
    description?: true
    verdict?: true
    createdAt?: true
  }

  export type CandidateReviewCountAggregateInputType = {
    id?: true
    description?: true
    verdict?: true
    createdAt?: true
    _all?: true
  }

  export type CandidateReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CandidateReview to aggregate.
     */
    where?: CandidateReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateReviews to fetch.
     */
    orderBy?: CandidateReviewOrderByWithRelationInput | CandidateReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CandidateReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CandidateReviews
    **/
    _count?: true | CandidateReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CandidateReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CandidateReviewMaxAggregateInputType
  }

  export type GetCandidateReviewAggregateType<T extends CandidateReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateCandidateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCandidateReview[P]>
      : GetScalarType<T[P], AggregateCandidateReview[P]>
  }




  export type CandidateReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidateReviewWhereInput
    orderBy?: CandidateReviewOrderByWithAggregationInput | CandidateReviewOrderByWithAggregationInput[]
    by: CandidateReviewScalarFieldEnum[] | CandidateReviewScalarFieldEnum
    having?: CandidateReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CandidateReviewCountAggregateInputType | true
    _min?: CandidateReviewMinAggregateInputType
    _max?: CandidateReviewMaxAggregateInputType
  }

  export type CandidateReviewGroupByOutputType = {
    id: string
    description: string | null
    verdict: string
    createdAt: Date
    _count: CandidateReviewCountAggregateOutputType | null
    _min: CandidateReviewMinAggregateOutputType | null
    _max: CandidateReviewMaxAggregateOutputType | null
  }

  type GetCandidateReviewGroupByPayload<T extends CandidateReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CandidateReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CandidateReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CandidateReviewGroupByOutputType[P]>
            : GetScalarType<T[P], CandidateReviewGroupByOutputType[P]>
        }
      >
    >


  export type CandidateReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    verdict?: boolean
    createdAt?: boolean
    candidateTimeline?: boolean | CandidateReview$candidateTimelineArgs<ExtArgs>
    _count?: boolean | CandidateReviewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candidateReview"]>

  export type CandidateReviewSelectScalar = {
    id?: boolean
    description?: boolean
    verdict?: boolean
    createdAt?: boolean
  }

  export type CandidateReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidateTimeline?: boolean | CandidateReview$candidateTimelineArgs<ExtArgs>
    _count?: boolean | CandidateReviewCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CandidateReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CandidateReview"
    objects: {
      candidateTimeline: Prisma.$CandidateTimelinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string | null
      verdict: string
      createdAt: Date
    }, ExtArgs["result"]["candidateReview"]>
    composites: {}
  }


  type CandidateReviewGetPayload<S extends boolean | null | undefined | CandidateReviewDefaultArgs> = $Result.GetResult<Prisma.$CandidateReviewPayload, S>

  type CandidateReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CandidateReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CandidateReviewCountAggregateInputType | true
    }

  export interface CandidateReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CandidateReview'], meta: { name: 'CandidateReview' } }
    /**
     * Find zero or one CandidateReview that matches the filter.
     * @param {CandidateReviewFindUniqueArgs} args - Arguments to find a CandidateReview
     * @example
     * // Get one CandidateReview
     * const candidateReview = await prisma.candidateReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CandidateReviewFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateReviewFindUniqueArgs<ExtArgs>>
    ): Prisma__CandidateReviewClient<$Result.GetResult<Prisma.$CandidateReviewPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CandidateReview that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CandidateReviewFindUniqueOrThrowArgs} args - Arguments to find a CandidateReview
     * @example
     * // Get one CandidateReview
     * const candidateReview = await prisma.candidateReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CandidateReviewFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateReviewFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CandidateReviewClient<$Result.GetResult<Prisma.$CandidateReviewPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CandidateReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateReviewFindFirstArgs} args - Arguments to find a CandidateReview
     * @example
     * // Get one CandidateReview
     * const candidateReview = await prisma.candidateReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CandidateReviewFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateReviewFindFirstArgs<ExtArgs>>
    ): Prisma__CandidateReviewClient<$Result.GetResult<Prisma.$CandidateReviewPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CandidateReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateReviewFindFirstOrThrowArgs} args - Arguments to find a CandidateReview
     * @example
     * // Get one CandidateReview
     * const candidateReview = await prisma.candidateReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CandidateReviewFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateReviewFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CandidateReviewClient<$Result.GetResult<Prisma.$CandidateReviewPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CandidateReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateReviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CandidateReviews
     * const candidateReviews = await prisma.candidateReview.findMany()
     * 
     * // Get first 10 CandidateReviews
     * const candidateReviews = await prisma.candidateReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const candidateReviewWithIdOnly = await prisma.candidateReview.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CandidateReviewFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateReviewFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidateReviewPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CandidateReview.
     * @param {CandidateReviewCreateArgs} args - Arguments to create a CandidateReview.
     * @example
     * // Create one CandidateReview
     * const CandidateReview = await prisma.candidateReview.create({
     *   data: {
     *     // ... data to create a CandidateReview
     *   }
     * })
     * 
    **/
    create<T extends CandidateReviewCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateReviewCreateArgs<ExtArgs>>
    ): Prisma__CandidateReviewClient<$Result.GetResult<Prisma.$CandidateReviewPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CandidateReviews.
     *     @param {CandidateReviewCreateManyArgs} args - Arguments to create many CandidateReviews.
     *     @example
     *     // Create many CandidateReviews
     *     const candidateReview = await prisma.candidateReview.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CandidateReviewCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateReviewCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CandidateReview.
     * @param {CandidateReviewDeleteArgs} args - Arguments to delete one CandidateReview.
     * @example
     * // Delete one CandidateReview
     * const CandidateReview = await prisma.candidateReview.delete({
     *   where: {
     *     // ... filter to delete one CandidateReview
     *   }
     * })
     * 
    **/
    delete<T extends CandidateReviewDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateReviewDeleteArgs<ExtArgs>>
    ): Prisma__CandidateReviewClient<$Result.GetResult<Prisma.$CandidateReviewPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CandidateReview.
     * @param {CandidateReviewUpdateArgs} args - Arguments to update one CandidateReview.
     * @example
     * // Update one CandidateReview
     * const candidateReview = await prisma.candidateReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CandidateReviewUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateReviewUpdateArgs<ExtArgs>>
    ): Prisma__CandidateReviewClient<$Result.GetResult<Prisma.$CandidateReviewPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CandidateReviews.
     * @param {CandidateReviewDeleteManyArgs} args - Arguments to filter CandidateReviews to delete.
     * @example
     * // Delete a few CandidateReviews
     * const { count } = await prisma.candidateReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CandidateReviewDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateReviewDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CandidateReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CandidateReviews
     * const candidateReview = await prisma.candidateReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CandidateReviewUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateReviewUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CandidateReview.
     * @param {CandidateReviewUpsertArgs} args - Arguments to update or create a CandidateReview.
     * @example
     * // Update or create a CandidateReview
     * const candidateReview = await prisma.candidateReview.upsert({
     *   create: {
     *     // ... data to create a CandidateReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CandidateReview we want to update
     *   }
     * })
    **/
    upsert<T extends CandidateReviewUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateReviewUpsertArgs<ExtArgs>>
    ): Prisma__CandidateReviewClient<$Result.GetResult<Prisma.$CandidateReviewPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CandidateReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateReviewCountArgs} args - Arguments to filter CandidateReviews to count.
     * @example
     * // Count the number of CandidateReviews
     * const count = await prisma.candidateReview.count({
     *   where: {
     *     // ... the filter for the CandidateReviews we want to count
     *   }
     * })
    **/
    count<T extends CandidateReviewCountArgs>(
      args?: Subset<T, CandidateReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CandidateReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CandidateReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CandidateReviewAggregateArgs>(args: Subset<T, CandidateReviewAggregateArgs>): Prisma.PrismaPromise<GetCandidateReviewAggregateType<T>>

    /**
     * Group by CandidateReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CandidateReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CandidateReviewGroupByArgs['orderBy'] }
        : { orderBy?: CandidateReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CandidateReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCandidateReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CandidateReview model
   */
  readonly fields: CandidateReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CandidateReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CandidateReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    candidateTimeline<T extends CandidateReview$candidateTimelineArgs<ExtArgs> = {}>(args?: Subset<T, CandidateReview$candidateTimelineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidateTimelinePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CandidateReview model
   */ 
  interface CandidateReviewFieldRefs {
    readonly id: FieldRef<"CandidateReview", 'String'>
    readonly description: FieldRef<"CandidateReview", 'String'>
    readonly verdict: FieldRef<"CandidateReview", 'String'>
    readonly createdAt: FieldRef<"CandidateReview", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * CandidateReview findUnique
   */
  export type CandidateReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateReview
     */
    select?: CandidateReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateReviewInclude<ExtArgs> | null
    /**
     * Filter, which CandidateReview to fetch.
     */
    where: CandidateReviewWhereUniqueInput
  }


  /**
   * CandidateReview findUniqueOrThrow
   */
  export type CandidateReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateReview
     */
    select?: CandidateReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateReviewInclude<ExtArgs> | null
    /**
     * Filter, which CandidateReview to fetch.
     */
    where: CandidateReviewWhereUniqueInput
  }


  /**
   * CandidateReview findFirst
   */
  export type CandidateReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateReview
     */
    select?: CandidateReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateReviewInclude<ExtArgs> | null
    /**
     * Filter, which CandidateReview to fetch.
     */
    where?: CandidateReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateReviews to fetch.
     */
    orderBy?: CandidateReviewOrderByWithRelationInput | CandidateReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CandidateReviews.
     */
    cursor?: CandidateReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CandidateReviews.
     */
    distinct?: CandidateReviewScalarFieldEnum | CandidateReviewScalarFieldEnum[]
  }


  /**
   * CandidateReview findFirstOrThrow
   */
  export type CandidateReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateReview
     */
    select?: CandidateReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateReviewInclude<ExtArgs> | null
    /**
     * Filter, which CandidateReview to fetch.
     */
    where?: CandidateReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateReviews to fetch.
     */
    orderBy?: CandidateReviewOrderByWithRelationInput | CandidateReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CandidateReviews.
     */
    cursor?: CandidateReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CandidateReviews.
     */
    distinct?: CandidateReviewScalarFieldEnum | CandidateReviewScalarFieldEnum[]
  }


  /**
   * CandidateReview findMany
   */
  export type CandidateReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateReview
     */
    select?: CandidateReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateReviewInclude<ExtArgs> | null
    /**
     * Filter, which CandidateReviews to fetch.
     */
    where?: CandidateReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateReviews to fetch.
     */
    orderBy?: CandidateReviewOrderByWithRelationInput | CandidateReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CandidateReviews.
     */
    cursor?: CandidateReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateReviews.
     */
    skip?: number
    distinct?: CandidateReviewScalarFieldEnum | CandidateReviewScalarFieldEnum[]
  }


  /**
   * CandidateReview create
   */
  export type CandidateReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateReview
     */
    select?: CandidateReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a CandidateReview.
     */
    data: XOR<CandidateReviewCreateInput, CandidateReviewUncheckedCreateInput>
  }


  /**
   * CandidateReview createMany
   */
  export type CandidateReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CandidateReviews.
     */
    data: CandidateReviewCreateManyInput | CandidateReviewCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CandidateReview update
   */
  export type CandidateReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateReview
     */
    select?: CandidateReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a CandidateReview.
     */
    data: XOR<CandidateReviewUpdateInput, CandidateReviewUncheckedUpdateInput>
    /**
     * Choose, which CandidateReview to update.
     */
    where: CandidateReviewWhereUniqueInput
  }


  /**
   * CandidateReview updateMany
   */
  export type CandidateReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CandidateReviews.
     */
    data: XOR<CandidateReviewUpdateManyMutationInput, CandidateReviewUncheckedUpdateManyInput>
    /**
     * Filter which CandidateReviews to update
     */
    where?: CandidateReviewWhereInput
  }


  /**
   * CandidateReview upsert
   */
  export type CandidateReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateReview
     */
    select?: CandidateReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the CandidateReview to update in case it exists.
     */
    where: CandidateReviewWhereUniqueInput
    /**
     * In case the CandidateReview found by the `where` argument doesn't exist, create a new CandidateReview with this data.
     */
    create: XOR<CandidateReviewCreateInput, CandidateReviewUncheckedCreateInput>
    /**
     * In case the CandidateReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CandidateReviewUpdateInput, CandidateReviewUncheckedUpdateInput>
  }


  /**
   * CandidateReview delete
   */
  export type CandidateReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateReview
     */
    select?: CandidateReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateReviewInclude<ExtArgs> | null
    /**
     * Filter which CandidateReview to delete.
     */
    where: CandidateReviewWhereUniqueInput
  }


  /**
   * CandidateReview deleteMany
   */
  export type CandidateReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CandidateReviews to delete
     */
    where?: CandidateReviewWhereInput
  }


  /**
   * CandidateReview.candidateTimeline
   */
  export type CandidateReview$candidateTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateTimeline
     */
    select?: CandidateTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateTimelineInclude<ExtArgs> | null
    where?: CandidateTimelineWhereInput
    orderBy?: CandidateTimelineOrderByWithRelationInput | CandidateTimelineOrderByWithRelationInput[]
    cursor?: CandidateTimelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CandidateTimelineScalarFieldEnum | CandidateTimelineScalarFieldEnum[]
  }


  /**
   * CandidateReview without action
   */
  export type CandidateReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateReview
     */
    select?: CandidateReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateReviewInclude<ExtArgs> | null
  }



  /**
   * Model CandidateTimeline
   */

  export type AggregateCandidateTimeline = {
    _count: CandidateTimelineCountAggregateOutputType | null
    _min: CandidateTimelineMinAggregateOutputType | null
    _max: CandidateTimelineMaxAggregateOutputType | null
  }

  export type CandidateTimelineMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    userId: string | null
    actionType: string | null
    jobId: string | null
    timelineText: string | null
    comment: string | null
    reviewId: string | null
    candidateId: string | null
  }

  export type CandidateTimelineMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    userId: string | null
    actionType: string | null
    jobId: string | null
    timelineText: string | null
    comment: string | null
    reviewId: string | null
    candidateId: string | null
  }

  export type CandidateTimelineCountAggregateOutputType = {
    id: number
    createdAt: number
    userId: number
    actionType: number
    jobId: number
    timelineText: number
    comment: number
    reviewId: number
    candidateId: number
    _all: number
  }


  export type CandidateTimelineMinAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    actionType?: true
    jobId?: true
    timelineText?: true
    comment?: true
    reviewId?: true
    candidateId?: true
  }

  export type CandidateTimelineMaxAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    actionType?: true
    jobId?: true
    timelineText?: true
    comment?: true
    reviewId?: true
    candidateId?: true
  }

  export type CandidateTimelineCountAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    actionType?: true
    jobId?: true
    timelineText?: true
    comment?: true
    reviewId?: true
    candidateId?: true
    _all?: true
  }

  export type CandidateTimelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CandidateTimeline to aggregate.
     */
    where?: CandidateTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateTimelines to fetch.
     */
    orderBy?: CandidateTimelineOrderByWithRelationInput | CandidateTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CandidateTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CandidateTimelines
    **/
    _count?: true | CandidateTimelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CandidateTimelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CandidateTimelineMaxAggregateInputType
  }

  export type GetCandidateTimelineAggregateType<T extends CandidateTimelineAggregateArgs> = {
        [P in keyof T & keyof AggregateCandidateTimeline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCandidateTimeline[P]>
      : GetScalarType<T[P], AggregateCandidateTimeline[P]>
  }




  export type CandidateTimelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidateTimelineWhereInput
    orderBy?: CandidateTimelineOrderByWithAggregationInput | CandidateTimelineOrderByWithAggregationInput[]
    by: CandidateTimelineScalarFieldEnum[] | CandidateTimelineScalarFieldEnum
    having?: CandidateTimelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CandidateTimelineCountAggregateInputType | true
    _min?: CandidateTimelineMinAggregateInputType
    _max?: CandidateTimelineMaxAggregateInputType
  }

  export type CandidateTimelineGroupByOutputType = {
    id: string
    createdAt: Date
    userId: string | null
    actionType: string
    jobId: string
    timelineText: string
    comment: string | null
    reviewId: string | null
    candidateId: string
    _count: CandidateTimelineCountAggregateOutputType | null
    _min: CandidateTimelineMinAggregateOutputType | null
    _max: CandidateTimelineMaxAggregateOutputType | null
  }

  type GetCandidateTimelineGroupByPayload<T extends CandidateTimelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CandidateTimelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CandidateTimelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CandidateTimelineGroupByOutputType[P]>
            : GetScalarType<T[P], CandidateTimelineGroupByOutputType[P]>
        }
      >
    >


  export type CandidateTimelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    actionType?: boolean
    jobId?: boolean
    timelineText?: boolean
    comment?: boolean
    reviewId?: boolean
    candidateId?: boolean
    candidateReview?: boolean | CandidateTimeline$candidateReviewArgs<ExtArgs>
    candidateApplication?: boolean | CandidateApplicationDefaultArgs<ExtArgs>
    jobPost?: boolean | JobPostDefaultArgs<ExtArgs>
    user?: boolean | CandidateTimeline$userArgs<ExtArgs>
  }, ExtArgs["result"]["candidateTimeline"]>

  export type CandidateTimelineSelectScalar = {
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    actionType?: boolean
    jobId?: boolean
    timelineText?: boolean
    comment?: boolean
    reviewId?: boolean
    candidateId?: boolean
  }

  export type CandidateTimelineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidateReview?: boolean | CandidateTimeline$candidateReviewArgs<ExtArgs>
    candidateApplication?: boolean | CandidateApplicationDefaultArgs<ExtArgs>
    jobPost?: boolean | JobPostDefaultArgs<ExtArgs>
    user?: boolean | CandidateTimeline$userArgs<ExtArgs>
  }


  export type $CandidateTimelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CandidateTimeline"
    objects: {
      candidateReview: Prisma.$CandidateReviewPayload<ExtArgs> | null
      candidateApplication: Prisma.$CandidateApplicationPayload<ExtArgs>
      jobPost: Prisma.$JobPostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      userId: string | null
      actionType: string
      jobId: string
      timelineText: string
      comment: string | null
      reviewId: string | null
      candidateId: string
    }, ExtArgs["result"]["candidateTimeline"]>
    composites: {}
  }


  type CandidateTimelineGetPayload<S extends boolean | null | undefined | CandidateTimelineDefaultArgs> = $Result.GetResult<Prisma.$CandidateTimelinePayload, S>

  type CandidateTimelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CandidateTimelineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CandidateTimelineCountAggregateInputType | true
    }

  export interface CandidateTimelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CandidateTimeline'], meta: { name: 'CandidateTimeline' } }
    /**
     * Find zero or one CandidateTimeline that matches the filter.
     * @param {CandidateTimelineFindUniqueArgs} args - Arguments to find a CandidateTimeline
     * @example
     * // Get one CandidateTimeline
     * const candidateTimeline = await prisma.candidateTimeline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CandidateTimelineFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateTimelineFindUniqueArgs<ExtArgs>>
    ): Prisma__CandidateTimelineClient<$Result.GetResult<Prisma.$CandidateTimelinePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CandidateTimeline that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CandidateTimelineFindUniqueOrThrowArgs} args - Arguments to find a CandidateTimeline
     * @example
     * // Get one CandidateTimeline
     * const candidateTimeline = await prisma.candidateTimeline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CandidateTimelineFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateTimelineFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CandidateTimelineClient<$Result.GetResult<Prisma.$CandidateTimelinePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CandidateTimeline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateTimelineFindFirstArgs} args - Arguments to find a CandidateTimeline
     * @example
     * // Get one CandidateTimeline
     * const candidateTimeline = await prisma.candidateTimeline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CandidateTimelineFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateTimelineFindFirstArgs<ExtArgs>>
    ): Prisma__CandidateTimelineClient<$Result.GetResult<Prisma.$CandidateTimelinePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CandidateTimeline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateTimelineFindFirstOrThrowArgs} args - Arguments to find a CandidateTimeline
     * @example
     * // Get one CandidateTimeline
     * const candidateTimeline = await prisma.candidateTimeline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CandidateTimelineFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateTimelineFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CandidateTimelineClient<$Result.GetResult<Prisma.$CandidateTimelinePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CandidateTimelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateTimelineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CandidateTimelines
     * const candidateTimelines = await prisma.candidateTimeline.findMany()
     * 
     * // Get first 10 CandidateTimelines
     * const candidateTimelines = await prisma.candidateTimeline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const candidateTimelineWithIdOnly = await prisma.candidateTimeline.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CandidateTimelineFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateTimelineFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidateTimelinePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CandidateTimeline.
     * @param {CandidateTimelineCreateArgs} args - Arguments to create a CandidateTimeline.
     * @example
     * // Create one CandidateTimeline
     * const CandidateTimeline = await prisma.candidateTimeline.create({
     *   data: {
     *     // ... data to create a CandidateTimeline
     *   }
     * })
     * 
    **/
    create<T extends CandidateTimelineCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateTimelineCreateArgs<ExtArgs>>
    ): Prisma__CandidateTimelineClient<$Result.GetResult<Prisma.$CandidateTimelinePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CandidateTimelines.
     *     @param {CandidateTimelineCreateManyArgs} args - Arguments to create many CandidateTimelines.
     *     @example
     *     // Create many CandidateTimelines
     *     const candidateTimeline = await prisma.candidateTimeline.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CandidateTimelineCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateTimelineCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CandidateTimeline.
     * @param {CandidateTimelineDeleteArgs} args - Arguments to delete one CandidateTimeline.
     * @example
     * // Delete one CandidateTimeline
     * const CandidateTimeline = await prisma.candidateTimeline.delete({
     *   where: {
     *     // ... filter to delete one CandidateTimeline
     *   }
     * })
     * 
    **/
    delete<T extends CandidateTimelineDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateTimelineDeleteArgs<ExtArgs>>
    ): Prisma__CandidateTimelineClient<$Result.GetResult<Prisma.$CandidateTimelinePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CandidateTimeline.
     * @param {CandidateTimelineUpdateArgs} args - Arguments to update one CandidateTimeline.
     * @example
     * // Update one CandidateTimeline
     * const candidateTimeline = await prisma.candidateTimeline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CandidateTimelineUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateTimelineUpdateArgs<ExtArgs>>
    ): Prisma__CandidateTimelineClient<$Result.GetResult<Prisma.$CandidateTimelinePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CandidateTimelines.
     * @param {CandidateTimelineDeleteManyArgs} args - Arguments to filter CandidateTimelines to delete.
     * @example
     * // Delete a few CandidateTimelines
     * const { count } = await prisma.candidateTimeline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CandidateTimelineDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidateTimelineDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CandidateTimelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateTimelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CandidateTimelines
     * const candidateTimeline = await prisma.candidateTimeline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CandidateTimelineUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateTimelineUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CandidateTimeline.
     * @param {CandidateTimelineUpsertArgs} args - Arguments to update or create a CandidateTimeline.
     * @example
     * // Update or create a CandidateTimeline
     * const candidateTimeline = await prisma.candidateTimeline.upsert({
     *   create: {
     *     // ... data to create a CandidateTimeline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CandidateTimeline we want to update
     *   }
     * })
    **/
    upsert<T extends CandidateTimelineUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CandidateTimelineUpsertArgs<ExtArgs>>
    ): Prisma__CandidateTimelineClient<$Result.GetResult<Prisma.$CandidateTimelinePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CandidateTimelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateTimelineCountArgs} args - Arguments to filter CandidateTimelines to count.
     * @example
     * // Count the number of CandidateTimelines
     * const count = await prisma.candidateTimeline.count({
     *   where: {
     *     // ... the filter for the CandidateTimelines we want to count
     *   }
     * })
    **/
    count<T extends CandidateTimelineCountArgs>(
      args?: Subset<T, CandidateTimelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CandidateTimelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CandidateTimeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateTimelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CandidateTimelineAggregateArgs>(args: Subset<T, CandidateTimelineAggregateArgs>): Prisma.PrismaPromise<GetCandidateTimelineAggregateType<T>>

    /**
     * Group by CandidateTimeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateTimelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CandidateTimelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CandidateTimelineGroupByArgs['orderBy'] }
        : { orderBy?: CandidateTimelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CandidateTimelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCandidateTimelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CandidateTimeline model
   */
  readonly fields: CandidateTimelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CandidateTimeline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CandidateTimelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    candidateReview<T extends CandidateTimeline$candidateReviewArgs<ExtArgs> = {}>(args?: Subset<T, CandidateTimeline$candidateReviewArgs<ExtArgs>>): Prisma__CandidateReviewClient<$Result.GetResult<Prisma.$CandidateReviewPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    candidateApplication<T extends CandidateApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CandidateApplicationDefaultArgs<ExtArgs>>): Prisma__CandidateApplicationClient<$Result.GetResult<Prisma.$CandidateApplicationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    jobPost<T extends JobPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostDefaultArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends CandidateTimeline$userArgs<ExtArgs> = {}>(args?: Subset<T, CandidateTimeline$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CandidateTimeline model
   */ 
  interface CandidateTimelineFieldRefs {
    readonly id: FieldRef<"CandidateTimeline", 'String'>
    readonly createdAt: FieldRef<"CandidateTimeline", 'DateTime'>
    readonly userId: FieldRef<"CandidateTimeline", 'String'>
    readonly actionType: FieldRef<"CandidateTimeline", 'String'>
    readonly jobId: FieldRef<"CandidateTimeline", 'String'>
    readonly timelineText: FieldRef<"CandidateTimeline", 'String'>
    readonly comment: FieldRef<"CandidateTimeline", 'String'>
    readonly reviewId: FieldRef<"CandidateTimeline", 'String'>
    readonly candidateId: FieldRef<"CandidateTimeline", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CandidateTimeline findUnique
   */
  export type CandidateTimelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateTimeline
     */
    select?: CandidateTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateTimelineInclude<ExtArgs> | null
    /**
     * Filter, which CandidateTimeline to fetch.
     */
    where: CandidateTimelineWhereUniqueInput
  }


  /**
   * CandidateTimeline findUniqueOrThrow
   */
  export type CandidateTimelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateTimeline
     */
    select?: CandidateTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateTimelineInclude<ExtArgs> | null
    /**
     * Filter, which CandidateTimeline to fetch.
     */
    where: CandidateTimelineWhereUniqueInput
  }


  /**
   * CandidateTimeline findFirst
   */
  export type CandidateTimelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateTimeline
     */
    select?: CandidateTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateTimelineInclude<ExtArgs> | null
    /**
     * Filter, which CandidateTimeline to fetch.
     */
    where?: CandidateTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateTimelines to fetch.
     */
    orderBy?: CandidateTimelineOrderByWithRelationInput | CandidateTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CandidateTimelines.
     */
    cursor?: CandidateTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CandidateTimelines.
     */
    distinct?: CandidateTimelineScalarFieldEnum | CandidateTimelineScalarFieldEnum[]
  }


  /**
   * CandidateTimeline findFirstOrThrow
   */
  export type CandidateTimelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateTimeline
     */
    select?: CandidateTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateTimelineInclude<ExtArgs> | null
    /**
     * Filter, which CandidateTimeline to fetch.
     */
    where?: CandidateTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateTimelines to fetch.
     */
    orderBy?: CandidateTimelineOrderByWithRelationInput | CandidateTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CandidateTimelines.
     */
    cursor?: CandidateTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CandidateTimelines.
     */
    distinct?: CandidateTimelineScalarFieldEnum | CandidateTimelineScalarFieldEnum[]
  }


  /**
   * CandidateTimeline findMany
   */
  export type CandidateTimelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateTimeline
     */
    select?: CandidateTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateTimelineInclude<ExtArgs> | null
    /**
     * Filter, which CandidateTimelines to fetch.
     */
    where?: CandidateTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateTimelines to fetch.
     */
    orderBy?: CandidateTimelineOrderByWithRelationInput | CandidateTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CandidateTimelines.
     */
    cursor?: CandidateTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateTimelines.
     */
    skip?: number
    distinct?: CandidateTimelineScalarFieldEnum | CandidateTimelineScalarFieldEnum[]
  }


  /**
   * CandidateTimeline create
   */
  export type CandidateTimelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateTimeline
     */
    select?: CandidateTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateTimelineInclude<ExtArgs> | null
    /**
     * The data needed to create a CandidateTimeline.
     */
    data: XOR<CandidateTimelineCreateInput, CandidateTimelineUncheckedCreateInput>
  }


  /**
   * CandidateTimeline createMany
   */
  export type CandidateTimelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CandidateTimelines.
     */
    data: CandidateTimelineCreateManyInput | CandidateTimelineCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CandidateTimeline update
   */
  export type CandidateTimelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateTimeline
     */
    select?: CandidateTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateTimelineInclude<ExtArgs> | null
    /**
     * The data needed to update a CandidateTimeline.
     */
    data: XOR<CandidateTimelineUpdateInput, CandidateTimelineUncheckedUpdateInput>
    /**
     * Choose, which CandidateTimeline to update.
     */
    where: CandidateTimelineWhereUniqueInput
  }


  /**
   * CandidateTimeline updateMany
   */
  export type CandidateTimelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CandidateTimelines.
     */
    data: XOR<CandidateTimelineUpdateManyMutationInput, CandidateTimelineUncheckedUpdateManyInput>
    /**
     * Filter which CandidateTimelines to update
     */
    where?: CandidateTimelineWhereInput
  }


  /**
   * CandidateTimeline upsert
   */
  export type CandidateTimelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateTimeline
     */
    select?: CandidateTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateTimelineInclude<ExtArgs> | null
    /**
     * The filter to search for the CandidateTimeline to update in case it exists.
     */
    where: CandidateTimelineWhereUniqueInput
    /**
     * In case the CandidateTimeline found by the `where` argument doesn't exist, create a new CandidateTimeline with this data.
     */
    create: XOR<CandidateTimelineCreateInput, CandidateTimelineUncheckedCreateInput>
    /**
     * In case the CandidateTimeline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CandidateTimelineUpdateInput, CandidateTimelineUncheckedUpdateInput>
  }


  /**
   * CandidateTimeline delete
   */
  export type CandidateTimelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateTimeline
     */
    select?: CandidateTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateTimelineInclude<ExtArgs> | null
    /**
     * Filter which CandidateTimeline to delete.
     */
    where: CandidateTimelineWhereUniqueInput
  }


  /**
   * CandidateTimeline deleteMany
   */
  export type CandidateTimelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CandidateTimelines to delete
     */
    where?: CandidateTimelineWhereInput
  }


  /**
   * CandidateTimeline.candidateReview
   */
  export type CandidateTimeline$candidateReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateReview
     */
    select?: CandidateReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateReviewInclude<ExtArgs> | null
    where?: CandidateReviewWhereInput
  }


  /**
   * CandidateTimeline.user
   */
  export type CandidateTimeline$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * CandidateTimeline without action
   */
  export type CandidateTimelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateTimeline
     */
    select?: CandidateTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateTimelineInclude<ExtArgs> | null
  }



  /**
   * Model FormResponse
   */

  export type AggregateFormResponse = {
    _count: FormResponseCountAggregateOutputType | null
    _min: FormResponseMinAggregateOutputType | null
    _max: FormResponseMaxAggregateOutputType | null
  }

  export type FormResponseMinAggregateOutputType = {
    id: string | null
    candidateApplicationId: string | null
    jobApplicationId: string | null
    label: string | null
    value: string | null
    createdAt: Date | null
  }

  export type FormResponseMaxAggregateOutputType = {
    id: string | null
    candidateApplicationId: string | null
    jobApplicationId: string | null
    label: string | null
    value: string | null
    createdAt: Date | null
  }

  export type FormResponseCountAggregateOutputType = {
    id: number
    candidateApplicationId: number
    jobApplicationId: number
    label: number
    value: number
    createdAt: number
    _all: number
  }


  export type FormResponseMinAggregateInputType = {
    id?: true
    candidateApplicationId?: true
    jobApplicationId?: true
    label?: true
    value?: true
    createdAt?: true
  }

  export type FormResponseMaxAggregateInputType = {
    id?: true
    candidateApplicationId?: true
    jobApplicationId?: true
    label?: true
    value?: true
    createdAt?: true
  }

  export type FormResponseCountAggregateInputType = {
    id?: true
    candidateApplicationId?: true
    jobApplicationId?: true
    label?: true
    value?: true
    createdAt?: true
    _all?: true
  }

  export type FormResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormResponse to aggregate.
     */
    where?: FormResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormResponses to fetch.
     */
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormResponses
    **/
    _count?: true | FormResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormResponseMaxAggregateInputType
  }

  export type GetFormResponseAggregateType<T extends FormResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateFormResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormResponse[P]>
      : GetScalarType<T[P], AggregateFormResponse[P]>
  }




  export type FormResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormResponseWhereInput
    orderBy?: FormResponseOrderByWithAggregationInput | FormResponseOrderByWithAggregationInput[]
    by: FormResponseScalarFieldEnum[] | FormResponseScalarFieldEnum
    having?: FormResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormResponseCountAggregateInputType | true
    _min?: FormResponseMinAggregateInputType
    _max?: FormResponseMaxAggregateInputType
  }

  export type FormResponseGroupByOutputType = {
    id: string
    candidateApplicationId: string
    jobApplicationId: string
    label: string
    value: string | null
    createdAt: Date
    _count: FormResponseCountAggregateOutputType | null
    _min: FormResponseMinAggregateOutputType | null
    _max: FormResponseMaxAggregateOutputType | null
  }

  type GetFormResponseGroupByPayload<T extends FormResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormResponseGroupByOutputType[P]>
            : GetScalarType<T[P], FormResponseGroupByOutputType[P]>
        }
      >
    >


  export type FormResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    candidateApplicationId?: boolean
    jobApplicationId?: boolean
    label?: boolean
    value?: boolean
    createdAt?: boolean
    candidateApplication?: boolean | CandidateApplicationDefaultArgs<ExtArgs>
    jobApplication?: boolean | JobApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formResponse"]>

  export type FormResponseSelectScalar = {
    id?: boolean
    candidateApplicationId?: boolean
    jobApplicationId?: boolean
    label?: boolean
    value?: boolean
    createdAt?: boolean
  }

  export type FormResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidateApplication?: boolean | CandidateApplicationDefaultArgs<ExtArgs>
    jobApplication?: boolean | JobApplicationDefaultArgs<ExtArgs>
  }


  export type $FormResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormResponse"
    objects: {
      candidateApplication: Prisma.$CandidateApplicationPayload<ExtArgs>
      jobApplication: Prisma.$JobApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      candidateApplicationId: string
      jobApplicationId: string
      label: string
      value: string | null
      createdAt: Date
    }, ExtArgs["result"]["formResponse"]>
    composites: {}
  }


  type FormResponseGetPayload<S extends boolean | null | undefined | FormResponseDefaultArgs> = $Result.GetResult<Prisma.$FormResponsePayload, S>

  type FormResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FormResponseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormResponseCountAggregateInputType | true
    }

  export interface FormResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormResponse'], meta: { name: 'FormResponse' } }
    /**
     * Find zero or one FormResponse that matches the filter.
     * @param {FormResponseFindUniqueArgs} args - Arguments to find a FormResponse
     * @example
     * // Get one FormResponse
     * const formResponse = await prisma.formResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FormResponseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FormResponseFindUniqueArgs<ExtArgs>>
    ): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FormResponse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FormResponseFindUniqueOrThrowArgs} args - Arguments to find a FormResponse
     * @example
     * // Get one FormResponse
     * const formResponse = await prisma.formResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FormResponseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormResponseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FormResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseFindFirstArgs} args - Arguments to find a FormResponse
     * @example
     * // Get one FormResponse
     * const formResponse = await prisma.formResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FormResponseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FormResponseFindFirstArgs<ExtArgs>>
    ): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FormResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseFindFirstOrThrowArgs} args - Arguments to find a FormResponse
     * @example
     * // Get one FormResponse
     * const formResponse = await prisma.formResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FormResponseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormResponseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FormResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormResponses
     * const formResponses = await prisma.formResponse.findMany()
     * 
     * // Get first 10 FormResponses
     * const formResponses = await prisma.formResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formResponseWithIdOnly = await prisma.formResponse.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FormResponseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormResponseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FormResponse.
     * @param {FormResponseCreateArgs} args - Arguments to create a FormResponse.
     * @example
     * // Create one FormResponse
     * const FormResponse = await prisma.formResponse.create({
     *   data: {
     *     // ... data to create a FormResponse
     *   }
     * })
     * 
    **/
    create<T extends FormResponseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FormResponseCreateArgs<ExtArgs>>
    ): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FormResponses.
     *     @param {FormResponseCreateManyArgs} args - Arguments to create many FormResponses.
     *     @example
     *     // Create many FormResponses
     *     const formResponse = await prisma.formResponse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FormResponseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormResponseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FormResponse.
     * @param {FormResponseDeleteArgs} args - Arguments to delete one FormResponse.
     * @example
     * // Delete one FormResponse
     * const FormResponse = await prisma.formResponse.delete({
     *   where: {
     *     // ... filter to delete one FormResponse
     *   }
     * })
     * 
    **/
    delete<T extends FormResponseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FormResponseDeleteArgs<ExtArgs>>
    ): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FormResponse.
     * @param {FormResponseUpdateArgs} args - Arguments to update one FormResponse.
     * @example
     * // Update one FormResponse
     * const formResponse = await prisma.formResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FormResponseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FormResponseUpdateArgs<ExtArgs>>
    ): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FormResponses.
     * @param {FormResponseDeleteManyArgs} args - Arguments to filter FormResponses to delete.
     * @example
     * // Delete a few FormResponses
     * const { count } = await prisma.formResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FormResponseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormResponseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormResponses
     * const formResponse = await prisma.formResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FormResponseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FormResponseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FormResponse.
     * @param {FormResponseUpsertArgs} args - Arguments to update or create a FormResponse.
     * @example
     * // Update or create a FormResponse
     * const formResponse = await prisma.formResponse.upsert({
     *   create: {
     *     // ... data to create a FormResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormResponse we want to update
     *   }
     * })
    **/
    upsert<T extends FormResponseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FormResponseUpsertArgs<ExtArgs>>
    ): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FormResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseCountArgs} args - Arguments to filter FormResponses to count.
     * @example
     * // Count the number of FormResponses
     * const count = await prisma.formResponse.count({
     *   where: {
     *     // ... the filter for the FormResponses we want to count
     *   }
     * })
    **/
    count<T extends FormResponseCountArgs>(
      args?: Subset<T, FormResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormResponseAggregateArgs>(args: Subset<T, FormResponseAggregateArgs>): Prisma.PrismaPromise<GetFormResponseAggregateType<T>>

    /**
     * Group by FormResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormResponseGroupByArgs['orderBy'] }
        : { orderBy?: FormResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormResponse model
   */
  readonly fields: FormResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    candidateApplication<T extends CandidateApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CandidateApplicationDefaultArgs<ExtArgs>>): Prisma__CandidateApplicationClient<$Result.GetResult<Prisma.$CandidateApplicationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    jobApplication<T extends JobApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobApplicationDefaultArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FormResponse model
   */ 
  interface FormResponseFieldRefs {
    readonly id: FieldRef<"FormResponse", 'String'>
    readonly candidateApplicationId: FieldRef<"FormResponse", 'String'>
    readonly jobApplicationId: FieldRef<"FormResponse", 'String'>
    readonly label: FieldRef<"FormResponse", 'String'>
    readonly value: FieldRef<"FormResponse", 'String'>
    readonly createdAt: FieldRef<"FormResponse", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * FormResponse findUnique
   */
  export type FormResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter, which FormResponse to fetch.
     */
    where: FormResponseWhereUniqueInput
  }


  /**
   * FormResponse findUniqueOrThrow
   */
  export type FormResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter, which FormResponse to fetch.
     */
    where: FormResponseWhereUniqueInput
  }


  /**
   * FormResponse findFirst
   */
  export type FormResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter, which FormResponse to fetch.
     */
    where?: FormResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormResponses to fetch.
     */
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormResponses.
     */
    cursor?: FormResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormResponses.
     */
    distinct?: FormResponseScalarFieldEnum | FormResponseScalarFieldEnum[]
  }


  /**
   * FormResponse findFirstOrThrow
   */
  export type FormResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter, which FormResponse to fetch.
     */
    where?: FormResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormResponses to fetch.
     */
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormResponses.
     */
    cursor?: FormResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormResponses.
     */
    distinct?: FormResponseScalarFieldEnum | FormResponseScalarFieldEnum[]
  }


  /**
   * FormResponse findMany
   */
  export type FormResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter, which FormResponses to fetch.
     */
    where?: FormResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormResponses to fetch.
     */
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormResponses.
     */
    cursor?: FormResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormResponses.
     */
    skip?: number
    distinct?: FormResponseScalarFieldEnum | FormResponseScalarFieldEnum[]
  }


  /**
   * FormResponse create
   */
  export type FormResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a FormResponse.
     */
    data: XOR<FormResponseCreateInput, FormResponseUncheckedCreateInput>
  }


  /**
   * FormResponse createMany
   */
  export type FormResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormResponses.
     */
    data: FormResponseCreateManyInput | FormResponseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * FormResponse update
   */
  export type FormResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a FormResponse.
     */
    data: XOR<FormResponseUpdateInput, FormResponseUncheckedUpdateInput>
    /**
     * Choose, which FormResponse to update.
     */
    where: FormResponseWhereUniqueInput
  }


  /**
   * FormResponse updateMany
   */
  export type FormResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormResponses.
     */
    data: XOR<FormResponseUpdateManyMutationInput, FormResponseUncheckedUpdateManyInput>
    /**
     * Filter which FormResponses to update
     */
    where?: FormResponseWhereInput
  }


  /**
   * FormResponse upsert
   */
  export type FormResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the FormResponse to update in case it exists.
     */
    where: FormResponseWhereUniqueInput
    /**
     * In case the FormResponse found by the `where` argument doesn't exist, create a new FormResponse with this data.
     */
    create: XOR<FormResponseCreateInput, FormResponseUncheckedCreateInput>
    /**
     * In case the FormResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormResponseUpdateInput, FormResponseUncheckedUpdateInput>
  }


  /**
   * FormResponse delete
   */
  export type FormResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter which FormResponse to delete.
     */
    where: FormResponseWhereUniqueInput
  }


  /**
   * FormResponse deleteMany
   */
  export type FormResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormResponses to delete
     */
    where?: FormResponseWhereInput
  }


  /**
   * FormResponse without action
   */
  export type FormResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormResponseInclude<ExtArgs> | null
  }



  /**
   * Model JobPreview
   */

  export type AggregateJobPreview = {
    _count: JobPreviewCountAggregateOutputType | null
    _min: JobPreviewMinAggregateOutputType | null
    _max: JobPreviewMaxAggregateOutputType | null
  }

  export type JobPreviewMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    expiresAt: Date | null
    isExpired: boolean | null
    organizationId: string | null
    jobId: string | null
  }

  export type JobPreviewMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    expiresAt: Date | null
    isExpired: boolean | null
    organizationId: string | null
    jobId: string | null
  }

  export type JobPreviewCountAggregateOutputType = {
    id: number
    createdAt: number
    expiresAt: number
    isExpired: number
    organizationId: number
    jobId: number
    _all: number
  }


  export type JobPreviewMinAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    isExpired?: true
    organizationId?: true
    jobId?: true
  }

  export type JobPreviewMaxAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    isExpired?: true
    organizationId?: true
    jobId?: true
  }

  export type JobPreviewCountAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    isExpired?: true
    organizationId?: true
    jobId?: true
    _all?: true
  }

  export type JobPreviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPreview to aggregate.
     */
    where?: JobPreviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPreviews to fetch.
     */
    orderBy?: JobPreviewOrderByWithRelationInput | JobPreviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobPreviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPreviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPreviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobPreviews
    **/
    _count?: true | JobPreviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobPreviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobPreviewMaxAggregateInputType
  }

  export type GetJobPreviewAggregateType<T extends JobPreviewAggregateArgs> = {
        [P in keyof T & keyof AggregateJobPreview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobPreview[P]>
      : GetScalarType<T[P], AggregateJobPreview[P]>
  }




  export type JobPreviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPreviewWhereInput
    orderBy?: JobPreviewOrderByWithAggregationInput | JobPreviewOrderByWithAggregationInput[]
    by: JobPreviewScalarFieldEnum[] | JobPreviewScalarFieldEnum
    having?: JobPreviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobPreviewCountAggregateInputType | true
    _min?: JobPreviewMinAggregateInputType
    _max?: JobPreviewMaxAggregateInputType
  }

  export type JobPreviewGroupByOutputType = {
    id: string
    createdAt: Date
    expiresAt: Date
    isExpired: boolean
    organizationId: string | null
    jobId: string
    _count: JobPreviewCountAggregateOutputType | null
    _min: JobPreviewMinAggregateOutputType | null
    _max: JobPreviewMaxAggregateOutputType | null
  }

  type GetJobPreviewGroupByPayload<T extends JobPreviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobPreviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobPreviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobPreviewGroupByOutputType[P]>
            : GetScalarType<T[P], JobPreviewGroupByOutputType[P]>
        }
      >
    >


  export type JobPreviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    isExpired?: boolean
    organizationId?: boolean
    jobId?: boolean
    organization?: boolean | JobPreview$organizationArgs<ExtArgs>
    jobPost?: boolean | JobPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPreview"]>

  export type JobPreviewSelectScalar = {
    id?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    isExpired?: boolean
    organizationId?: boolean
    jobId?: boolean
  }

  export type JobPreviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | JobPreview$organizationArgs<ExtArgs>
    jobPost?: boolean | JobPostDefaultArgs<ExtArgs>
  }


  export type $JobPreviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobPreview"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      jobPost: Prisma.$JobPostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      expiresAt: Date
      isExpired: boolean
      organizationId: string | null
      jobId: string
    }, ExtArgs["result"]["jobPreview"]>
    composites: {}
  }


  type JobPreviewGetPayload<S extends boolean | null | undefined | JobPreviewDefaultArgs> = $Result.GetResult<Prisma.$JobPreviewPayload, S>

  type JobPreviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobPreviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobPreviewCountAggregateInputType | true
    }

  export interface JobPreviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobPreview'], meta: { name: 'JobPreview' } }
    /**
     * Find zero or one JobPreview that matches the filter.
     * @param {JobPreviewFindUniqueArgs} args - Arguments to find a JobPreview
     * @example
     * // Get one JobPreview
     * const jobPreview = await prisma.jobPreview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobPreviewFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, JobPreviewFindUniqueArgs<ExtArgs>>
    ): Prisma__JobPreviewClient<$Result.GetResult<Prisma.$JobPreviewPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one JobPreview that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JobPreviewFindUniqueOrThrowArgs} args - Arguments to find a JobPreview
     * @example
     * // Get one JobPreview
     * const jobPreview = await prisma.jobPreview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JobPreviewFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobPreviewFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JobPreviewClient<$Result.GetResult<Prisma.$JobPreviewPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first JobPreview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPreviewFindFirstArgs} args - Arguments to find a JobPreview
     * @example
     * // Get one JobPreview
     * const jobPreview = await prisma.jobPreview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobPreviewFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, JobPreviewFindFirstArgs<ExtArgs>>
    ): Prisma__JobPreviewClient<$Result.GetResult<Prisma.$JobPreviewPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first JobPreview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPreviewFindFirstOrThrowArgs} args - Arguments to find a JobPreview
     * @example
     * // Get one JobPreview
     * const jobPreview = await prisma.jobPreview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JobPreviewFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobPreviewFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JobPreviewClient<$Result.GetResult<Prisma.$JobPreviewPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more JobPreviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPreviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobPreviews
     * const jobPreviews = await prisma.jobPreview.findMany()
     * 
     * // Get first 10 JobPreviews
     * const jobPreviews = await prisma.jobPreview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobPreviewWithIdOnly = await prisma.jobPreview.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends JobPreviewFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobPreviewFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPreviewPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a JobPreview.
     * @param {JobPreviewCreateArgs} args - Arguments to create a JobPreview.
     * @example
     * // Create one JobPreview
     * const JobPreview = await prisma.jobPreview.create({
     *   data: {
     *     // ... data to create a JobPreview
     *   }
     * })
     * 
    **/
    create<T extends JobPreviewCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JobPreviewCreateArgs<ExtArgs>>
    ): Prisma__JobPreviewClient<$Result.GetResult<Prisma.$JobPreviewPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many JobPreviews.
     *     @param {JobPreviewCreateManyArgs} args - Arguments to create many JobPreviews.
     *     @example
     *     // Create many JobPreviews
     *     const jobPreview = await prisma.jobPreview.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobPreviewCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobPreviewCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JobPreview.
     * @param {JobPreviewDeleteArgs} args - Arguments to delete one JobPreview.
     * @example
     * // Delete one JobPreview
     * const JobPreview = await prisma.jobPreview.delete({
     *   where: {
     *     // ... filter to delete one JobPreview
     *   }
     * })
     * 
    **/
    delete<T extends JobPreviewDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JobPreviewDeleteArgs<ExtArgs>>
    ): Prisma__JobPreviewClient<$Result.GetResult<Prisma.$JobPreviewPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one JobPreview.
     * @param {JobPreviewUpdateArgs} args - Arguments to update one JobPreview.
     * @example
     * // Update one JobPreview
     * const jobPreview = await prisma.jobPreview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobPreviewUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JobPreviewUpdateArgs<ExtArgs>>
    ): Prisma__JobPreviewClient<$Result.GetResult<Prisma.$JobPreviewPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more JobPreviews.
     * @param {JobPreviewDeleteManyArgs} args - Arguments to filter JobPreviews to delete.
     * @example
     * // Delete a few JobPreviews
     * const { count } = await prisma.jobPreview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobPreviewDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobPreviewDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPreviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPreviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobPreviews
     * const jobPreview = await prisma.jobPreview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobPreviewUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JobPreviewUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobPreview.
     * @param {JobPreviewUpsertArgs} args - Arguments to update or create a JobPreview.
     * @example
     * // Update or create a JobPreview
     * const jobPreview = await prisma.jobPreview.upsert({
     *   create: {
     *     // ... data to create a JobPreview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobPreview we want to update
     *   }
     * })
    **/
    upsert<T extends JobPreviewUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JobPreviewUpsertArgs<ExtArgs>>
    ): Prisma__JobPreviewClient<$Result.GetResult<Prisma.$JobPreviewPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of JobPreviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPreviewCountArgs} args - Arguments to filter JobPreviews to count.
     * @example
     * // Count the number of JobPreviews
     * const count = await prisma.jobPreview.count({
     *   where: {
     *     // ... the filter for the JobPreviews we want to count
     *   }
     * })
    **/
    count<T extends JobPreviewCountArgs>(
      args?: Subset<T, JobPreviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobPreviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobPreview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPreviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobPreviewAggregateArgs>(args: Subset<T, JobPreviewAggregateArgs>): Prisma.PrismaPromise<GetJobPreviewAggregateType<T>>

    /**
     * Group by JobPreview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPreviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobPreviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobPreviewGroupByArgs['orderBy'] }
        : { orderBy?: JobPreviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobPreviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobPreviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobPreview model
   */
  readonly fields: JobPreviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobPreview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobPreviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    organization<T extends JobPreview$organizationArgs<ExtArgs> = {}>(args?: Subset<T, JobPreview$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    jobPost<T extends JobPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostDefaultArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the JobPreview model
   */ 
  interface JobPreviewFieldRefs {
    readonly id: FieldRef<"JobPreview", 'String'>
    readonly createdAt: FieldRef<"JobPreview", 'DateTime'>
    readonly expiresAt: FieldRef<"JobPreview", 'DateTime'>
    readonly isExpired: FieldRef<"JobPreview", 'Boolean'>
    readonly organizationId: FieldRef<"JobPreview", 'String'>
    readonly jobId: FieldRef<"JobPreview", 'String'>
  }
    

  // Custom InputTypes

  /**
   * JobPreview findUnique
   */
  export type JobPreviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPreview
     */
    select?: JobPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPreviewInclude<ExtArgs> | null
    /**
     * Filter, which JobPreview to fetch.
     */
    where: JobPreviewWhereUniqueInput
  }


  /**
   * JobPreview findUniqueOrThrow
   */
  export type JobPreviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPreview
     */
    select?: JobPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPreviewInclude<ExtArgs> | null
    /**
     * Filter, which JobPreview to fetch.
     */
    where: JobPreviewWhereUniqueInput
  }


  /**
   * JobPreview findFirst
   */
  export type JobPreviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPreview
     */
    select?: JobPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPreviewInclude<ExtArgs> | null
    /**
     * Filter, which JobPreview to fetch.
     */
    where?: JobPreviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPreviews to fetch.
     */
    orderBy?: JobPreviewOrderByWithRelationInput | JobPreviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPreviews.
     */
    cursor?: JobPreviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPreviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPreviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPreviews.
     */
    distinct?: JobPreviewScalarFieldEnum | JobPreviewScalarFieldEnum[]
  }


  /**
   * JobPreview findFirstOrThrow
   */
  export type JobPreviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPreview
     */
    select?: JobPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPreviewInclude<ExtArgs> | null
    /**
     * Filter, which JobPreview to fetch.
     */
    where?: JobPreviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPreviews to fetch.
     */
    orderBy?: JobPreviewOrderByWithRelationInput | JobPreviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPreviews.
     */
    cursor?: JobPreviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPreviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPreviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPreviews.
     */
    distinct?: JobPreviewScalarFieldEnum | JobPreviewScalarFieldEnum[]
  }


  /**
   * JobPreview findMany
   */
  export type JobPreviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPreview
     */
    select?: JobPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPreviewInclude<ExtArgs> | null
    /**
     * Filter, which JobPreviews to fetch.
     */
    where?: JobPreviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPreviews to fetch.
     */
    orderBy?: JobPreviewOrderByWithRelationInput | JobPreviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobPreviews.
     */
    cursor?: JobPreviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPreviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPreviews.
     */
    skip?: number
    distinct?: JobPreviewScalarFieldEnum | JobPreviewScalarFieldEnum[]
  }


  /**
   * JobPreview create
   */
  export type JobPreviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPreview
     */
    select?: JobPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPreviewInclude<ExtArgs> | null
    /**
     * The data needed to create a JobPreview.
     */
    data: XOR<JobPreviewCreateInput, JobPreviewUncheckedCreateInput>
  }


  /**
   * JobPreview createMany
   */
  export type JobPreviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobPreviews.
     */
    data: JobPreviewCreateManyInput | JobPreviewCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * JobPreview update
   */
  export type JobPreviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPreview
     */
    select?: JobPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPreviewInclude<ExtArgs> | null
    /**
     * The data needed to update a JobPreview.
     */
    data: XOR<JobPreviewUpdateInput, JobPreviewUncheckedUpdateInput>
    /**
     * Choose, which JobPreview to update.
     */
    where: JobPreviewWhereUniqueInput
  }


  /**
   * JobPreview updateMany
   */
  export type JobPreviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobPreviews.
     */
    data: XOR<JobPreviewUpdateManyMutationInput, JobPreviewUncheckedUpdateManyInput>
    /**
     * Filter which JobPreviews to update
     */
    where?: JobPreviewWhereInput
  }


  /**
   * JobPreview upsert
   */
  export type JobPreviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPreview
     */
    select?: JobPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPreviewInclude<ExtArgs> | null
    /**
     * The filter to search for the JobPreview to update in case it exists.
     */
    where: JobPreviewWhereUniqueInput
    /**
     * In case the JobPreview found by the `where` argument doesn't exist, create a new JobPreview with this data.
     */
    create: XOR<JobPreviewCreateInput, JobPreviewUncheckedCreateInput>
    /**
     * In case the JobPreview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobPreviewUpdateInput, JobPreviewUncheckedUpdateInput>
  }


  /**
   * JobPreview delete
   */
  export type JobPreviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPreview
     */
    select?: JobPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPreviewInclude<ExtArgs> | null
    /**
     * Filter which JobPreview to delete.
     */
    where: JobPreviewWhereUniqueInput
  }


  /**
   * JobPreview deleteMany
   */
  export type JobPreviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPreviews to delete
     */
    where?: JobPreviewWhereInput
  }


  /**
   * JobPreview.organization
   */
  export type JobPreview$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }


  /**
   * JobPreview without action
   */
  export type JobPreviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPreview
     */
    select?: JobPreviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobPreviewInclude<ExtArgs> | null
  }



  /**
   * Model JobStage
   */

  export type AggregateJobStage = {
    _count: JobStageCountAggregateOutputType | null
    _avg: JobStageAvgAggregateOutputType | null
    _sum: JobStageSumAggregateOutputType | null
    _min: JobStageMinAggregateOutputType | null
    _max: JobStageMaxAggregateOutputType | null
  }

  export type JobStageAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type JobStageSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type JobStageMinAggregateOutputType = {
    id: string | null
    name: string | null
    isDeletable: boolean | null
    isDeleted: boolean | null
    displayOrder: number | null
    jobId: string | null
    createdAt: Date | null
  }

  export type JobStageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    isDeletable: boolean | null
    isDeleted: boolean | null
    displayOrder: number | null
    jobId: string | null
    createdAt: Date | null
  }

  export type JobStageCountAggregateOutputType = {
    id: number
    name: number
    isDeletable: number
    isDeleted: number
    displayOrder: number
    jobId: number
    createdAt: number
    _all: number
  }


  export type JobStageAvgAggregateInputType = {
    displayOrder?: true
  }

  export type JobStageSumAggregateInputType = {
    displayOrder?: true
  }

  export type JobStageMinAggregateInputType = {
    id?: true
    name?: true
    isDeletable?: true
    isDeleted?: true
    displayOrder?: true
    jobId?: true
    createdAt?: true
  }

  export type JobStageMaxAggregateInputType = {
    id?: true
    name?: true
    isDeletable?: true
    isDeleted?: true
    displayOrder?: true
    jobId?: true
    createdAt?: true
  }

  export type JobStageCountAggregateInputType = {
    id?: true
    name?: true
    isDeletable?: true
    isDeleted?: true
    displayOrder?: true
    jobId?: true
    createdAt?: true
    _all?: true
  }

  export type JobStageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobStage to aggregate.
     */
    where?: JobStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobStages to fetch.
     */
    orderBy?: JobStageOrderByWithRelationInput | JobStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobStages
    **/
    _count?: true | JobStageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobStageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobStageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobStageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobStageMaxAggregateInputType
  }

  export type GetJobStageAggregateType<T extends JobStageAggregateArgs> = {
        [P in keyof T & keyof AggregateJobStage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobStage[P]>
      : GetScalarType<T[P], AggregateJobStage[P]>
  }




  export type JobStageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobStageWhereInput
    orderBy?: JobStageOrderByWithAggregationInput | JobStageOrderByWithAggregationInput[]
    by: JobStageScalarFieldEnum[] | JobStageScalarFieldEnum
    having?: JobStageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobStageCountAggregateInputType | true
    _avg?: JobStageAvgAggregateInputType
    _sum?: JobStageSumAggregateInputType
    _min?: JobStageMinAggregateInputType
    _max?: JobStageMaxAggregateInputType
  }

  export type JobStageGroupByOutputType = {
    id: string
    name: string
    isDeletable: boolean
    isDeleted: boolean
    displayOrder: number
    jobId: string
    createdAt: Date
    _count: JobStageCountAggregateOutputType | null
    _avg: JobStageAvgAggregateOutputType | null
    _sum: JobStageSumAggregateOutputType | null
    _min: JobStageMinAggregateOutputType | null
    _max: JobStageMaxAggregateOutputType | null
  }

  type GetJobStageGroupByPayload<T extends JobStageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobStageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobStageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobStageGroupByOutputType[P]>
            : GetScalarType<T[P], JobStageGroupByOutputType[P]>
        }
      >
    >


  export type JobStageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isDeletable?: boolean
    isDeleted?: boolean
    displayOrder?: boolean
    jobId?: boolean
    createdAt?: boolean
    jobPost?: boolean | JobPostDefaultArgs<ExtArgs>
    candidateStage?: boolean | JobStage$candidateStageArgs<ExtArgs>
    _count?: boolean | JobStageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobStage"]>

  export type JobStageSelectScalar = {
    id?: boolean
    name?: boolean
    isDeletable?: boolean
    isDeleted?: boolean
    displayOrder?: boolean
    jobId?: boolean
    createdAt?: boolean
  }

  export type JobStageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPost?: boolean | JobPostDefaultArgs<ExtArgs>
    candidateStage?: boolean | JobStage$candidateStageArgs<ExtArgs>
    _count?: boolean | JobStageCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $JobStagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobStage"
    objects: {
      jobPost: Prisma.$JobPostPayload<ExtArgs>
      candidateStage: Prisma.$CandidateApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      isDeletable: boolean
      isDeleted: boolean
      displayOrder: number
      jobId: string
      createdAt: Date
    }, ExtArgs["result"]["jobStage"]>
    composites: {}
  }


  type JobStageGetPayload<S extends boolean | null | undefined | JobStageDefaultArgs> = $Result.GetResult<Prisma.$JobStagePayload, S>

  type JobStageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobStageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobStageCountAggregateInputType | true
    }

  export interface JobStageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobStage'], meta: { name: 'JobStage' } }
    /**
     * Find zero or one JobStage that matches the filter.
     * @param {JobStageFindUniqueArgs} args - Arguments to find a JobStage
     * @example
     * // Get one JobStage
     * const jobStage = await prisma.jobStage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobStageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, JobStageFindUniqueArgs<ExtArgs>>
    ): Prisma__JobStageClient<$Result.GetResult<Prisma.$JobStagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one JobStage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JobStageFindUniqueOrThrowArgs} args - Arguments to find a JobStage
     * @example
     * // Get one JobStage
     * const jobStage = await prisma.jobStage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JobStageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobStageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JobStageClient<$Result.GetResult<Prisma.$JobStagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first JobStage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobStageFindFirstArgs} args - Arguments to find a JobStage
     * @example
     * // Get one JobStage
     * const jobStage = await prisma.jobStage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobStageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, JobStageFindFirstArgs<ExtArgs>>
    ): Prisma__JobStageClient<$Result.GetResult<Prisma.$JobStagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first JobStage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobStageFindFirstOrThrowArgs} args - Arguments to find a JobStage
     * @example
     * // Get one JobStage
     * const jobStage = await prisma.jobStage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JobStageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobStageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JobStageClient<$Result.GetResult<Prisma.$JobStagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more JobStages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobStageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobStages
     * const jobStages = await prisma.jobStage.findMany()
     * 
     * // Get first 10 JobStages
     * const jobStages = await prisma.jobStage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobStageWithIdOnly = await prisma.jobStage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends JobStageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobStageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobStagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a JobStage.
     * @param {JobStageCreateArgs} args - Arguments to create a JobStage.
     * @example
     * // Create one JobStage
     * const JobStage = await prisma.jobStage.create({
     *   data: {
     *     // ... data to create a JobStage
     *   }
     * })
     * 
    **/
    create<T extends JobStageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JobStageCreateArgs<ExtArgs>>
    ): Prisma__JobStageClient<$Result.GetResult<Prisma.$JobStagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many JobStages.
     *     @param {JobStageCreateManyArgs} args - Arguments to create many JobStages.
     *     @example
     *     // Create many JobStages
     *     const jobStage = await prisma.jobStage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobStageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobStageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JobStage.
     * @param {JobStageDeleteArgs} args - Arguments to delete one JobStage.
     * @example
     * // Delete one JobStage
     * const JobStage = await prisma.jobStage.delete({
     *   where: {
     *     // ... filter to delete one JobStage
     *   }
     * })
     * 
    **/
    delete<T extends JobStageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JobStageDeleteArgs<ExtArgs>>
    ): Prisma__JobStageClient<$Result.GetResult<Prisma.$JobStagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one JobStage.
     * @param {JobStageUpdateArgs} args - Arguments to update one JobStage.
     * @example
     * // Update one JobStage
     * const jobStage = await prisma.jobStage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobStageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JobStageUpdateArgs<ExtArgs>>
    ): Prisma__JobStageClient<$Result.GetResult<Prisma.$JobStagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more JobStages.
     * @param {JobStageDeleteManyArgs} args - Arguments to filter JobStages to delete.
     * @example
     * // Delete a few JobStages
     * const { count } = await prisma.jobStage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobStageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobStageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobStageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobStages
     * const jobStage = await prisma.jobStage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobStageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JobStageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobStage.
     * @param {JobStageUpsertArgs} args - Arguments to update or create a JobStage.
     * @example
     * // Update or create a JobStage
     * const jobStage = await prisma.jobStage.upsert({
     *   create: {
     *     // ... data to create a JobStage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobStage we want to update
     *   }
     * })
    **/
    upsert<T extends JobStageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JobStageUpsertArgs<ExtArgs>>
    ): Prisma__JobStageClient<$Result.GetResult<Prisma.$JobStagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of JobStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobStageCountArgs} args - Arguments to filter JobStages to count.
     * @example
     * // Count the number of JobStages
     * const count = await prisma.jobStage.count({
     *   where: {
     *     // ... the filter for the JobStages we want to count
     *   }
     * })
    **/
    count<T extends JobStageCountArgs>(
      args?: Subset<T, JobStageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobStageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobStageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobStageAggregateArgs>(args: Subset<T, JobStageAggregateArgs>): Prisma.PrismaPromise<GetJobStageAggregateType<T>>

    /**
     * Group by JobStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobStageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobStageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobStageGroupByArgs['orderBy'] }
        : { orderBy?: JobStageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobStageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobStageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobStage model
   */
  readonly fields: JobStageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobStage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobStageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    jobPost<T extends JobPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostDefaultArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    candidateStage<T extends JobStage$candidateStageArgs<ExtArgs> = {}>(args?: Subset<T, JobStage$candidateStageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidateApplicationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the JobStage model
   */ 
  interface JobStageFieldRefs {
    readonly id: FieldRef<"JobStage", 'String'>
    readonly name: FieldRef<"JobStage", 'String'>
    readonly isDeletable: FieldRef<"JobStage", 'Boolean'>
    readonly isDeleted: FieldRef<"JobStage", 'Boolean'>
    readonly displayOrder: FieldRef<"JobStage", 'Int'>
    readonly jobId: FieldRef<"JobStage", 'String'>
    readonly createdAt: FieldRef<"JobStage", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * JobStage findUnique
   */
  export type JobStageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStage
     */
    select?: JobStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobStageInclude<ExtArgs> | null
    /**
     * Filter, which JobStage to fetch.
     */
    where: JobStageWhereUniqueInput
  }


  /**
   * JobStage findUniqueOrThrow
   */
  export type JobStageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStage
     */
    select?: JobStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobStageInclude<ExtArgs> | null
    /**
     * Filter, which JobStage to fetch.
     */
    where: JobStageWhereUniqueInput
  }


  /**
   * JobStage findFirst
   */
  export type JobStageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStage
     */
    select?: JobStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobStageInclude<ExtArgs> | null
    /**
     * Filter, which JobStage to fetch.
     */
    where?: JobStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobStages to fetch.
     */
    orderBy?: JobStageOrderByWithRelationInput | JobStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobStages.
     */
    cursor?: JobStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobStages.
     */
    distinct?: JobStageScalarFieldEnum | JobStageScalarFieldEnum[]
  }


  /**
   * JobStage findFirstOrThrow
   */
  export type JobStageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStage
     */
    select?: JobStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobStageInclude<ExtArgs> | null
    /**
     * Filter, which JobStage to fetch.
     */
    where?: JobStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobStages to fetch.
     */
    orderBy?: JobStageOrderByWithRelationInput | JobStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobStages.
     */
    cursor?: JobStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobStages.
     */
    distinct?: JobStageScalarFieldEnum | JobStageScalarFieldEnum[]
  }


  /**
   * JobStage findMany
   */
  export type JobStageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStage
     */
    select?: JobStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobStageInclude<ExtArgs> | null
    /**
     * Filter, which JobStages to fetch.
     */
    where?: JobStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobStages to fetch.
     */
    orderBy?: JobStageOrderByWithRelationInput | JobStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobStages.
     */
    cursor?: JobStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobStages.
     */
    skip?: number
    distinct?: JobStageScalarFieldEnum | JobStageScalarFieldEnum[]
  }


  /**
   * JobStage create
   */
  export type JobStageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStage
     */
    select?: JobStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobStageInclude<ExtArgs> | null
    /**
     * The data needed to create a JobStage.
     */
    data: XOR<JobStageCreateInput, JobStageUncheckedCreateInput>
  }


  /**
   * JobStage createMany
   */
  export type JobStageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobStages.
     */
    data: JobStageCreateManyInput | JobStageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * JobStage update
   */
  export type JobStageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStage
     */
    select?: JobStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobStageInclude<ExtArgs> | null
    /**
     * The data needed to update a JobStage.
     */
    data: XOR<JobStageUpdateInput, JobStageUncheckedUpdateInput>
    /**
     * Choose, which JobStage to update.
     */
    where: JobStageWhereUniqueInput
  }


  /**
   * JobStage updateMany
   */
  export type JobStageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobStages.
     */
    data: XOR<JobStageUpdateManyMutationInput, JobStageUncheckedUpdateManyInput>
    /**
     * Filter which JobStages to update
     */
    where?: JobStageWhereInput
  }


  /**
   * JobStage upsert
   */
  export type JobStageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStage
     */
    select?: JobStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobStageInclude<ExtArgs> | null
    /**
     * The filter to search for the JobStage to update in case it exists.
     */
    where: JobStageWhereUniqueInput
    /**
     * In case the JobStage found by the `where` argument doesn't exist, create a new JobStage with this data.
     */
    create: XOR<JobStageCreateInput, JobStageUncheckedCreateInput>
    /**
     * In case the JobStage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobStageUpdateInput, JobStageUncheckedUpdateInput>
  }


  /**
   * JobStage delete
   */
  export type JobStageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStage
     */
    select?: JobStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobStageInclude<ExtArgs> | null
    /**
     * Filter which JobStage to delete.
     */
    where: JobStageWhereUniqueInput
  }


  /**
   * JobStage deleteMany
   */
  export type JobStageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobStages to delete
     */
    where?: JobStageWhereInput
  }


  /**
   * JobStage.candidateStage
   */
  export type JobStage$candidateStageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateApplication
     */
    select?: CandidateApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidateApplicationInclude<ExtArgs> | null
    where?: CandidateApplicationWhereInput
    orderBy?: CandidateApplicationOrderByWithRelationInput | CandidateApplicationOrderByWithRelationInput[]
    cursor?: CandidateApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CandidateApplicationScalarFieldEnum | CandidateApplicationScalarFieldEnum[]
  }


  /**
   * JobStage without action
   */
  export type JobStageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStage
     */
    select?: JobStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobStageInclude<ExtArgs> | null
  }



  /**
   * Model JobMailingTemplate
   */

  export type AggregateJobMailingTemplate = {
    _count: JobMailingTemplateCountAggregateOutputType | null
    _min: JobMailingTemplateMinAggregateOutputType | null
    _max: JobMailingTemplateMaxAggregateOutputType | null
  }

  export type JobMailingTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    body: string | null
    createdAt: Date | null
    jobId: string | null
  }

  export type JobMailingTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    body: string | null
    createdAt: Date | null
    jobId: string | null
  }

  export type JobMailingTemplateCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    body: number
    createdAt: number
    jobId: number
    _all: number
  }


  export type JobMailingTemplateMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    createdAt?: true
    jobId?: true
  }

  export type JobMailingTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    createdAt?: true
    jobId?: true
  }

  export type JobMailingTemplateCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    createdAt?: true
    jobId?: true
    _all?: true
  }

  export type JobMailingTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobMailingTemplate to aggregate.
     */
    where?: JobMailingTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobMailingTemplates to fetch.
     */
    orderBy?: JobMailingTemplateOrderByWithRelationInput | JobMailingTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobMailingTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobMailingTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobMailingTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobMailingTemplates
    **/
    _count?: true | JobMailingTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMailingTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMailingTemplateMaxAggregateInputType
  }

  export type GetJobMailingTemplateAggregateType<T extends JobMailingTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateJobMailingTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobMailingTemplate[P]>
      : GetScalarType<T[P], AggregateJobMailingTemplate[P]>
  }




  export type JobMailingTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobMailingTemplateWhereInput
    orderBy?: JobMailingTemplateOrderByWithAggregationInput | JobMailingTemplateOrderByWithAggregationInput[]
    by: JobMailingTemplateScalarFieldEnum[] | JobMailingTemplateScalarFieldEnum
    having?: JobMailingTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobMailingTemplateCountAggregateInputType | true
    _min?: JobMailingTemplateMinAggregateInputType
    _max?: JobMailingTemplateMaxAggregateInputType
  }

  export type JobMailingTemplateGroupByOutputType = {
    id: string
    name: string
    subject: string
    body: string
    createdAt: Date
    jobId: string
    _count: JobMailingTemplateCountAggregateOutputType | null
    _min: JobMailingTemplateMinAggregateOutputType | null
    _max: JobMailingTemplateMaxAggregateOutputType | null
  }

  type GetJobMailingTemplateGroupByPayload<T extends JobMailingTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobMailingTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobMailingTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobMailingTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], JobMailingTemplateGroupByOutputType[P]>
        }
      >
    >


  export type JobMailingTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    createdAt?: boolean
    jobId?: boolean
    jobPost?: boolean | JobPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobMailingTemplate"]>

  export type JobMailingTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    createdAt?: boolean
    jobId?: boolean
  }

  export type JobMailingTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobPost?: boolean | JobPostDefaultArgs<ExtArgs>
  }


  export type $JobMailingTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobMailingTemplate"
    objects: {
      jobPost: Prisma.$JobPostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subject: string
      body: string
      createdAt: Date
      jobId: string
    }, ExtArgs["result"]["jobMailingTemplate"]>
    composites: {}
  }


  type JobMailingTemplateGetPayload<S extends boolean | null | undefined | JobMailingTemplateDefaultArgs> = $Result.GetResult<Prisma.$JobMailingTemplatePayload, S>

  type JobMailingTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobMailingTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobMailingTemplateCountAggregateInputType | true
    }

  export interface JobMailingTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobMailingTemplate'], meta: { name: 'JobMailingTemplate' } }
    /**
     * Find zero or one JobMailingTemplate that matches the filter.
     * @param {JobMailingTemplateFindUniqueArgs} args - Arguments to find a JobMailingTemplate
     * @example
     * // Get one JobMailingTemplate
     * const jobMailingTemplate = await prisma.jobMailingTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobMailingTemplateFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, JobMailingTemplateFindUniqueArgs<ExtArgs>>
    ): Prisma__JobMailingTemplateClient<$Result.GetResult<Prisma.$JobMailingTemplatePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one JobMailingTemplate that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JobMailingTemplateFindUniqueOrThrowArgs} args - Arguments to find a JobMailingTemplate
     * @example
     * // Get one JobMailingTemplate
     * const jobMailingTemplate = await prisma.jobMailingTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JobMailingTemplateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobMailingTemplateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JobMailingTemplateClient<$Result.GetResult<Prisma.$JobMailingTemplatePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first JobMailingTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobMailingTemplateFindFirstArgs} args - Arguments to find a JobMailingTemplate
     * @example
     * // Get one JobMailingTemplate
     * const jobMailingTemplate = await prisma.jobMailingTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobMailingTemplateFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, JobMailingTemplateFindFirstArgs<ExtArgs>>
    ): Prisma__JobMailingTemplateClient<$Result.GetResult<Prisma.$JobMailingTemplatePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first JobMailingTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobMailingTemplateFindFirstOrThrowArgs} args - Arguments to find a JobMailingTemplate
     * @example
     * // Get one JobMailingTemplate
     * const jobMailingTemplate = await prisma.jobMailingTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JobMailingTemplateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, JobMailingTemplateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JobMailingTemplateClient<$Result.GetResult<Prisma.$JobMailingTemplatePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more JobMailingTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobMailingTemplateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobMailingTemplates
     * const jobMailingTemplates = await prisma.jobMailingTemplate.findMany()
     * 
     * // Get first 10 JobMailingTemplates
     * const jobMailingTemplates = await prisma.jobMailingTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobMailingTemplateWithIdOnly = await prisma.jobMailingTemplate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends JobMailingTemplateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobMailingTemplateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobMailingTemplatePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a JobMailingTemplate.
     * @param {JobMailingTemplateCreateArgs} args - Arguments to create a JobMailingTemplate.
     * @example
     * // Create one JobMailingTemplate
     * const JobMailingTemplate = await prisma.jobMailingTemplate.create({
     *   data: {
     *     // ... data to create a JobMailingTemplate
     *   }
     * })
     * 
    **/
    create<T extends JobMailingTemplateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, JobMailingTemplateCreateArgs<ExtArgs>>
    ): Prisma__JobMailingTemplateClient<$Result.GetResult<Prisma.$JobMailingTemplatePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many JobMailingTemplates.
     *     @param {JobMailingTemplateCreateManyArgs} args - Arguments to create many JobMailingTemplates.
     *     @example
     *     // Create many JobMailingTemplates
     *     const jobMailingTemplate = await prisma.jobMailingTemplate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobMailingTemplateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobMailingTemplateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JobMailingTemplate.
     * @param {JobMailingTemplateDeleteArgs} args - Arguments to delete one JobMailingTemplate.
     * @example
     * // Delete one JobMailingTemplate
     * const JobMailingTemplate = await prisma.jobMailingTemplate.delete({
     *   where: {
     *     // ... filter to delete one JobMailingTemplate
     *   }
     * })
     * 
    **/
    delete<T extends JobMailingTemplateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, JobMailingTemplateDeleteArgs<ExtArgs>>
    ): Prisma__JobMailingTemplateClient<$Result.GetResult<Prisma.$JobMailingTemplatePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one JobMailingTemplate.
     * @param {JobMailingTemplateUpdateArgs} args - Arguments to update one JobMailingTemplate.
     * @example
     * // Update one JobMailingTemplate
     * const jobMailingTemplate = await prisma.jobMailingTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobMailingTemplateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, JobMailingTemplateUpdateArgs<ExtArgs>>
    ): Prisma__JobMailingTemplateClient<$Result.GetResult<Prisma.$JobMailingTemplatePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more JobMailingTemplates.
     * @param {JobMailingTemplateDeleteManyArgs} args - Arguments to filter JobMailingTemplates to delete.
     * @example
     * // Delete a few JobMailingTemplates
     * const { count } = await prisma.jobMailingTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobMailingTemplateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, JobMailingTemplateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobMailingTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobMailingTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobMailingTemplates
     * const jobMailingTemplate = await prisma.jobMailingTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobMailingTemplateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, JobMailingTemplateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobMailingTemplate.
     * @param {JobMailingTemplateUpsertArgs} args - Arguments to update or create a JobMailingTemplate.
     * @example
     * // Update or create a JobMailingTemplate
     * const jobMailingTemplate = await prisma.jobMailingTemplate.upsert({
     *   create: {
     *     // ... data to create a JobMailingTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobMailingTemplate we want to update
     *   }
     * })
    **/
    upsert<T extends JobMailingTemplateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, JobMailingTemplateUpsertArgs<ExtArgs>>
    ): Prisma__JobMailingTemplateClient<$Result.GetResult<Prisma.$JobMailingTemplatePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of JobMailingTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobMailingTemplateCountArgs} args - Arguments to filter JobMailingTemplates to count.
     * @example
     * // Count the number of JobMailingTemplates
     * const count = await prisma.jobMailingTemplate.count({
     *   where: {
     *     // ... the filter for the JobMailingTemplates we want to count
     *   }
     * })
    **/
    count<T extends JobMailingTemplateCountArgs>(
      args?: Subset<T, JobMailingTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobMailingTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobMailingTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobMailingTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobMailingTemplateAggregateArgs>(args: Subset<T, JobMailingTemplateAggregateArgs>): Prisma.PrismaPromise<GetJobMailingTemplateAggregateType<T>>

    /**
     * Group by JobMailingTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobMailingTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobMailingTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobMailingTemplateGroupByArgs['orderBy'] }
        : { orderBy?: JobMailingTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobMailingTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobMailingTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobMailingTemplate model
   */
  readonly fields: JobMailingTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobMailingTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobMailingTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    jobPost<T extends JobPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostDefaultArgs<ExtArgs>>): Prisma__JobPostClient<$Result.GetResult<Prisma.$JobPostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the JobMailingTemplate model
   */ 
  interface JobMailingTemplateFieldRefs {
    readonly id: FieldRef<"JobMailingTemplate", 'String'>
    readonly name: FieldRef<"JobMailingTemplate", 'String'>
    readonly subject: FieldRef<"JobMailingTemplate", 'String'>
    readonly body: FieldRef<"JobMailingTemplate", 'String'>
    readonly createdAt: FieldRef<"JobMailingTemplate", 'DateTime'>
    readonly jobId: FieldRef<"JobMailingTemplate", 'String'>
  }
    

  // Custom InputTypes

  /**
   * JobMailingTemplate findUnique
   */
  export type JobMailingTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobMailingTemplate
     */
    select?: JobMailingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobMailingTemplateInclude<ExtArgs> | null
    /**
     * Filter, which JobMailingTemplate to fetch.
     */
    where: JobMailingTemplateWhereUniqueInput
  }


  /**
   * JobMailingTemplate findUniqueOrThrow
   */
  export type JobMailingTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobMailingTemplate
     */
    select?: JobMailingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobMailingTemplateInclude<ExtArgs> | null
    /**
     * Filter, which JobMailingTemplate to fetch.
     */
    where: JobMailingTemplateWhereUniqueInput
  }


  /**
   * JobMailingTemplate findFirst
   */
  export type JobMailingTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobMailingTemplate
     */
    select?: JobMailingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobMailingTemplateInclude<ExtArgs> | null
    /**
     * Filter, which JobMailingTemplate to fetch.
     */
    where?: JobMailingTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobMailingTemplates to fetch.
     */
    orderBy?: JobMailingTemplateOrderByWithRelationInput | JobMailingTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobMailingTemplates.
     */
    cursor?: JobMailingTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobMailingTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobMailingTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobMailingTemplates.
     */
    distinct?: JobMailingTemplateScalarFieldEnum | JobMailingTemplateScalarFieldEnum[]
  }


  /**
   * JobMailingTemplate findFirstOrThrow
   */
  export type JobMailingTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobMailingTemplate
     */
    select?: JobMailingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobMailingTemplateInclude<ExtArgs> | null
    /**
     * Filter, which JobMailingTemplate to fetch.
     */
    where?: JobMailingTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobMailingTemplates to fetch.
     */
    orderBy?: JobMailingTemplateOrderByWithRelationInput | JobMailingTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobMailingTemplates.
     */
    cursor?: JobMailingTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobMailingTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobMailingTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobMailingTemplates.
     */
    distinct?: JobMailingTemplateScalarFieldEnum | JobMailingTemplateScalarFieldEnum[]
  }


  /**
   * JobMailingTemplate findMany
   */
  export type JobMailingTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobMailingTemplate
     */
    select?: JobMailingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobMailingTemplateInclude<ExtArgs> | null
    /**
     * Filter, which JobMailingTemplates to fetch.
     */
    where?: JobMailingTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobMailingTemplates to fetch.
     */
    orderBy?: JobMailingTemplateOrderByWithRelationInput | JobMailingTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobMailingTemplates.
     */
    cursor?: JobMailingTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobMailingTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobMailingTemplates.
     */
    skip?: number
    distinct?: JobMailingTemplateScalarFieldEnum | JobMailingTemplateScalarFieldEnum[]
  }


  /**
   * JobMailingTemplate create
   */
  export type JobMailingTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobMailingTemplate
     */
    select?: JobMailingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobMailingTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a JobMailingTemplate.
     */
    data: XOR<JobMailingTemplateCreateInput, JobMailingTemplateUncheckedCreateInput>
  }


  /**
   * JobMailingTemplate createMany
   */
  export type JobMailingTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobMailingTemplates.
     */
    data: JobMailingTemplateCreateManyInput | JobMailingTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * JobMailingTemplate update
   */
  export type JobMailingTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobMailingTemplate
     */
    select?: JobMailingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobMailingTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a JobMailingTemplate.
     */
    data: XOR<JobMailingTemplateUpdateInput, JobMailingTemplateUncheckedUpdateInput>
    /**
     * Choose, which JobMailingTemplate to update.
     */
    where: JobMailingTemplateWhereUniqueInput
  }


  /**
   * JobMailingTemplate updateMany
   */
  export type JobMailingTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobMailingTemplates.
     */
    data: XOR<JobMailingTemplateUpdateManyMutationInput, JobMailingTemplateUncheckedUpdateManyInput>
    /**
     * Filter which JobMailingTemplates to update
     */
    where?: JobMailingTemplateWhereInput
  }


  /**
   * JobMailingTemplate upsert
   */
  export type JobMailingTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobMailingTemplate
     */
    select?: JobMailingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobMailingTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the JobMailingTemplate to update in case it exists.
     */
    where: JobMailingTemplateWhereUniqueInput
    /**
     * In case the JobMailingTemplate found by the `where` argument doesn't exist, create a new JobMailingTemplate with this data.
     */
    create: XOR<JobMailingTemplateCreateInput, JobMailingTemplateUncheckedCreateInput>
    /**
     * In case the JobMailingTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobMailingTemplateUpdateInput, JobMailingTemplateUncheckedUpdateInput>
  }


  /**
   * JobMailingTemplate delete
   */
  export type JobMailingTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobMailingTemplate
     */
    select?: JobMailingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobMailingTemplateInclude<ExtArgs> | null
    /**
     * Filter which JobMailingTemplate to delete.
     */
    where: JobMailingTemplateWhereUniqueInput
  }


  /**
   * JobMailingTemplate deleteMany
   */
  export type JobMailingTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobMailingTemplates to delete
     */
    where?: JobMailingTemplateWhereInput
  }


  /**
   * JobMailingTemplate without action
   */
  export type JobMailingTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobMailingTemplate
     */
    select?: JobMailingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: JobMailingTemplateInclude<ExtArgs> | null
  }



  /**
   * Model EmailMessage
   */

  export type AggregateEmailMessage = {
    _count: EmailMessageCountAggregateOutputType | null
    _min: EmailMessageMinAggregateOutputType | null
    _max: EmailMessageMaxAggregateOutputType | null
  }

  export type EmailMessageMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    parentMessageId: string | null
    sender: string | null
    recipient: string | null
    subject: string | null
    body: string | null
    s3Url: string | null
    direction: $Enums.EmailDirection | null
    createdAt: Date | null
    userId: string | null
    candidateId: string | null
  }

  export type EmailMessageMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    parentMessageId: string | null
    sender: string | null
    recipient: string | null
    subject: string | null
    body: string | null
    s3Url: string | null
    direction: $Enums.EmailDirection | null
    createdAt: Date | null
    userId: string | null
    candidateId: string | null
  }

  export type EmailMessageCountAggregateOutputType = {
    id: number
    messageId: number
    parentMessageId: number
    sender: number
    recipient: number
    subject: number
    body: number
    s3Url: number
    direction: number
    createdAt: number
    userId: number
    candidateId: number
    _all: number
  }


  export type EmailMessageMinAggregateInputType = {
    id?: true
    messageId?: true
    parentMessageId?: true
    sender?: true
    recipient?: true
    subject?: true
    body?: true
    s3Url?: true
    direction?: true
    createdAt?: true
    userId?: true
    candidateId?: true
  }

  export type EmailMessageMaxAggregateInputType = {
    id?: true
    messageId?: true
    parentMessageId?: true
    sender?: true
    recipient?: true
    subject?: true
    body?: true
    s3Url?: true
    direction?: true
    createdAt?: true
    userId?: true
    candidateId?: true
  }

  export type EmailMessageCountAggregateInputType = {
    id?: true
    messageId?: true
    parentMessageId?: true
    sender?: true
    recipient?: true
    subject?: true
    body?: true
    s3Url?: true
    direction?: true
    createdAt?: true
    userId?: true
    candidateId?: true
    _all?: true
  }

  export type EmailMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailMessage to aggregate.
     */
    where?: EmailMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailMessages to fetch.
     */
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailMessages
    **/
    _count?: true | EmailMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailMessageMaxAggregateInputType
  }

  export type GetEmailMessageAggregateType<T extends EmailMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailMessage[P]>
      : GetScalarType<T[P], AggregateEmailMessage[P]>
  }




  export type EmailMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailMessageWhereInput
    orderBy?: EmailMessageOrderByWithAggregationInput | EmailMessageOrderByWithAggregationInput[]
    by: EmailMessageScalarFieldEnum[] | EmailMessageScalarFieldEnum
    having?: EmailMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailMessageCountAggregateInputType | true
    _min?: EmailMessageMinAggregateInputType
    _max?: EmailMessageMaxAggregateInputType
  }

  export type EmailMessageGroupByOutputType = {
    id: string
    messageId: string
    parentMessageId: string | null
    sender: string
    recipient: string
    subject: string
    body: string
    s3Url: string | null
    direction: $Enums.EmailDirection
    createdAt: Date
    userId: string
    candidateId: string
    _count: EmailMessageCountAggregateOutputType | null
    _min: EmailMessageMinAggregateOutputType | null
    _max: EmailMessageMaxAggregateOutputType | null
  }

  type GetEmailMessageGroupByPayload<T extends EmailMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailMessageGroupByOutputType[P]>
            : GetScalarType<T[P], EmailMessageGroupByOutputType[P]>
        }
      >
    >


  export type EmailMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    parentMessageId?: boolean
    sender?: boolean
    recipient?: boolean
    subject?: boolean
    body?: boolean
    s3Url?: boolean
    direction?: boolean
    createdAt?: boolean
    userId?: boolean
    candidateId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    candidate?: boolean | CandidateApplicationDefaultArgs<ExtArgs>
    parentMessage?: boolean | EmailMessage$parentMessageArgs<ExtArgs>
    replies?: boolean | EmailMessage$repliesArgs<ExtArgs>
    _count?: boolean | EmailMessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailMessage"]>

  export type EmailMessageSelectScalar = {
    id?: boolean
    messageId?: boolean
    parentMessageId?: boolean
    sender?: boolean
    recipient?: boolean
    subject?: boolean
    body?: boolean
    s3Url?: boolean
    direction?: boolean
    createdAt?: boolean
    userId?: boolean
    candidateId?: boolean
  }

  export type EmailMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    candidate?: boolean | CandidateApplicationDefaultArgs<ExtArgs>
    parentMessage?: boolean | EmailMessage$parentMessageArgs<ExtArgs>
    replies?: boolean | EmailMessage$repliesArgs<ExtArgs>
    _count?: boolean | EmailMessageCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EmailMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailMessage"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      candidate: Prisma.$CandidateApplicationPayload<ExtArgs>
      parentMessage: Prisma.$EmailMessagePayload<ExtArgs> | null
      replies: Prisma.$EmailMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      parentMessageId: string | null
      sender: string
      recipient: string
      subject: string
      body: string
      s3Url: string | null
      direction: $Enums.EmailDirection
      createdAt: Date
      userId: string
      candidateId: string
    }, ExtArgs["result"]["emailMessage"]>
    composites: {}
  }


  type EmailMessageGetPayload<S extends boolean | null | undefined | EmailMessageDefaultArgs> = $Result.GetResult<Prisma.$EmailMessagePayload, S>

  type EmailMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailMessageCountAggregateInputType | true
    }

  export interface EmailMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailMessage'], meta: { name: 'EmailMessage' } }
    /**
     * Find zero or one EmailMessage that matches the filter.
     * @param {EmailMessageFindUniqueArgs} args - Arguments to find a EmailMessage
     * @example
     * // Get one EmailMessage
     * const emailMessage = await prisma.emailMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailMessageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailMessageFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailMessageFindUniqueOrThrowArgs} args - Arguments to find a EmailMessage
     * @example
     * // Get one EmailMessage
     * const emailMessage = await prisma.emailMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailMessageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailMessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageFindFirstArgs} args - Arguments to find a EmailMessage
     * @example
     * // Get one EmailMessage
     * const emailMessage = await prisma.emailMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailMessageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailMessageFindFirstArgs<ExtArgs>>
    ): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageFindFirstOrThrowArgs} args - Arguments to find a EmailMessage
     * @example
     * // Get one EmailMessage
     * const emailMessage = await prisma.emailMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailMessageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailMessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailMessages
     * const emailMessages = await prisma.emailMessage.findMany()
     * 
     * // Get first 10 EmailMessages
     * const emailMessages = await prisma.emailMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailMessageWithIdOnly = await prisma.emailMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailMessageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailMessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailMessage.
     * @param {EmailMessageCreateArgs} args - Arguments to create a EmailMessage.
     * @example
     * // Create one EmailMessage
     * const EmailMessage = await prisma.emailMessage.create({
     *   data: {
     *     // ... data to create a EmailMessage
     *   }
     * })
     * 
    **/
    create<T extends EmailMessageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailMessageCreateArgs<ExtArgs>>
    ): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailMessages.
     *     @param {EmailMessageCreateManyArgs} args - Arguments to create many EmailMessages.
     *     @example
     *     // Create many EmailMessages
     *     const emailMessage = await prisma.emailMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailMessageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailMessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailMessage.
     * @param {EmailMessageDeleteArgs} args - Arguments to delete one EmailMessage.
     * @example
     * // Delete one EmailMessage
     * const EmailMessage = await prisma.emailMessage.delete({
     *   where: {
     *     // ... filter to delete one EmailMessage
     *   }
     * })
     * 
    **/
    delete<T extends EmailMessageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailMessageDeleteArgs<ExtArgs>>
    ): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailMessage.
     * @param {EmailMessageUpdateArgs} args - Arguments to update one EmailMessage.
     * @example
     * // Update one EmailMessage
     * const emailMessage = await prisma.emailMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailMessageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailMessageUpdateArgs<ExtArgs>>
    ): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailMessages.
     * @param {EmailMessageDeleteManyArgs} args - Arguments to filter EmailMessages to delete.
     * @example
     * // Delete a few EmailMessages
     * const { count } = await prisma.emailMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailMessageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailMessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailMessages
     * const emailMessage = await prisma.emailMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailMessageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailMessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailMessage.
     * @param {EmailMessageUpsertArgs} args - Arguments to update or create a EmailMessage.
     * @example
     * // Update or create a EmailMessage
     * const emailMessage = await prisma.emailMessage.upsert({
     *   create: {
     *     // ... data to create a EmailMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailMessage we want to update
     *   }
     * })
    **/
    upsert<T extends EmailMessageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailMessageUpsertArgs<ExtArgs>>
    ): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmailMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageCountArgs} args - Arguments to filter EmailMessages to count.
     * @example
     * // Count the number of EmailMessages
     * const count = await prisma.emailMessage.count({
     *   where: {
     *     // ... the filter for the EmailMessages we want to count
     *   }
     * })
    **/
    count<T extends EmailMessageCountArgs>(
      args?: Subset<T, EmailMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailMessageAggregateArgs>(args: Subset<T, EmailMessageAggregateArgs>): Prisma.PrismaPromise<GetEmailMessageAggregateType<T>>

    /**
     * Group by EmailMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailMessageGroupByArgs['orderBy'] }
        : { orderBy?: EmailMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailMessage model
   */
  readonly fields: EmailMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    candidate<T extends CandidateApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CandidateApplicationDefaultArgs<ExtArgs>>): Prisma__CandidateApplicationClient<$Result.GetResult<Prisma.$CandidateApplicationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    parentMessage<T extends EmailMessage$parentMessageArgs<ExtArgs> = {}>(args?: Subset<T, EmailMessage$parentMessageArgs<ExtArgs>>): Prisma__EmailMessageClient<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    replies<T extends EmailMessage$repliesArgs<ExtArgs> = {}>(args?: Subset<T, EmailMessage$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailMessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailMessage model
   */ 
  interface EmailMessageFieldRefs {
    readonly id: FieldRef<"EmailMessage", 'String'>
    readonly messageId: FieldRef<"EmailMessage", 'String'>
    readonly parentMessageId: FieldRef<"EmailMessage", 'String'>
    readonly sender: FieldRef<"EmailMessage", 'String'>
    readonly recipient: FieldRef<"EmailMessage", 'String'>
    readonly subject: FieldRef<"EmailMessage", 'String'>
    readonly body: FieldRef<"EmailMessage", 'String'>
    readonly s3Url: FieldRef<"EmailMessage", 'String'>
    readonly direction: FieldRef<"EmailMessage", 'EmailDirection'>
    readonly createdAt: FieldRef<"EmailMessage", 'DateTime'>
    readonly userId: FieldRef<"EmailMessage", 'String'>
    readonly candidateId: FieldRef<"EmailMessage", 'String'>
  }
    

  // Custom InputTypes

  /**
   * EmailMessage findUnique
   */
  export type EmailMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailMessage to fetch.
     */
    where: EmailMessageWhereUniqueInput
  }


  /**
   * EmailMessage findUniqueOrThrow
   */
  export type EmailMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailMessage to fetch.
     */
    where: EmailMessageWhereUniqueInput
  }


  /**
   * EmailMessage findFirst
   */
  export type EmailMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailMessage to fetch.
     */
    where?: EmailMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailMessages to fetch.
     */
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailMessages.
     */
    cursor?: EmailMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailMessages.
     */
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }


  /**
   * EmailMessage findFirstOrThrow
   */
  export type EmailMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailMessage to fetch.
     */
    where?: EmailMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailMessages to fetch.
     */
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailMessages.
     */
    cursor?: EmailMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailMessages.
     */
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }


  /**
   * EmailMessage findMany
   */
  export type EmailMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter, which EmailMessages to fetch.
     */
    where?: EmailMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailMessages to fetch.
     */
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailMessages.
     */
    cursor?: EmailMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailMessages.
     */
    skip?: number
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }


  /**
   * EmailMessage create
   */
  export type EmailMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailMessage.
     */
    data: XOR<EmailMessageCreateInput, EmailMessageUncheckedCreateInput>
  }


  /**
   * EmailMessage createMany
   */
  export type EmailMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailMessages.
     */
    data: EmailMessageCreateManyInput | EmailMessageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmailMessage update
   */
  export type EmailMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailMessage.
     */
    data: XOR<EmailMessageUpdateInput, EmailMessageUncheckedUpdateInput>
    /**
     * Choose, which EmailMessage to update.
     */
    where: EmailMessageWhereUniqueInput
  }


  /**
   * EmailMessage updateMany
   */
  export type EmailMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailMessages.
     */
    data: XOR<EmailMessageUpdateManyMutationInput, EmailMessageUncheckedUpdateManyInput>
    /**
     * Filter which EmailMessages to update
     */
    where?: EmailMessageWhereInput
  }


  /**
   * EmailMessage upsert
   */
  export type EmailMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailMessage to update in case it exists.
     */
    where: EmailMessageWhereUniqueInput
    /**
     * In case the EmailMessage found by the `where` argument doesn't exist, create a new EmailMessage with this data.
     */
    create: XOR<EmailMessageCreateInput, EmailMessageUncheckedCreateInput>
    /**
     * In case the EmailMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailMessageUpdateInput, EmailMessageUncheckedUpdateInput>
  }


  /**
   * EmailMessage delete
   */
  export type EmailMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailMessageInclude<ExtArgs> | null
    /**
     * Filter which EmailMessage to delete.
     */
    where: EmailMessageWhereUniqueInput
  }


  /**
   * EmailMessage deleteMany
   */
  export type EmailMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailMessages to delete
     */
    where?: EmailMessageWhereInput
  }


  /**
   * EmailMessage.parentMessage
   */
  export type EmailMessage$parentMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailMessageInclude<ExtArgs> | null
    where?: EmailMessageWhereInput
  }


  /**
   * EmailMessage.replies
   */
  export type EmailMessage$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailMessageInclude<ExtArgs> | null
    where?: EmailMessageWhereInput
    orderBy?: EmailMessageOrderByWithRelationInput | EmailMessageOrderByWithRelationInput[]
    cursor?: EmailMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailMessageScalarFieldEnum | EmailMessageScalarFieldEnum[]
  }


  /**
   * EmailMessage without action
   */
  export type EmailMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailMessage
     */
    select?: EmailMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailMessageInclude<ExtArgs> | null
  }



  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    message: string | null
    createdAt: Date | null
    type: string | null
    category: string | null
    actionUrl: string | null
    priority: string | null
    userId: string | null
    organizationId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    message: string | null
    createdAt: Date | null
    type: string | null
    category: string | null
    actionUrl: string | null
    priority: string | null
    userId: string | null
    organizationId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    message: number
    createdAt: number
    type: number
    category: number
    actionUrl: number
    priority: number
    metadata: number
    userId: number
    organizationId: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    message?: true
    createdAt?: true
    type?: true
    category?: true
    actionUrl?: true
    priority?: true
    userId?: true
    organizationId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    message?: true
    createdAt?: true
    type?: true
    category?: true
    actionUrl?: true
    priority?: true
    userId?: true
    organizationId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    message?: true
    createdAt?: true
    type?: true
    category?: true
    actionUrl?: true
    priority?: true
    metadata?: true
    userId?: true
    organizationId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    message: string
    createdAt: Date
    type: string
    category: string
    actionUrl: string | null
    priority: string
    metadata: JsonValue | null
    userId: string | null
    organizationId: string | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    createdAt?: boolean
    type?: boolean
    category?: boolean
    actionUrl?: boolean
    priority?: boolean
    metadata?: boolean
    userId?: boolean
    organizationId?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
    organization?: boolean | Notification$organizationArgs<ExtArgs>
    receipts?: boolean | Notification$receiptsArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    message?: boolean
    createdAt?: boolean
    type?: boolean
    category?: boolean
    actionUrl?: boolean
    priority?: boolean
    metadata?: boolean
    userId?: boolean
    organizationId?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
    organization?: boolean | Notification$organizationArgs<ExtArgs>
    receipts?: boolean | Notification$receiptsArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      receipts: Prisma.$NotificationReceiptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      message: string
      createdAt: Date
      type: string
      category: string
      actionUrl: string | null
      priority: string
      metadata: Prisma.JsonValue | null
      userId: string | null
      organizationId: string | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }


  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Notifications.
     *     @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends Notification$userArgs<ExtArgs> = {}>(args?: Subset<T, Notification$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    organization<T extends Notification$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Notification$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    receipts<T extends Notification$receiptsArgs<ExtArgs> = {}>(args?: Subset<T, Notification$receiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationReceiptPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly category: FieldRef<"Notification", 'String'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly priority: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly organizationId: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }


  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification.user
   */
  export type Notification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Notification.organization
   */
  export type Notification$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }


  /**
   * Notification.receipts
   */
  export type Notification$receiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationReceipt
     */
    select?: NotificationReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationReceiptInclude<ExtArgs> | null
    where?: NotificationReceiptWhereInput
    orderBy?: NotificationReceiptOrderByWithRelationInput | NotificationReceiptOrderByWithRelationInput[]
    cursor?: NotificationReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationReceiptScalarFieldEnum | NotificationReceiptScalarFieldEnum[]
  }


  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
  }



  /**
   * Model NotificationReceipt
   */

  export type AggregateNotificationReceipt = {
    _count: NotificationReceiptCountAggregateOutputType | null
    _min: NotificationReceiptMinAggregateOutputType | null
    _max: NotificationReceiptMaxAggregateOutputType | null
  }

  export type NotificationReceiptMinAggregateOutputType = {
    id: string | null
    notificationId: string | null
    userId: string | null
    isRead: boolean | null
    readAt: Date | null
  }

  export type NotificationReceiptMaxAggregateOutputType = {
    id: string | null
    notificationId: string | null
    userId: string | null
    isRead: boolean | null
    readAt: Date | null
  }

  export type NotificationReceiptCountAggregateOutputType = {
    id: number
    notificationId: number
    userId: number
    isRead: number
    readAt: number
    _all: number
  }


  export type NotificationReceiptMinAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    isRead?: true
    readAt?: true
  }

  export type NotificationReceiptMaxAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    isRead?: true
    readAt?: true
  }

  export type NotificationReceiptCountAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    isRead?: true
    readAt?: true
    _all?: true
  }

  export type NotificationReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationReceipt to aggregate.
     */
    where?: NotificationReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationReceipts to fetch.
     */
    orderBy?: NotificationReceiptOrderByWithRelationInput | NotificationReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationReceipts
    **/
    _count?: true | NotificationReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationReceiptMaxAggregateInputType
  }

  export type GetNotificationReceiptAggregateType<T extends NotificationReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationReceipt[P]>
      : GetScalarType<T[P], AggregateNotificationReceipt[P]>
  }




  export type NotificationReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationReceiptWhereInput
    orderBy?: NotificationReceiptOrderByWithAggregationInput | NotificationReceiptOrderByWithAggregationInput[]
    by: NotificationReceiptScalarFieldEnum[] | NotificationReceiptScalarFieldEnum
    having?: NotificationReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationReceiptCountAggregateInputType | true
    _min?: NotificationReceiptMinAggregateInputType
    _max?: NotificationReceiptMaxAggregateInputType
  }

  export type NotificationReceiptGroupByOutputType = {
    id: string
    notificationId: string
    userId: string
    isRead: boolean
    readAt: Date | null
    _count: NotificationReceiptCountAggregateOutputType | null
    _min: NotificationReceiptMinAggregateOutputType | null
    _max: NotificationReceiptMaxAggregateOutputType | null
  }

  type GetNotificationReceiptGroupByPayload<T extends NotificationReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationReceiptGroupByOutputType[P]>
        }
      >
    >


  export type NotificationReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    isRead?: boolean
    readAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationReceipt"]>

  export type NotificationReceiptSelectScalar = {
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    isRead?: boolean
    readAt?: boolean
  }

  export type NotificationReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $NotificationReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationReceipt"
    objects: {
      notification: Prisma.$NotificationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      notificationId: string
      userId: string
      isRead: boolean
      readAt: Date | null
    }, ExtArgs["result"]["notificationReceipt"]>
    composites: {}
  }


  type NotificationReceiptGetPayload<S extends boolean | null | undefined | NotificationReceiptDefaultArgs> = $Result.GetResult<Prisma.$NotificationReceiptPayload, S>

  type NotificationReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationReceiptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationReceiptCountAggregateInputType | true
    }

  export interface NotificationReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationReceipt'], meta: { name: 'NotificationReceipt' } }
    /**
     * Find zero or one NotificationReceipt that matches the filter.
     * @param {NotificationReceiptFindUniqueArgs} args - Arguments to find a NotificationReceipt
     * @example
     * // Get one NotificationReceipt
     * const notificationReceipt = await prisma.notificationReceipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationReceiptFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationReceiptFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationReceiptClient<$Result.GetResult<Prisma.$NotificationReceiptPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one NotificationReceipt that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationReceiptFindUniqueOrThrowArgs} args - Arguments to find a NotificationReceipt
     * @example
     * // Get one NotificationReceipt
     * const notificationReceipt = await prisma.notificationReceipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationReceiptFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationReceiptFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationReceiptClient<$Result.GetResult<Prisma.$NotificationReceiptPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first NotificationReceipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReceiptFindFirstArgs} args - Arguments to find a NotificationReceipt
     * @example
     * // Get one NotificationReceipt
     * const notificationReceipt = await prisma.notificationReceipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationReceiptFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationReceiptFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationReceiptClient<$Result.GetResult<Prisma.$NotificationReceiptPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first NotificationReceipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReceiptFindFirstOrThrowArgs} args - Arguments to find a NotificationReceipt
     * @example
     * // Get one NotificationReceipt
     * const notificationReceipt = await prisma.notificationReceipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationReceiptFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationReceiptFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationReceiptClient<$Result.GetResult<Prisma.$NotificationReceiptPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more NotificationReceipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReceiptFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationReceipts
     * const notificationReceipts = await prisma.notificationReceipt.findMany()
     * 
     * // Get first 10 NotificationReceipts
     * const notificationReceipts = await prisma.notificationReceipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationReceiptWithIdOnly = await prisma.notificationReceipt.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationReceiptFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationReceiptFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationReceiptPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a NotificationReceipt.
     * @param {NotificationReceiptCreateArgs} args - Arguments to create a NotificationReceipt.
     * @example
     * // Create one NotificationReceipt
     * const NotificationReceipt = await prisma.notificationReceipt.create({
     *   data: {
     *     // ... data to create a NotificationReceipt
     *   }
     * })
     * 
    **/
    create<T extends NotificationReceiptCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationReceiptCreateArgs<ExtArgs>>
    ): Prisma__NotificationReceiptClient<$Result.GetResult<Prisma.$NotificationReceiptPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many NotificationReceipts.
     *     @param {NotificationReceiptCreateManyArgs} args - Arguments to create many NotificationReceipts.
     *     @example
     *     // Create many NotificationReceipts
     *     const notificationReceipt = await prisma.notificationReceipt.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationReceiptCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationReceiptCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NotificationReceipt.
     * @param {NotificationReceiptDeleteArgs} args - Arguments to delete one NotificationReceipt.
     * @example
     * // Delete one NotificationReceipt
     * const NotificationReceipt = await prisma.notificationReceipt.delete({
     *   where: {
     *     // ... filter to delete one NotificationReceipt
     *   }
     * })
     * 
    **/
    delete<T extends NotificationReceiptDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationReceiptDeleteArgs<ExtArgs>>
    ): Prisma__NotificationReceiptClient<$Result.GetResult<Prisma.$NotificationReceiptPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one NotificationReceipt.
     * @param {NotificationReceiptUpdateArgs} args - Arguments to update one NotificationReceipt.
     * @example
     * // Update one NotificationReceipt
     * const notificationReceipt = await prisma.notificationReceipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationReceiptUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationReceiptUpdateArgs<ExtArgs>>
    ): Prisma__NotificationReceiptClient<$Result.GetResult<Prisma.$NotificationReceiptPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more NotificationReceipts.
     * @param {NotificationReceiptDeleteManyArgs} args - Arguments to filter NotificationReceipts to delete.
     * @example
     * // Delete a few NotificationReceipts
     * const { count } = await prisma.notificationReceipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationReceiptDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationReceiptDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationReceipts
     * const notificationReceipt = await prisma.notificationReceipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationReceiptUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationReceiptUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationReceipt.
     * @param {NotificationReceiptUpsertArgs} args - Arguments to update or create a NotificationReceipt.
     * @example
     * // Update or create a NotificationReceipt
     * const notificationReceipt = await prisma.notificationReceipt.upsert({
     *   create: {
     *     // ... data to create a NotificationReceipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationReceipt we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationReceiptUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationReceiptUpsertArgs<ExtArgs>>
    ): Prisma__NotificationReceiptClient<$Result.GetResult<Prisma.$NotificationReceiptPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of NotificationReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReceiptCountArgs} args - Arguments to filter NotificationReceipts to count.
     * @example
     * // Count the number of NotificationReceipts
     * const count = await prisma.notificationReceipt.count({
     *   where: {
     *     // ... the filter for the NotificationReceipts we want to count
     *   }
     * })
    **/
    count<T extends NotificationReceiptCountArgs>(
      args?: Subset<T, NotificationReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationReceiptAggregateArgs>(args: Subset<T, NotificationReceiptAggregateArgs>): Prisma.PrismaPromise<GetNotificationReceiptAggregateType<T>>

    /**
     * Group by NotificationReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationReceiptGroupByArgs['orderBy'] }
        : { orderBy?: NotificationReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationReceipt model
   */
  readonly fields: NotificationReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationReceipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    notification<T extends NotificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationDefaultArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the NotificationReceipt model
   */ 
  interface NotificationReceiptFieldRefs {
    readonly id: FieldRef<"NotificationReceipt", 'String'>
    readonly notificationId: FieldRef<"NotificationReceipt", 'String'>
    readonly userId: FieldRef<"NotificationReceipt", 'String'>
    readonly isRead: FieldRef<"NotificationReceipt", 'Boolean'>
    readonly readAt: FieldRef<"NotificationReceipt", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * NotificationReceipt findUnique
   */
  export type NotificationReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationReceipt
     */
    select?: NotificationReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationReceiptInclude<ExtArgs> | null
    /**
     * Filter, which NotificationReceipt to fetch.
     */
    where: NotificationReceiptWhereUniqueInput
  }


  /**
   * NotificationReceipt findUniqueOrThrow
   */
  export type NotificationReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationReceipt
     */
    select?: NotificationReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationReceiptInclude<ExtArgs> | null
    /**
     * Filter, which NotificationReceipt to fetch.
     */
    where: NotificationReceiptWhereUniqueInput
  }


  /**
   * NotificationReceipt findFirst
   */
  export type NotificationReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationReceipt
     */
    select?: NotificationReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationReceiptInclude<ExtArgs> | null
    /**
     * Filter, which NotificationReceipt to fetch.
     */
    where?: NotificationReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationReceipts to fetch.
     */
    orderBy?: NotificationReceiptOrderByWithRelationInput | NotificationReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationReceipts.
     */
    cursor?: NotificationReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationReceipts.
     */
    distinct?: NotificationReceiptScalarFieldEnum | NotificationReceiptScalarFieldEnum[]
  }


  /**
   * NotificationReceipt findFirstOrThrow
   */
  export type NotificationReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationReceipt
     */
    select?: NotificationReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationReceiptInclude<ExtArgs> | null
    /**
     * Filter, which NotificationReceipt to fetch.
     */
    where?: NotificationReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationReceipts to fetch.
     */
    orderBy?: NotificationReceiptOrderByWithRelationInput | NotificationReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationReceipts.
     */
    cursor?: NotificationReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationReceipts.
     */
    distinct?: NotificationReceiptScalarFieldEnum | NotificationReceiptScalarFieldEnum[]
  }


  /**
   * NotificationReceipt findMany
   */
  export type NotificationReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationReceipt
     */
    select?: NotificationReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationReceiptInclude<ExtArgs> | null
    /**
     * Filter, which NotificationReceipts to fetch.
     */
    where?: NotificationReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationReceipts to fetch.
     */
    orderBy?: NotificationReceiptOrderByWithRelationInput | NotificationReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationReceipts.
     */
    cursor?: NotificationReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationReceipts.
     */
    skip?: number
    distinct?: NotificationReceiptScalarFieldEnum | NotificationReceiptScalarFieldEnum[]
  }


  /**
   * NotificationReceipt create
   */
  export type NotificationReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationReceipt
     */
    select?: NotificationReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationReceipt.
     */
    data: XOR<NotificationReceiptCreateInput, NotificationReceiptUncheckedCreateInput>
  }


  /**
   * NotificationReceipt createMany
   */
  export type NotificationReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationReceipts.
     */
    data: NotificationReceiptCreateManyInput | NotificationReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * NotificationReceipt update
   */
  export type NotificationReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationReceipt
     */
    select?: NotificationReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationReceipt.
     */
    data: XOR<NotificationReceiptUpdateInput, NotificationReceiptUncheckedUpdateInput>
    /**
     * Choose, which NotificationReceipt to update.
     */
    where: NotificationReceiptWhereUniqueInput
  }


  /**
   * NotificationReceipt updateMany
   */
  export type NotificationReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationReceipts.
     */
    data: XOR<NotificationReceiptUpdateManyMutationInput, NotificationReceiptUncheckedUpdateManyInput>
    /**
     * Filter which NotificationReceipts to update
     */
    where?: NotificationReceiptWhereInput
  }


  /**
   * NotificationReceipt upsert
   */
  export type NotificationReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationReceipt
     */
    select?: NotificationReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationReceipt to update in case it exists.
     */
    where: NotificationReceiptWhereUniqueInput
    /**
     * In case the NotificationReceipt found by the `where` argument doesn't exist, create a new NotificationReceipt with this data.
     */
    create: XOR<NotificationReceiptCreateInput, NotificationReceiptUncheckedCreateInput>
    /**
     * In case the NotificationReceipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationReceiptUpdateInput, NotificationReceiptUncheckedUpdateInput>
  }


  /**
   * NotificationReceipt delete
   */
  export type NotificationReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationReceipt
     */
    select?: NotificationReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationReceiptInclude<ExtArgs> | null
    /**
     * Filter which NotificationReceipt to delete.
     */
    where: NotificationReceiptWhereUniqueInput
  }


  /**
   * NotificationReceipt deleteMany
   */
  export type NotificationReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationReceipts to delete
     */
    where?: NotificationReceiptWhereInput
  }


  /**
   * NotificationReceipt without action
   */
  export type NotificationReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationReceipt
     */
    select?: NotificationReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationReceiptInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const OrganizationUserRoleScalarFieldEnum: {
    id: 'id',
    role: 'role',
    organizationId: 'organizationId',
    email: 'email',
    userId: 'userId',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type OrganizationUserRoleScalarFieldEnum = (typeof OrganizationUserRoleScalarFieldEnum)[keyof typeof OrganizationUserRoleScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    password: 'password',
    role: 'role',
    isTwoFactorEnabled: 'isTwoFactorEnabled'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const TwoFactorTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires'
  };

  export type TwoFactorTokenScalarFieldEnum = (typeof TwoFactorTokenScalarFieldEnum)[keyof typeof TwoFactorTokenScalarFieldEnum]


  export const TwoFactorConfirmationScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type TwoFactorConfirmationScalarFieldEnum = (typeof TwoFactorConfirmationScalarFieldEnum)[keyof typeof TwoFactorConfirmationScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    logo: 'logo',
    assignedDomain: 'assignedDomain',
    customDomain: 'customDomain',
    createdAt: 'createdAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const OrganizationSubscriptionScalarFieldEnum: {
    id: 'id',
    referalId: 'referalId',
    paymentHandler: 'paymentHandler',
    organizationId: 'organizationId',
    status: 'status',
    subscriptionType: 'subscriptionType',
    userId: 'userId',
    createdAt: 'createdAt',
    expiresOn: 'expiresOn'
  };

  export type OrganizationSubscriptionScalarFieldEnum = (typeof OrganizationSubscriptionScalarFieldEnum)[keyof typeof OrganizationSubscriptionScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    paddlePaymentId: 'paddlePaymentId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const OrganizationActivityLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    organizationId: 'organizationId',
    createdAt: 'createdAt'
  };

  export type OrganizationActivityLogScalarFieldEnum = (typeof OrganizationActivityLogScalarFieldEnum)[keyof typeof OrganizationActivityLogScalarFieldEnum]


  export const JobPostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    employmentType: 'employmentType',
    country: 'country',
    city: 'city',
    remoteOption: 'remoteOption',
    countryResidence: 'countryResidence',
    countryListResidence: 'countryListResidence',
    displaySalary: 'displaySalary',
    currency: 'currency',
    salaryAmount: 'salaryAmount',
    minimumAmount: 'minimumAmount',
    maximumAmount: 'maximumAmount',
    isPublished: 'isPublished',
    isScheduled: 'isScheduled',
    isArchived: 'isArchived',
    dateStart: 'dateStart',
    dateEnd: 'dateEnd',
    organizationId: 'organizationId',
    createdAt: 'createdAt'
  };

  export type JobPostScalarFieldEnum = (typeof JobPostScalarFieldEnum)[keyof typeof JobPostScalarFieldEnum]


  export const JobApplicationScalarFieldEnum: {
    id: 'id',
    label: 'label',
    dataType: 'dataType',
    option: 'option',
    rule: 'rule',
    questionType: 'questionType',
    isDeleted: 'isDeleted',
    jobId: 'jobId',
    createdAt: 'createdAt'
  };

  export type JobApplicationScalarFieldEnum = (typeof JobApplicationScalarFieldEnum)[keyof typeof JobApplicationScalarFieldEnum]


  export const CandidateApplicationScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    createdAt: 'createdAt',
    stageId: 'stageId'
  };

  export type CandidateApplicationScalarFieldEnum = (typeof CandidateApplicationScalarFieldEnum)[keyof typeof CandidateApplicationScalarFieldEnum]


  export const CandidateReviewScalarFieldEnum: {
    id: 'id',
    description: 'description',
    verdict: 'verdict',
    createdAt: 'createdAt'
  };

  export type CandidateReviewScalarFieldEnum = (typeof CandidateReviewScalarFieldEnum)[keyof typeof CandidateReviewScalarFieldEnum]


  export const CandidateTimelineScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    userId: 'userId',
    actionType: 'actionType',
    jobId: 'jobId',
    timelineText: 'timelineText',
    comment: 'comment',
    reviewId: 'reviewId',
    candidateId: 'candidateId'
  };

  export type CandidateTimelineScalarFieldEnum = (typeof CandidateTimelineScalarFieldEnum)[keyof typeof CandidateTimelineScalarFieldEnum]


  export const FormResponseScalarFieldEnum: {
    id: 'id',
    candidateApplicationId: 'candidateApplicationId',
    jobApplicationId: 'jobApplicationId',
    label: 'label',
    value: 'value',
    createdAt: 'createdAt'
  };

  export type FormResponseScalarFieldEnum = (typeof FormResponseScalarFieldEnum)[keyof typeof FormResponseScalarFieldEnum]


  export const JobPreviewScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    isExpired: 'isExpired',
    organizationId: 'organizationId',
    jobId: 'jobId'
  };

  export type JobPreviewScalarFieldEnum = (typeof JobPreviewScalarFieldEnum)[keyof typeof JobPreviewScalarFieldEnum]


  export const JobStageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isDeletable: 'isDeletable',
    isDeleted: 'isDeleted',
    displayOrder: 'displayOrder',
    jobId: 'jobId',
    createdAt: 'createdAt'
  };

  export type JobStageScalarFieldEnum = (typeof JobStageScalarFieldEnum)[keyof typeof JobStageScalarFieldEnum]


  export const JobMailingTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    body: 'body',
    createdAt: 'createdAt',
    jobId: 'jobId'
  };

  export type JobMailingTemplateScalarFieldEnum = (typeof JobMailingTemplateScalarFieldEnum)[keyof typeof JobMailingTemplateScalarFieldEnum]


  export const EmailMessageScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    parentMessageId: 'parentMessageId',
    sender: 'sender',
    recipient: 'recipient',
    subject: 'subject',
    body: 'body',
    s3Url: 's3Url',
    direction: 'direction',
    createdAt: 'createdAt',
    userId: 'userId',
    candidateId: 'candidateId'
  };

  export type EmailMessageScalarFieldEnum = (typeof EmailMessageScalarFieldEnum)[keyof typeof EmailMessageScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    message: 'message',
    createdAt: 'createdAt',
    type: 'type',
    category: 'category',
    actionUrl: 'actionUrl',
    priority: 'priority',
    metadata: 'metadata',
    userId: 'userId',
    organizationId: 'organizationId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationReceiptScalarFieldEnum: {
    id: 'id',
    notificationId: 'notificationId',
    userId: 'userId',
    isRead: 'isRead',
    readAt: 'readAt'
  };

  export type NotificationReceiptScalarFieldEnum = (typeof NotificationReceiptScalarFieldEnum)[keyof typeof NotificationReceiptScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'OrganizationRole'
   */
  export type EnumOrganizationRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrganizationRole'>
    


  /**
   * Reference to a field of type 'OrganizationRole[]'
   */
  export type ListEnumOrganizationRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrganizationRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'EmailDirection'
   */
  export type EnumEmailDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailDirection'>
    


  /**
   * Reference to a field of type 'EmailDirection[]'
   */
  export type ListEnumEmailDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailDirection[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type OrganizationUserRoleWhereInput = {
    AND?: OrganizationUserRoleWhereInput | OrganizationUserRoleWhereInput[]
    OR?: OrganizationUserRoleWhereInput[]
    NOT?: OrganizationUserRoleWhereInput | OrganizationUserRoleWhereInput[]
    id?: StringFilter<"OrganizationUserRole"> | string
    role?: EnumOrganizationRoleFilter<"OrganizationUserRole"> | $Enums.OrganizationRole
    organizationId?: StringFilter<"OrganizationUserRole"> | string
    email?: StringFilter<"OrganizationUserRole"> | string
    userId?: StringNullableFilter<"OrganizationUserRole"> | string | null
    status?: StringFilter<"OrganizationUserRole"> | string
    createdAt?: DateTimeFilter<"OrganizationUserRole"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type OrganizationUserRoleOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    userId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type OrganizationUserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganizationUserRoleWhereInput | OrganizationUserRoleWhereInput[]
    OR?: OrganizationUserRoleWhereInput[]
    NOT?: OrganizationUserRoleWhereInput | OrganizationUserRoleWhereInput[]
    role?: EnumOrganizationRoleFilter<"OrganizationUserRole"> | $Enums.OrganizationRole
    organizationId?: StringFilter<"OrganizationUserRole"> | string
    email?: StringFilter<"OrganizationUserRole"> | string
    userId?: StringNullableFilter<"OrganizationUserRole"> | string | null
    status?: StringFilter<"OrganizationUserRole"> | string
    createdAt?: DateTimeFilter<"OrganizationUserRole"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type OrganizationUserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    userId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: OrganizationUserRoleCountOrderByAggregateInput
    _max?: OrganizationUserRoleMaxOrderByAggregateInput
    _min?: OrganizationUserRoleMinOrderByAggregateInput
  }

  export type OrganizationUserRoleScalarWhereWithAggregatesInput = {
    AND?: OrganizationUserRoleScalarWhereWithAggregatesInput | OrganizationUserRoleScalarWhereWithAggregatesInput[]
    OR?: OrganizationUserRoleScalarWhereWithAggregatesInput[]
    NOT?: OrganizationUserRoleScalarWhereWithAggregatesInput | OrganizationUserRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrganizationUserRole"> | string
    role?: EnumOrganizationRoleWithAggregatesFilter<"OrganizationUserRole"> | $Enums.OrganizationRole
    organizationId?: StringWithAggregatesFilter<"OrganizationUserRole"> | string
    email?: StringWithAggregatesFilter<"OrganizationUserRole"> | string
    userId?: StringNullableWithAggregatesFilter<"OrganizationUserRole"> | string | null
    status?: StringWithAggregatesFilter<"OrganizationUserRole"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OrganizationUserRole"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isTwoFactorEnabled?: BoolFilter<"User"> | boolean
    accounts?: AccountListRelationFilter
    organizations?: OrganizationUserRoleListRelationFilter
    twoFactorConfirmation?: XOR<TwoFactorConfirmationNullableRelationFilter, TwoFactorConfirmationWhereInput> | null
    candidateTimeline?: CandidateTimelineListRelationFilter
    emailMessage?: EmailMessageListRelationFilter
    organizationSubscription?: OrganizationSubscriptionListRelationFilter
    NotificationReceipt?: NotificationReceiptListRelationFilter
    Notification?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    isTwoFactorEnabled?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    organizations?: OrganizationUserRoleOrderByRelationAggregateInput
    twoFactorConfirmation?: TwoFactorConfirmationOrderByWithRelationInput
    candidateTimeline?: CandidateTimelineOrderByRelationAggregateInput
    emailMessage?: EmailMessageOrderByRelationAggregateInput
    organizationSubscription?: OrganizationSubscriptionOrderByRelationAggregateInput
    NotificationReceipt?: NotificationReceiptOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isTwoFactorEnabled?: BoolFilter<"User"> | boolean
    accounts?: AccountListRelationFilter
    organizations?: OrganizationUserRoleListRelationFilter
    twoFactorConfirmation?: XOR<TwoFactorConfirmationNullableRelationFilter, TwoFactorConfirmationWhereInput> | null
    candidateTimeline?: CandidateTimelineListRelationFilter
    emailMessage?: EmailMessageListRelationFilter
    organizationSubscription?: OrganizationSubscriptionListRelationFilter
    NotificationReceipt?: NotificationReceiptListRelationFilter
    Notification?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    isTwoFactorEnabled?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isTwoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    id?: StringFilter<"VerificationToken"> | string
    email?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_token?: VerificationTokenEmailTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    email?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "id" | "token" | "email_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationToken"> | string
    email?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_token?: PasswordResetTokenEmailTokenCompoundUniqueInput
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    email?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }, "id" | "token" | "email_token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    email?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expires?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type TwoFactorTokenWhereInput = {
    AND?: TwoFactorTokenWhereInput | TwoFactorTokenWhereInput[]
    OR?: TwoFactorTokenWhereInput[]
    NOT?: TwoFactorTokenWhereInput | TwoFactorTokenWhereInput[]
    id?: StringFilter<"TwoFactorToken"> | string
    email?: StringFilter<"TwoFactorToken"> | string
    token?: StringFilter<"TwoFactorToken"> | string
    expires?: DateTimeFilter<"TwoFactorToken"> | Date | string
  }

  export type TwoFactorTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type TwoFactorTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_token?: TwoFactorTokenEmailTokenCompoundUniqueInput
    AND?: TwoFactorTokenWhereInput | TwoFactorTokenWhereInput[]
    OR?: TwoFactorTokenWhereInput[]
    NOT?: TwoFactorTokenWhereInput | TwoFactorTokenWhereInput[]
    email?: StringFilter<"TwoFactorToken"> | string
    expires?: DateTimeFilter<"TwoFactorToken"> | Date | string
  }, "id" | "token" | "email_token">

  export type TwoFactorTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: TwoFactorTokenCountOrderByAggregateInput
    _max?: TwoFactorTokenMaxOrderByAggregateInput
    _min?: TwoFactorTokenMinOrderByAggregateInput
  }

  export type TwoFactorTokenScalarWhereWithAggregatesInput = {
    AND?: TwoFactorTokenScalarWhereWithAggregatesInput | TwoFactorTokenScalarWhereWithAggregatesInput[]
    OR?: TwoFactorTokenScalarWhereWithAggregatesInput[]
    NOT?: TwoFactorTokenScalarWhereWithAggregatesInput | TwoFactorTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TwoFactorToken"> | string
    email?: StringWithAggregatesFilter<"TwoFactorToken"> | string
    token?: StringWithAggregatesFilter<"TwoFactorToken"> | string
    expires?: DateTimeWithAggregatesFilter<"TwoFactorToken"> | Date | string
  }

  export type TwoFactorConfirmationWhereInput = {
    AND?: TwoFactorConfirmationWhereInput | TwoFactorConfirmationWhereInput[]
    OR?: TwoFactorConfirmationWhereInput[]
    NOT?: TwoFactorConfirmationWhereInput | TwoFactorConfirmationWhereInput[]
    id?: StringFilter<"TwoFactorConfirmation"> | string
    userId?: StringFilter<"TwoFactorConfirmation"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TwoFactorConfirmationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TwoFactorConfirmationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: TwoFactorConfirmationWhereInput | TwoFactorConfirmationWhereInput[]
    OR?: TwoFactorConfirmationWhereInput[]
    NOT?: TwoFactorConfirmationWhereInput | TwoFactorConfirmationWhereInput[]
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type TwoFactorConfirmationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: TwoFactorConfirmationCountOrderByAggregateInput
    _max?: TwoFactorConfirmationMaxOrderByAggregateInput
    _min?: TwoFactorConfirmationMinOrderByAggregateInput
  }

  export type TwoFactorConfirmationScalarWhereWithAggregatesInput = {
    AND?: TwoFactorConfirmationScalarWhereWithAggregatesInput | TwoFactorConfirmationScalarWhereWithAggregatesInput[]
    OR?: TwoFactorConfirmationScalarWhereWithAggregatesInput[]
    NOT?: TwoFactorConfirmationScalarWhereWithAggregatesInput | TwoFactorConfirmationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TwoFactorConfirmation"> | string
    userId?: StringWithAggregatesFilter<"TwoFactorConfirmation"> | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    url?: StringNullableFilter<"Organization"> | string | null
    logo?: StringNullableFilter<"Organization"> | string | null
    assignedDomain?: StringNullableFilter<"Organization"> | string | null
    customDomain?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    organizationRole?: OrganizationUserRoleListRelationFilter
    organizationActionLog?: OrganizationActivityLogListRelationFilter
    jobPost?: JobPostListRelationFilter
    payment?: PaymentListRelationFilter
    jobPreview?: JobPreviewListRelationFilter
    organizationSubscription?: OrganizationSubscriptionListRelationFilter
    Notification?: NotificationListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    assignedDomain?: SortOrderInput | SortOrder
    customDomain?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    organizationRole?: OrganizationUserRoleOrderByRelationAggregateInput
    organizationActionLog?: OrganizationActivityLogOrderByRelationAggregateInput
    jobPost?: JobPostOrderByRelationAggregateInput
    payment?: PaymentOrderByRelationAggregateInput
    jobPreview?: JobPreviewOrderByRelationAggregateInput
    organizationSubscription?: OrganizationSubscriptionOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    url?: StringNullableFilter<"Organization"> | string | null
    logo?: StringNullableFilter<"Organization"> | string | null
    assignedDomain?: StringNullableFilter<"Organization"> | string | null
    customDomain?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    organizationRole?: OrganizationUserRoleListRelationFilter
    organizationActionLog?: OrganizationActivityLogListRelationFilter
    jobPost?: JobPostListRelationFilter
    payment?: PaymentListRelationFilter
    jobPreview?: JobPreviewListRelationFilter
    organizationSubscription?: OrganizationSubscriptionListRelationFilter
    Notification?: NotificationListRelationFilter
  }, "id">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    assignedDomain?: SortOrderInput | SortOrder
    customDomain?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    url?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    assignedDomain?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    customDomain?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type OrganizationSubscriptionWhereInput = {
    AND?: OrganizationSubscriptionWhereInput | OrganizationSubscriptionWhereInput[]
    OR?: OrganizationSubscriptionWhereInput[]
    NOT?: OrganizationSubscriptionWhereInput | OrganizationSubscriptionWhereInput[]
    id?: StringFilter<"OrganizationSubscription"> | string
    referalId?: StringNullableFilter<"OrganizationSubscription"> | string | null
    paymentHandler?: StringFilter<"OrganizationSubscription"> | string
    organizationId?: StringFilter<"OrganizationSubscription"> | string
    status?: EnumSubscriptionStatusFilter<"OrganizationSubscription"> | $Enums.SubscriptionStatus
    subscriptionType?: StringFilter<"OrganizationSubscription"> | string
    userId?: StringFilter<"OrganizationSubscription"> | string
    createdAt?: DateTimeFilter<"OrganizationSubscription"> | Date | string
    expiresOn?: DateTimeFilter<"OrganizationSubscription"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OrganizationSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    referalId?: SortOrderInput | SortOrder
    paymentHandler?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    subscriptionType?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresOn?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type OrganizationSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganizationSubscriptionWhereInput | OrganizationSubscriptionWhereInput[]
    OR?: OrganizationSubscriptionWhereInput[]
    NOT?: OrganizationSubscriptionWhereInput | OrganizationSubscriptionWhereInput[]
    referalId?: StringNullableFilter<"OrganizationSubscription"> | string | null
    paymentHandler?: StringFilter<"OrganizationSubscription"> | string
    organizationId?: StringFilter<"OrganizationSubscription"> | string
    status?: EnumSubscriptionStatusFilter<"OrganizationSubscription"> | $Enums.SubscriptionStatus
    subscriptionType?: StringFilter<"OrganizationSubscription"> | string
    userId?: StringFilter<"OrganizationSubscription"> | string
    createdAt?: DateTimeFilter<"OrganizationSubscription"> | Date | string
    expiresOn?: DateTimeFilter<"OrganizationSubscription"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type OrganizationSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    referalId?: SortOrderInput | SortOrder
    paymentHandler?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    subscriptionType?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresOn?: SortOrder
    _count?: OrganizationSubscriptionCountOrderByAggregateInput
    _max?: OrganizationSubscriptionMaxOrderByAggregateInput
    _min?: OrganizationSubscriptionMinOrderByAggregateInput
  }

  export type OrganizationSubscriptionScalarWhereWithAggregatesInput = {
    AND?: OrganizationSubscriptionScalarWhereWithAggregatesInput | OrganizationSubscriptionScalarWhereWithAggregatesInput[]
    OR?: OrganizationSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: OrganizationSubscriptionScalarWhereWithAggregatesInput | OrganizationSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrganizationSubscription"> | string
    referalId?: StringNullableWithAggregatesFilter<"OrganizationSubscription"> | string | null
    paymentHandler?: StringWithAggregatesFilter<"OrganizationSubscription"> | string
    organizationId?: StringWithAggregatesFilter<"OrganizationSubscription"> | string
    status?: EnumSubscriptionStatusWithAggregatesFilter<"OrganizationSubscription"> | $Enums.SubscriptionStatus
    subscriptionType?: StringWithAggregatesFilter<"OrganizationSubscription"> | string
    userId?: StringWithAggregatesFilter<"OrganizationSubscription"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OrganizationSubscription"> | Date | string
    expiresOn?: DateTimeWithAggregatesFilter<"OrganizationSubscription"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    organizationId?: StringFilter<"Payment"> | string
    paddlePaymentId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    paddlePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    paddlePaymentId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    organizationId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }, "id" | "paddlePaymentId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    paddlePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    organizationId?: StringWithAggregatesFilter<"Payment"> | string
    paddlePaymentId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type OrganizationActivityLogWhereInput = {
    AND?: OrganizationActivityLogWhereInput | OrganizationActivityLogWhereInput[]
    OR?: OrganizationActivityLogWhereInput[]
    NOT?: OrganizationActivityLogWhereInput | OrganizationActivityLogWhereInput[]
    id?: StringFilter<"OrganizationActivityLog"> | string
    action?: StringFilter<"OrganizationActivityLog"> | string
    organizationId?: StringFilter<"OrganizationActivityLog"> | string
    createdAt?: DateTimeFilter<"OrganizationActivityLog"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }

  export type OrganizationActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type OrganizationActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganizationActivityLogWhereInput | OrganizationActivityLogWhereInput[]
    OR?: OrganizationActivityLogWhereInput[]
    NOT?: OrganizationActivityLogWhereInput | OrganizationActivityLogWhereInput[]
    action?: StringFilter<"OrganizationActivityLog"> | string
    organizationId?: StringFilter<"OrganizationActivityLog"> | string
    createdAt?: DateTimeFilter<"OrganizationActivityLog"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }, "id">

  export type OrganizationActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    _count?: OrganizationActivityLogCountOrderByAggregateInput
    _max?: OrganizationActivityLogMaxOrderByAggregateInput
    _min?: OrganizationActivityLogMinOrderByAggregateInput
  }

  export type OrganizationActivityLogScalarWhereWithAggregatesInput = {
    AND?: OrganizationActivityLogScalarWhereWithAggregatesInput | OrganizationActivityLogScalarWhereWithAggregatesInput[]
    OR?: OrganizationActivityLogScalarWhereWithAggregatesInput[]
    NOT?: OrganizationActivityLogScalarWhereWithAggregatesInput | OrganizationActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrganizationActivityLog"> | string
    action?: StringWithAggregatesFilter<"OrganizationActivityLog"> | string
    organizationId?: StringWithAggregatesFilter<"OrganizationActivityLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OrganizationActivityLog"> | Date | string
  }

  export type JobPostWhereInput = {
    AND?: JobPostWhereInput | JobPostWhereInput[]
    OR?: JobPostWhereInput[]
    NOT?: JobPostWhereInput | JobPostWhereInput[]
    id?: StringFilter<"JobPost"> | string
    title?: StringFilter<"JobPost"> | string
    description?: StringNullableFilter<"JobPost"> | string | null
    category?: StringNullableFilter<"JobPost"> | string | null
    employmentType?: StringNullableFilter<"JobPost"> | string | null
    country?: StringNullableFilter<"JobPost"> | string | null
    city?: StringNullableFilter<"JobPost"> | string | null
    remoteOption?: StringNullableFilter<"JobPost"> | string | null
    countryResidence?: StringNullableFilter<"JobPost"> | string | null
    countryListResidence?: StringNullableListFilter<"JobPost">
    displaySalary?: StringNullableFilter<"JobPost"> | string | null
    currency?: StringNullableFilter<"JobPost"> | string | null
    salaryAmount?: FloatNullableFilter<"JobPost"> | number | null
    minimumAmount?: FloatNullableFilter<"JobPost"> | number | null
    maximumAmount?: FloatNullableFilter<"JobPost"> | number | null
    isPublished?: BoolFilter<"JobPost"> | boolean
    isScheduled?: BoolFilter<"JobPost"> | boolean
    isArchived?: BoolFilter<"JobPost"> | boolean
    dateStart?: DateTimeNullableFilter<"JobPost"> | Date | string | null
    dateEnd?: DateTimeNullableFilter<"JobPost"> | Date | string | null
    organizationId?: StringFilter<"JobPost"> | string
    createdAt?: DateTimeFilter<"JobPost"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    jobApplication?: JobApplicationListRelationFilter
    jobStage?: JobStageListRelationFilter
    jobPreview?: JobPreviewListRelationFilter
    candidateApplication?: CandidateApplicationListRelationFilter
    CandidateTimeline?: CandidateTimelineListRelationFilter
    JobMailingTemplate?: JobMailingTemplateListRelationFilter
  }

  export type JobPostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    employmentType?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    remoteOption?: SortOrderInput | SortOrder
    countryResidence?: SortOrderInput | SortOrder
    countryListResidence?: SortOrder
    displaySalary?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    salaryAmount?: SortOrderInput | SortOrder
    minimumAmount?: SortOrderInput | SortOrder
    maximumAmount?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    isScheduled?: SortOrder
    isArchived?: SortOrder
    dateStart?: SortOrderInput | SortOrder
    dateEnd?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    jobApplication?: JobApplicationOrderByRelationAggregateInput
    jobStage?: JobStageOrderByRelationAggregateInput
    jobPreview?: JobPreviewOrderByRelationAggregateInput
    candidateApplication?: CandidateApplicationOrderByRelationAggregateInput
    CandidateTimeline?: CandidateTimelineOrderByRelationAggregateInput
    JobMailingTemplate?: JobMailingTemplateOrderByRelationAggregateInput
  }

  export type JobPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobPostWhereInput | JobPostWhereInput[]
    OR?: JobPostWhereInput[]
    NOT?: JobPostWhereInput | JobPostWhereInput[]
    title?: StringFilter<"JobPost"> | string
    description?: StringNullableFilter<"JobPost"> | string | null
    category?: StringNullableFilter<"JobPost"> | string | null
    employmentType?: StringNullableFilter<"JobPost"> | string | null
    country?: StringNullableFilter<"JobPost"> | string | null
    city?: StringNullableFilter<"JobPost"> | string | null
    remoteOption?: StringNullableFilter<"JobPost"> | string | null
    countryResidence?: StringNullableFilter<"JobPost"> | string | null
    countryListResidence?: StringNullableListFilter<"JobPost">
    displaySalary?: StringNullableFilter<"JobPost"> | string | null
    currency?: StringNullableFilter<"JobPost"> | string | null
    salaryAmount?: FloatNullableFilter<"JobPost"> | number | null
    minimumAmount?: FloatNullableFilter<"JobPost"> | number | null
    maximumAmount?: FloatNullableFilter<"JobPost"> | number | null
    isPublished?: BoolFilter<"JobPost"> | boolean
    isScheduled?: BoolFilter<"JobPost"> | boolean
    isArchived?: BoolFilter<"JobPost"> | boolean
    dateStart?: DateTimeNullableFilter<"JobPost"> | Date | string | null
    dateEnd?: DateTimeNullableFilter<"JobPost"> | Date | string | null
    organizationId?: StringFilter<"JobPost"> | string
    createdAt?: DateTimeFilter<"JobPost"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    jobApplication?: JobApplicationListRelationFilter
    jobStage?: JobStageListRelationFilter
    jobPreview?: JobPreviewListRelationFilter
    candidateApplication?: CandidateApplicationListRelationFilter
    CandidateTimeline?: CandidateTimelineListRelationFilter
    JobMailingTemplate?: JobMailingTemplateListRelationFilter
  }, "id">

  export type JobPostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    employmentType?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    remoteOption?: SortOrderInput | SortOrder
    countryResidence?: SortOrderInput | SortOrder
    countryListResidence?: SortOrder
    displaySalary?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    salaryAmount?: SortOrderInput | SortOrder
    minimumAmount?: SortOrderInput | SortOrder
    maximumAmount?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    isScheduled?: SortOrder
    isArchived?: SortOrder
    dateStart?: SortOrderInput | SortOrder
    dateEnd?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    _count?: JobPostCountOrderByAggregateInput
    _avg?: JobPostAvgOrderByAggregateInput
    _max?: JobPostMaxOrderByAggregateInput
    _min?: JobPostMinOrderByAggregateInput
    _sum?: JobPostSumOrderByAggregateInput
  }

  export type JobPostScalarWhereWithAggregatesInput = {
    AND?: JobPostScalarWhereWithAggregatesInput | JobPostScalarWhereWithAggregatesInput[]
    OR?: JobPostScalarWhereWithAggregatesInput[]
    NOT?: JobPostScalarWhereWithAggregatesInput | JobPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobPost"> | string
    title?: StringWithAggregatesFilter<"JobPost"> | string
    description?: StringNullableWithAggregatesFilter<"JobPost"> | string | null
    category?: StringNullableWithAggregatesFilter<"JobPost"> | string | null
    employmentType?: StringNullableWithAggregatesFilter<"JobPost"> | string | null
    country?: StringNullableWithAggregatesFilter<"JobPost"> | string | null
    city?: StringNullableWithAggregatesFilter<"JobPost"> | string | null
    remoteOption?: StringNullableWithAggregatesFilter<"JobPost"> | string | null
    countryResidence?: StringNullableWithAggregatesFilter<"JobPost"> | string | null
    countryListResidence?: StringNullableListFilter<"JobPost">
    displaySalary?: StringNullableWithAggregatesFilter<"JobPost"> | string | null
    currency?: StringNullableWithAggregatesFilter<"JobPost"> | string | null
    salaryAmount?: FloatNullableWithAggregatesFilter<"JobPost"> | number | null
    minimumAmount?: FloatNullableWithAggregatesFilter<"JobPost"> | number | null
    maximumAmount?: FloatNullableWithAggregatesFilter<"JobPost"> | number | null
    isPublished?: BoolWithAggregatesFilter<"JobPost"> | boolean
    isScheduled?: BoolWithAggregatesFilter<"JobPost"> | boolean
    isArchived?: BoolWithAggregatesFilter<"JobPost"> | boolean
    dateStart?: DateTimeNullableWithAggregatesFilter<"JobPost"> | Date | string | null
    dateEnd?: DateTimeNullableWithAggregatesFilter<"JobPost"> | Date | string | null
    organizationId?: StringWithAggregatesFilter<"JobPost"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JobPost"> | Date | string
  }

  export type JobApplicationWhereInput = {
    AND?: JobApplicationWhereInput | JobApplicationWhereInput[]
    OR?: JobApplicationWhereInput[]
    NOT?: JobApplicationWhereInput | JobApplicationWhereInput[]
    id?: StringFilter<"JobApplication"> | string
    label?: StringFilter<"JobApplication"> | string
    dataType?: StringFilter<"JobApplication"> | string
    option?: StringNullableListFilter<"JobApplication">
    rule?: StringFilter<"JobApplication"> | string
    questionType?: StringFilter<"JobApplication"> | string
    isDeleted?: BoolFilter<"JobApplication"> | boolean
    jobId?: StringFilter<"JobApplication"> | string
    createdAt?: DateTimeFilter<"JobApplication"> | Date | string
    jobPost?: XOR<JobPostRelationFilter, JobPostWhereInput>
    formResponse?: FormResponseListRelationFilter
  }

  export type JobApplicationOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    dataType?: SortOrder
    option?: SortOrder
    rule?: SortOrder
    questionType?: SortOrder
    isDeleted?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    jobPost?: JobPostOrderByWithRelationInput
    formResponse?: FormResponseOrderByRelationAggregateInput
  }

  export type JobApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobApplicationWhereInput | JobApplicationWhereInput[]
    OR?: JobApplicationWhereInput[]
    NOT?: JobApplicationWhereInput | JobApplicationWhereInput[]
    label?: StringFilter<"JobApplication"> | string
    dataType?: StringFilter<"JobApplication"> | string
    option?: StringNullableListFilter<"JobApplication">
    rule?: StringFilter<"JobApplication"> | string
    questionType?: StringFilter<"JobApplication"> | string
    isDeleted?: BoolFilter<"JobApplication"> | boolean
    jobId?: StringFilter<"JobApplication"> | string
    createdAt?: DateTimeFilter<"JobApplication"> | Date | string
    jobPost?: XOR<JobPostRelationFilter, JobPostWhereInput>
    formResponse?: FormResponseListRelationFilter
  }, "id">

  export type JobApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    dataType?: SortOrder
    option?: SortOrder
    rule?: SortOrder
    questionType?: SortOrder
    isDeleted?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    _count?: JobApplicationCountOrderByAggregateInput
    _max?: JobApplicationMaxOrderByAggregateInput
    _min?: JobApplicationMinOrderByAggregateInput
  }

  export type JobApplicationScalarWhereWithAggregatesInput = {
    AND?: JobApplicationScalarWhereWithAggregatesInput | JobApplicationScalarWhereWithAggregatesInput[]
    OR?: JobApplicationScalarWhereWithAggregatesInput[]
    NOT?: JobApplicationScalarWhereWithAggregatesInput | JobApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobApplication"> | string
    label?: StringWithAggregatesFilter<"JobApplication"> | string
    dataType?: StringWithAggregatesFilter<"JobApplication"> | string
    option?: StringNullableListFilter<"JobApplication">
    rule?: StringWithAggregatesFilter<"JobApplication"> | string
    questionType?: StringWithAggregatesFilter<"JobApplication"> | string
    isDeleted?: BoolWithAggregatesFilter<"JobApplication"> | boolean
    jobId?: StringWithAggregatesFilter<"JobApplication"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JobApplication"> | Date | string
  }

  export type CandidateApplicationWhereInput = {
    AND?: CandidateApplicationWhereInput | CandidateApplicationWhereInput[]
    OR?: CandidateApplicationWhereInput[]
    NOT?: CandidateApplicationWhereInput | CandidateApplicationWhereInput[]
    id?: StringFilter<"CandidateApplication"> | string
    jobId?: StringFilter<"CandidateApplication"> | string
    createdAt?: DateTimeFilter<"CandidateApplication"> | Date | string
    stageId?: StringFilter<"CandidateApplication"> | string
    jobPost?: XOR<JobPostRelationFilter, JobPostWhereInput>
    jobStage?: XOR<JobStageRelationFilter, JobStageWhereInput>
    formResponses?: FormResponseListRelationFilter
    emailMessage?: EmailMessageListRelationFilter
    CandidateTimeline?: CandidateTimelineListRelationFilter
  }

  export type CandidateApplicationOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    stageId?: SortOrder
    jobPost?: JobPostOrderByWithRelationInput
    jobStage?: JobStageOrderByWithRelationInput
    formResponses?: FormResponseOrderByRelationAggregateInput
    emailMessage?: EmailMessageOrderByRelationAggregateInput
    CandidateTimeline?: CandidateTimelineOrderByRelationAggregateInput
  }

  export type CandidateApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CandidateApplicationWhereInput | CandidateApplicationWhereInput[]
    OR?: CandidateApplicationWhereInput[]
    NOT?: CandidateApplicationWhereInput | CandidateApplicationWhereInput[]
    jobId?: StringFilter<"CandidateApplication"> | string
    createdAt?: DateTimeFilter<"CandidateApplication"> | Date | string
    stageId?: StringFilter<"CandidateApplication"> | string
    jobPost?: XOR<JobPostRelationFilter, JobPostWhereInput>
    jobStage?: XOR<JobStageRelationFilter, JobStageWhereInput>
    formResponses?: FormResponseListRelationFilter
    emailMessage?: EmailMessageListRelationFilter
    CandidateTimeline?: CandidateTimelineListRelationFilter
  }, "id">

  export type CandidateApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    stageId?: SortOrder
    _count?: CandidateApplicationCountOrderByAggregateInput
    _max?: CandidateApplicationMaxOrderByAggregateInput
    _min?: CandidateApplicationMinOrderByAggregateInput
  }

  export type CandidateApplicationScalarWhereWithAggregatesInput = {
    AND?: CandidateApplicationScalarWhereWithAggregatesInput | CandidateApplicationScalarWhereWithAggregatesInput[]
    OR?: CandidateApplicationScalarWhereWithAggregatesInput[]
    NOT?: CandidateApplicationScalarWhereWithAggregatesInput | CandidateApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CandidateApplication"> | string
    jobId?: StringWithAggregatesFilter<"CandidateApplication"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CandidateApplication"> | Date | string
    stageId?: StringWithAggregatesFilter<"CandidateApplication"> | string
  }

  export type CandidateReviewWhereInput = {
    AND?: CandidateReviewWhereInput | CandidateReviewWhereInput[]
    OR?: CandidateReviewWhereInput[]
    NOT?: CandidateReviewWhereInput | CandidateReviewWhereInput[]
    id?: StringFilter<"CandidateReview"> | string
    description?: StringNullableFilter<"CandidateReview"> | string | null
    verdict?: StringFilter<"CandidateReview"> | string
    createdAt?: DateTimeFilter<"CandidateReview"> | Date | string
    candidateTimeline?: CandidateTimelineListRelationFilter
  }

  export type CandidateReviewOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    verdict?: SortOrder
    createdAt?: SortOrder
    candidateTimeline?: CandidateTimelineOrderByRelationAggregateInput
  }

  export type CandidateReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CandidateReviewWhereInput | CandidateReviewWhereInput[]
    OR?: CandidateReviewWhereInput[]
    NOT?: CandidateReviewWhereInput | CandidateReviewWhereInput[]
    description?: StringNullableFilter<"CandidateReview"> | string | null
    verdict?: StringFilter<"CandidateReview"> | string
    createdAt?: DateTimeFilter<"CandidateReview"> | Date | string
    candidateTimeline?: CandidateTimelineListRelationFilter
  }, "id">

  export type CandidateReviewOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    verdict?: SortOrder
    createdAt?: SortOrder
    _count?: CandidateReviewCountOrderByAggregateInput
    _max?: CandidateReviewMaxOrderByAggregateInput
    _min?: CandidateReviewMinOrderByAggregateInput
  }

  export type CandidateReviewScalarWhereWithAggregatesInput = {
    AND?: CandidateReviewScalarWhereWithAggregatesInput | CandidateReviewScalarWhereWithAggregatesInput[]
    OR?: CandidateReviewScalarWhereWithAggregatesInput[]
    NOT?: CandidateReviewScalarWhereWithAggregatesInput | CandidateReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CandidateReview"> | string
    description?: StringNullableWithAggregatesFilter<"CandidateReview"> | string | null
    verdict?: StringWithAggregatesFilter<"CandidateReview"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CandidateReview"> | Date | string
  }

  export type CandidateTimelineWhereInput = {
    AND?: CandidateTimelineWhereInput | CandidateTimelineWhereInput[]
    OR?: CandidateTimelineWhereInput[]
    NOT?: CandidateTimelineWhereInput | CandidateTimelineWhereInput[]
    id?: StringFilter<"CandidateTimeline"> | string
    createdAt?: DateTimeFilter<"CandidateTimeline"> | Date | string
    userId?: StringNullableFilter<"CandidateTimeline"> | string | null
    actionType?: StringFilter<"CandidateTimeline"> | string
    jobId?: StringFilter<"CandidateTimeline"> | string
    timelineText?: StringFilter<"CandidateTimeline"> | string
    comment?: StringNullableFilter<"CandidateTimeline"> | string | null
    reviewId?: StringNullableFilter<"CandidateTimeline"> | string | null
    candidateId?: StringFilter<"CandidateTimeline"> | string
    candidateReview?: XOR<CandidateReviewNullableRelationFilter, CandidateReviewWhereInput> | null
    candidateApplication?: XOR<CandidateApplicationRelationFilter, CandidateApplicationWhereInput>
    jobPost?: XOR<JobPostRelationFilter, JobPostWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type CandidateTimelineOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    actionType?: SortOrder
    jobId?: SortOrder
    timelineText?: SortOrder
    comment?: SortOrderInput | SortOrder
    reviewId?: SortOrderInput | SortOrder
    candidateId?: SortOrder
    candidateReview?: CandidateReviewOrderByWithRelationInput
    candidateApplication?: CandidateApplicationOrderByWithRelationInput
    jobPost?: JobPostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CandidateTimelineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CandidateTimelineWhereInput | CandidateTimelineWhereInput[]
    OR?: CandidateTimelineWhereInput[]
    NOT?: CandidateTimelineWhereInput | CandidateTimelineWhereInput[]
    createdAt?: DateTimeFilter<"CandidateTimeline"> | Date | string
    userId?: StringNullableFilter<"CandidateTimeline"> | string | null
    actionType?: StringFilter<"CandidateTimeline"> | string
    jobId?: StringFilter<"CandidateTimeline"> | string
    timelineText?: StringFilter<"CandidateTimeline"> | string
    comment?: StringNullableFilter<"CandidateTimeline"> | string | null
    reviewId?: StringNullableFilter<"CandidateTimeline"> | string | null
    candidateId?: StringFilter<"CandidateTimeline"> | string
    candidateReview?: XOR<CandidateReviewNullableRelationFilter, CandidateReviewWhereInput> | null
    candidateApplication?: XOR<CandidateApplicationRelationFilter, CandidateApplicationWhereInput>
    jobPost?: XOR<JobPostRelationFilter, JobPostWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type CandidateTimelineOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    actionType?: SortOrder
    jobId?: SortOrder
    timelineText?: SortOrder
    comment?: SortOrderInput | SortOrder
    reviewId?: SortOrderInput | SortOrder
    candidateId?: SortOrder
    _count?: CandidateTimelineCountOrderByAggregateInput
    _max?: CandidateTimelineMaxOrderByAggregateInput
    _min?: CandidateTimelineMinOrderByAggregateInput
  }

  export type CandidateTimelineScalarWhereWithAggregatesInput = {
    AND?: CandidateTimelineScalarWhereWithAggregatesInput | CandidateTimelineScalarWhereWithAggregatesInput[]
    OR?: CandidateTimelineScalarWhereWithAggregatesInput[]
    NOT?: CandidateTimelineScalarWhereWithAggregatesInput | CandidateTimelineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CandidateTimeline"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CandidateTimeline"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"CandidateTimeline"> | string | null
    actionType?: StringWithAggregatesFilter<"CandidateTimeline"> | string
    jobId?: StringWithAggregatesFilter<"CandidateTimeline"> | string
    timelineText?: StringWithAggregatesFilter<"CandidateTimeline"> | string
    comment?: StringNullableWithAggregatesFilter<"CandidateTimeline"> | string | null
    reviewId?: StringNullableWithAggregatesFilter<"CandidateTimeline"> | string | null
    candidateId?: StringWithAggregatesFilter<"CandidateTimeline"> | string
  }

  export type FormResponseWhereInput = {
    AND?: FormResponseWhereInput | FormResponseWhereInput[]
    OR?: FormResponseWhereInput[]
    NOT?: FormResponseWhereInput | FormResponseWhereInput[]
    id?: StringFilter<"FormResponse"> | string
    candidateApplicationId?: StringFilter<"FormResponse"> | string
    jobApplicationId?: StringFilter<"FormResponse"> | string
    label?: StringFilter<"FormResponse"> | string
    value?: StringNullableFilter<"FormResponse"> | string | null
    createdAt?: DateTimeFilter<"FormResponse"> | Date | string
    candidateApplication?: XOR<CandidateApplicationRelationFilter, CandidateApplicationWhereInput>
    jobApplication?: XOR<JobApplicationRelationFilter, JobApplicationWhereInput>
  }

  export type FormResponseOrderByWithRelationInput = {
    id?: SortOrder
    candidateApplicationId?: SortOrder
    jobApplicationId?: SortOrder
    label?: SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    candidateApplication?: CandidateApplicationOrderByWithRelationInput
    jobApplication?: JobApplicationOrderByWithRelationInput
  }

  export type FormResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormResponseWhereInput | FormResponseWhereInput[]
    OR?: FormResponseWhereInput[]
    NOT?: FormResponseWhereInput | FormResponseWhereInput[]
    candidateApplicationId?: StringFilter<"FormResponse"> | string
    jobApplicationId?: StringFilter<"FormResponse"> | string
    label?: StringFilter<"FormResponse"> | string
    value?: StringNullableFilter<"FormResponse"> | string | null
    createdAt?: DateTimeFilter<"FormResponse"> | Date | string
    candidateApplication?: XOR<CandidateApplicationRelationFilter, CandidateApplicationWhereInput>
    jobApplication?: XOR<JobApplicationRelationFilter, JobApplicationWhereInput>
  }, "id">

  export type FormResponseOrderByWithAggregationInput = {
    id?: SortOrder
    candidateApplicationId?: SortOrder
    jobApplicationId?: SortOrder
    label?: SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FormResponseCountOrderByAggregateInput
    _max?: FormResponseMaxOrderByAggregateInput
    _min?: FormResponseMinOrderByAggregateInput
  }

  export type FormResponseScalarWhereWithAggregatesInput = {
    AND?: FormResponseScalarWhereWithAggregatesInput | FormResponseScalarWhereWithAggregatesInput[]
    OR?: FormResponseScalarWhereWithAggregatesInput[]
    NOT?: FormResponseScalarWhereWithAggregatesInput | FormResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormResponse"> | string
    candidateApplicationId?: StringWithAggregatesFilter<"FormResponse"> | string
    jobApplicationId?: StringWithAggregatesFilter<"FormResponse"> | string
    label?: StringWithAggregatesFilter<"FormResponse"> | string
    value?: StringNullableWithAggregatesFilter<"FormResponse"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FormResponse"> | Date | string
  }

  export type JobPreviewWhereInput = {
    AND?: JobPreviewWhereInput | JobPreviewWhereInput[]
    OR?: JobPreviewWhereInput[]
    NOT?: JobPreviewWhereInput | JobPreviewWhereInput[]
    id?: StringFilter<"JobPreview"> | string
    createdAt?: DateTimeFilter<"JobPreview"> | Date | string
    expiresAt?: DateTimeFilter<"JobPreview"> | Date | string
    isExpired?: BoolFilter<"JobPreview"> | boolean
    organizationId?: StringNullableFilter<"JobPreview"> | string | null
    jobId?: StringFilter<"JobPreview"> | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    jobPost?: XOR<JobPostRelationFilter, JobPostWhereInput>
  }

  export type JobPreviewOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    isExpired?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    jobId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    jobPost?: JobPostOrderByWithRelationInput
  }

  export type JobPreviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobPreviewWhereInput | JobPreviewWhereInput[]
    OR?: JobPreviewWhereInput[]
    NOT?: JobPreviewWhereInput | JobPreviewWhereInput[]
    createdAt?: DateTimeFilter<"JobPreview"> | Date | string
    expiresAt?: DateTimeFilter<"JobPreview"> | Date | string
    isExpired?: BoolFilter<"JobPreview"> | boolean
    organizationId?: StringNullableFilter<"JobPreview"> | string | null
    jobId?: StringFilter<"JobPreview"> | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    jobPost?: XOR<JobPostRelationFilter, JobPostWhereInput>
  }, "id">

  export type JobPreviewOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    isExpired?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    jobId?: SortOrder
    _count?: JobPreviewCountOrderByAggregateInput
    _max?: JobPreviewMaxOrderByAggregateInput
    _min?: JobPreviewMinOrderByAggregateInput
  }

  export type JobPreviewScalarWhereWithAggregatesInput = {
    AND?: JobPreviewScalarWhereWithAggregatesInput | JobPreviewScalarWhereWithAggregatesInput[]
    OR?: JobPreviewScalarWhereWithAggregatesInput[]
    NOT?: JobPreviewScalarWhereWithAggregatesInput | JobPreviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobPreview"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JobPreview"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"JobPreview"> | Date | string
    isExpired?: BoolWithAggregatesFilter<"JobPreview"> | boolean
    organizationId?: StringNullableWithAggregatesFilter<"JobPreview"> | string | null
    jobId?: StringWithAggregatesFilter<"JobPreview"> | string
  }

  export type JobStageWhereInput = {
    AND?: JobStageWhereInput | JobStageWhereInput[]
    OR?: JobStageWhereInput[]
    NOT?: JobStageWhereInput | JobStageWhereInput[]
    id?: StringFilter<"JobStage"> | string
    name?: StringFilter<"JobStage"> | string
    isDeletable?: BoolFilter<"JobStage"> | boolean
    isDeleted?: BoolFilter<"JobStage"> | boolean
    displayOrder?: IntFilter<"JobStage"> | number
    jobId?: StringFilter<"JobStage"> | string
    createdAt?: DateTimeFilter<"JobStage"> | Date | string
    jobPost?: XOR<JobPostRelationFilter, JobPostWhereInput>
    candidateStage?: CandidateApplicationListRelationFilter
  }

  export type JobStageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isDeletable?: SortOrder
    isDeleted?: SortOrder
    displayOrder?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    jobPost?: JobPostOrderByWithRelationInput
    candidateStage?: CandidateApplicationOrderByRelationAggregateInput
  }

  export type JobStageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobStageWhereInput | JobStageWhereInput[]
    OR?: JobStageWhereInput[]
    NOT?: JobStageWhereInput | JobStageWhereInput[]
    name?: StringFilter<"JobStage"> | string
    isDeletable?: BoolFilter<"JobStage"> | boolean
    isDeleted?: BoolFilter<"JobStage"> | boolean
    displayOrder?: IntFilter<"JobStage"> | number
    jobId?: StringFilter<"JobStage"> | string
    createdAt?: DateTimeFilter<"JobStage"> | Date | string
    jobPost?: XOR<JobPostRelationFilter, JobPostWhereInput>
    candidateStage?: CandidateApplicationListRelationFilter
  }, "id">

  export type JobStageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isDeletable?: SortOrder
    isDeleted?: SortOrder
    displayOrder?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    _count?: JobStageCountOrderByAggregateInput
    _avg?: JobStageAvgOrderByAggregateInput
    _max?: JobStageMaxOrderByAggregateInput
    _min?: JobStageMinOrderByAggregateInput
    _sum?: JobStageSumOrderByAggregateInput
  }

  export type JobStageScalarWhereWithAggregatesInput = {
    AND?: JobStageScalarWhereWithAggregatesInput | JobStageScalarWhereWithAggregatesInput[]
    OR?: JobStageScalarWhereWithAggregatesInput[]
    NOT?: JobStageScalarWhereWithAggregatesInput | JobStageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobStage"> | string
    name?: StringWithAggregatesFilter<"JobStage"> | string
    isDeletable?: BoolWithAggregatesFilter<"JobStage"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"JobStage"> | boolean
    displayOrder?: IntWithAggregatesFilter<"JobStage"> | number
    jobId?: StringWithAggregatesFilter<"JobStage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JobStage"> | Date | string
  }

  export type JobMailingTemplateWhereInput = {
    AND?: JobMailingTemplateWhereInput | JobMailingTemplateWhereInput[]
    OR?: JobMailingTemplateWhereInput[]
    NOT?: JobMailingTemplateWhereInput | JobMailingTemplateWhereInput[]
    id?: StringFilter<"JobMailingTemplate"> | string
    name?: StringFilter<"JobMailingTemplate"> | string
    subject?: StringFilter<"JobMailingTemplate"> | string
    body?: StringFilter<"JobMailingTemplate"> | string
    createdAt?: DateTimeFilter<"JobMailingTemplate"> | Date | string
    jobId?: StringFilter<"JobMailingTemplate"> | string
    jobPost?: XOR<JobPostRelationFilter, JobPostWhereInput>
  }

  export type JobMailingTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    jobId?: SortOrder
    jobPost?: JobPostOrderByWithRelationInput
  }

  export type JobMailingTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobMailingTemplateWhereInput | JobMailingTemplateWhereInput[]
    OR?: JobMailingTemplateWhereInput[]
    NOT?: JobMailingTemplateWhereInput | JobMailingTemplateWhereInput[]
    name?: StringFilter<"JobMailingTemplate"> | string
    subject?: StringFilter<"JobMailingTemplate"> | string
    body?: StringFilter<"JobMailingTemplate"> | string
    createdAt?: DateTimeFilter<"JobMailingTemplate"> | Date | string
    jobId?: StringFilter<"JobMailingTemplate"> | string
    jobPost?: XOR<JobPostRelationFilter, JobPostWhereInput>
  }, "id">

  export type JobMailingTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    jobId?: SortOrder
    _count?: JobMailingTemplateCountOrderByAggregateInput
    _max?: JobMailingTemplateMaxOrderByAggregateInput
    _min?: JobMailingTemplateMinOrderByAggregateInput
  }

  export type JobMailingTemplateScalarWhereWithAggregatesInput = {
    AND?: JobMailingTemplateScalarWhereWithAggregatesInput | JobMailingTemplateScalarWhereWithAggregatesInput[]
    OR?: JobMailingTemplateScalarWhereWithAggregatesInput[]
    NOT?: JobMailingTemplateScalarWhereWithAggregatesInput | JobMailingTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobMailingTemplate"> | string
    name?: StringWithAggregatesFilter<"JobMailingTemplate"> | string
    subject?: StringWithAggregatesFilter<"JobMailingTemplate"> | string
    body?: StringWithAggregatesFilter<"JobMailingTemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JobMailingTemplate"> | Date | string
    jobId?: StringWithAggregatesFilter<"JobMailingTemplate"> | string
  }

  export type EmailMessageWhereInput = {
    AND?: EmailMessageWhereInput | EmailMessageWhereInput[]
    OR?: EmailMessageWhereInput[]
    NOT?: EmailMessageWhereInput | EmailMessageWhereInput[]
    id?: StringFilter<"EmailMessage"> | string
    messageId?: StringFilter<"EmailMessage"> | string
    parentMessageId?: StringNullableFilter<"EmailMessage"> | string | null
    sender?: StringFilter<"EmailMessage"> | string
    recipient?: StringFilter<"EmailMessage"> | string
    subject?: StringFilter<"EmailMessage"> | string
    body?: StringFilter<"EmailMessage"> | string
    s3Url?: StringNullableFilter<"EmailMessage"> | string | null
    direction?: EnumEmailDirectionFilter<"EmailMessage"> | $Enums.EmailDirection
    createdAt?: DateTimeFilter<"EmailMessage"> | Date | string
    userId?: StringFilter<"EmailMessage"> | string
    candidateId?: StringFilter<"EmailMessage"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    candidate?: XOR<CandidateApplicationRelationFilter, CandidateApplicationWhereInput>
    parentMessage?: XOR<EmailMessageNullableRelationFilter, EmailMessageWhereInput> | null
    replies?: EmailMessageListRelationFilter
  }

  export type EmailMessageOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    parentMessageId?: SortOrderInput | SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    s3Url?: SortOrderInput | SortOrder
    direction?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    candidateId?: SortOrder
    user?: UserOrderByWithRelationInput
    candidate?: CandidateApplicationOrderByWithRelationInput
    parentMessage?: EmailMessageOrderByWithRelationInput
    replies?: EmailMessageOrderByRelationAggregateInput
  }

  export type EmailMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId?: string
    parentMessageId?: string
    AND?: EmailMessageWhereInput | EmailMessageWhereInput[]
    OR?: EmailMessageWhereInput[]
    NOT?: EmailMessageWhereInput | EmailMessageWhereInput[]
    sender?: StringFilter<"EmailMessage"> | string
    recipient?: StringFilter<"EmailMessage"> | string
    subject?: StringFilter<"EmailMessage"> | string
    body?: StringFilter<"EmailMessage"> | string
    s3Url?: StringNullableFilter<"EmailMessage"> | string | null
    direction?: EnumEmailDirectionFilter<"EmailMessage"> | $Enums.EmailDirection
    createdAt?: DateTimeFilter<"EmailMessage"> | Date | string
    userId?: StringFilter<"EmailMessage"> | string
    candidateId?: StringFilter<"EmailMessage"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    candidate?: XOR<CandidateApplicationRelationFilter, CandidateApplicationWhereInput>
    parentMessage?: XOR<EmailMessageNullableRelationFilter, EmailMessageWhereInput> | null
    replies?: EmailMessageListRelationFilter
  }, "id" | "messageId" | "parentMessageId">

  export type EmailMessageOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    parentMessageId?: SortOrderInput | SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    s3Url?: SortOrderInput | SortOrder
    direction?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    candidateId?: SortOrder
    _count?: EmailMessageCountOrderByAggregateInput
    _max?: EmailMessageMaxOrderByAggregateInput
    _min?: EmailMessageMinOrderByAggregateInput
  }

  export type EmailMessageScalarWhereWithAggregatesInput = {
    AND?: EmailMessageScalarWhereWithAggregatesInput | EmailMessageScalarWhereWithAggregatesInput[]
    OR?: EmailMessageScalarWhereWithAggregatesInput[]
    NOT?: EmailMessageScalarWhereWithAggregatesInput | EmailMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailMessage"> | string
    messageId?: StringWithAggregatesFilter<"EmailMessage"> | string
    parentMessageId?: StringNullableWithAggregatesFilter<"EmailMessage"> | string | null
    sender?: StringWithAggregatesFilter<"EmailMessage"> | string
    recipient?: StringWithAggregatesFilter<"EmailMessage"> | string
    subject?: StringWithAggregatesFilter<"EmailMessage"> | string
    body?: StringWithAggregatesFilter<"EmailMessage"> | string
    s3Url?: StringNullableWithAggregatesFilter<"EmailMessage"> | string | null
    direction?: EnumEmailDirectionWithAggregatesFilter<"EmailMessage"> | $Enums.EmailDirection
    createdAt?: DateTimeWithAggregatesFilter<"EmailMessage"> | Date | string
    userId?: StringWithAggregatesFilter<"EmailMessage"> | string
    candidateId?: StringWithAggregatesFilter<"EmailMessage"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    type?: StringFilter<"Notification"> | string
    category?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    priority?: StringFilter<"Notification"> | string
    metadata?: JsonNullableFilter<"Notification">
    userId?: StringNullableFilter<"Notification"> | string | null
    organizationId?: StringNullableFilter<"Notification"> | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    receipts?: NotificationReceiptListRelationFilter
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    category?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    priority?: SortOrder
    metadata?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    organizationId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    receipts?: NotificationReceiptOrderByRelationAggregateInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    message?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    type?: StringFilter<"Notification"> | string
    category?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    priority?: StringFilter<"Notification"> | string
    metadata?: JsonNullableFilter<"Notification">
    userId?: StringNullableFilter<"Notification"> | string | null
    organizationId?: StringNullableFilter<"Notification"> | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    receipts?: NotificationReceiptListRelationFilter
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    category?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    priority?: SortOrder
    metadata?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    organizationId?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    category?: StringWithAggregatesFilter<"Notification"> | string
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    priority?: StringWithAggregatesFilter<"Notification"> | string
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    userId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    organizationId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
  }

  export type NotificationReceiptWhereInput = {
    AND?: NotificationReceiptWhereInput | NotificationReceiptWhereInput[]
    OR?: NotificationReceiptWhereInput[]
    NOT?: NotificationReceiptWhereInput | NotificationReceiptWhereInput[]
    id?: StringFilter<"NotificationReceipt"> | string
    notificationId?: StringFilter<"NotificationReceipt"> | string
    userId?: StringFilter<"NotificationReceipt"> | string
    isRead?: BoolFilter<"NotificationReceipt"> | boolean
    readAt?: DateTimeNullableFilter<"NotificationReceipt"> | Date | string | null
    notification?: XOR<NotificationRelationFilter, NotificationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationReceiptOrderByWithRelationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    notification?: NotificationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NotificationReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationReceiptWhereInput | NotificationReceiptWhereInput[]
    OR?: NotificationReceiptWhereInput[]
    NOT?: NotificationReceiptWhereInput | NotificationReceiptWhereInput[]
    notificationId?: StringFilter<"NotificationReceipt"> | string
    userId?: StringFilter<"NotificationReceipt"> | string
    isRead?: BoolFilter<"NotificationReceipt"> | boolean
    readAt?: DateTimeNullableFilter<"NotificationReceipt"> | Date | string | null
    notification?: XOR<NotificationRelationFilter, NotificationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    _count?: NotificationReceiptCountOrderByAggregateInput
    _max?: NotificationReceiptMaxOrderByAggregateInput
    _min?: NotificationReceiptMinOrderByAggregateInput
  }

  export type NotificationReceiptScalarWhereWithAggregatesInput = {
    AND?: NotificationReceiptScalarWhereWithAggregatesInput | NotificationReceiptScalarWhereWithAggregatesInput[]
    OR?: NotificationReceiptScalarWhereWithAggregatesInput[]
    NOT?: NotificationReceiptScalarWhereWithAggregatesInput | NotificationReceiptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationReceipt"> | string
    notificationId?: StringWithAggregatesFilter<"NotificationReceipt"> | string
    userId?: StringWithAggregatesFilter<"NotificationReceipt"> | string
    isRead?: BoolWithAggregatesFilter<"NotificationReceipt"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"NotificationReceipt"> | Date | string | null
  }

  export type OrganizationUserRoleCreateInput = {
    id?: string
    role: $Enums.OrganizationRole
    email: string
    status?: string
    createdAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutOrganizationRoleInput
    user?: UserCreateNestedOneWithoutOrganizationsInput
  }

  export type OrganizationUserRoleUncheckedCreateInput = {
    id?: string
    role: $Enums.OrganizationRole
    organizationId: string
    email: string
    userId?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type OrganizationUserRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutOrganizationRoleNestedInput
    user?: UserUpdateOneWithoutOrganizationsNestedInput
  }

  export type OrganizationUserRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUserRoleCreateManyInput = {
    id?: string
    role: $Enums.OrganizationRole
    organizationId: string
    email: string
    userId?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type OrganizationUserRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUserRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizations?: OrganizationUserRoleCreateNestedManyWithoutUserInput
    twoFactorConfirmation?: TwoFactorConfirmationCreateNestedOneWithoutUserInput
    candidateTimeline?: CandidateTimelineCreateNestedManyWithoutUserInput
    emailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    organizationSubscription?: OrganizationSubscriptionCreateNestedManyWithoutUserInput
    NotificationReceipt?: NotificationReceiptCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationUserRoleUncheckedCreateNestedManyWithoutUserInput
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInput
    candidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutUserInput
    emailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    organizationSubscription?: OrganizationSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationReceipt?: NotificationReceiptUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizations?: OrganizationUserRoleUpdateManyWithoutUserNestedInput
    twoFactorConfirmation?: TwoFactorConfirmationUpdateOneWithoutUserNestedInput
    candidateTimeline?: CandidateTimelineUpdateManyWithoutUserNestedInput
    emailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    organizationSubscription?: OrganizationSubscriptionUpdateManyWithoutUserNestedInput
    NotificationReceipt?: NotificationReceiptUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationUserRoleUncheckedUpdateManyWithoutUserNestedInput
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInput
    candidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutUserNestedInput
    emailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    organizationSubscription?: OrganizationSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationReceipt?: NotificationReceiptUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerificationTokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorTokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type TwoFactorTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type TwoFactorTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type TwoFactorTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorConfirmationCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutTwoFactorConfirmationInput
  }

  export type TwoFactorConfirmationUncheckedCreateInput = {
    id?: string
    userId: string
  }

  export type TwoFactorConfirmationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutTwoFactorConfirmationNestedInput
  }

  export type TwoFactorConfirmationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TwoFactorConfirmationCreateManyInput = {
    id?: string
    userId: string
  }

  export type TwoFactorConfirmationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TwoFactorConfirmationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    url?: string | null
    logo?: string | null
    assignedDomain?: string | null
    customDomain?: string | null
    createdAt?: Date | string
    organizationRole?: OrganizationUserRoleCreateNestedManyWithoutOrganizationInput
    organizationActionLog?: OrganizationActivityLogCreateNestedManyWithoutOrganizationInput
    jobPost?: JobPostCreateNestedManyWithoutOrganizationInput
    payment?: PaymentCreateNestedManyWithoutOrganizationInput
    jobPreview?: JobPreviewCreateNestedManyWithoutOrganizationInput
    organizationSubscription?: OrganizationSubscriptionCreateNestedManyWithoutOrganizationInput
    Notification?: NotificationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    url?: string | null
    logo?: string | null
    assignedDomain?: string | null
    customDomain?: string | null
    createdAt?: Date | string
    organizationRole?: OrganizationUserRoleUncheckedCreateNestedManyWithoutOrganizationInput
    organizationActionLog?: OrganizationActivityLogUncheckedCreateNestedManyWithoutOrganizationInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutOrganizationInput
    payment?: PaymentUncheckedCreateNestedManyWithoutOrganizationInput
    jobPreview?: JobPreviewUncheckedCreateNestedManyWithoutOrganizationInput
    organizationSubscription?: OrganizationSubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationRole?: OrganizationUserRoleUpdateManyWithoutOrganizationNestedInput
    organizationActionLog?: OrganizationActivityLogUpdateManyWithoutOrganizationNestedInput
    jobPost?: JobPostUpdateManyWithoutOrganizationNestedInput
    payment?: PaymentUpdateManyWithoutOrganizationNestedInput
    jobPreview?: JobPreviewUpdateManyWithoutOrganizationNestedInput
    organizationSubscription?: OrganizationSubscriptionUpdateManyWithoutOrganizationNestedInput
    Notification?: NotificationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationRole?: OrganizationUserRoleUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationActionLog?: OrganizationActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutOrganizationNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    jobPreview?: JobPreviewUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationSubscription?: OrganizationSubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    url?: string | null
    logo?: string | null
    assignedDomain?: string | null
    customDomain?: string | null
    createdAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationSubscriptionCreateInput = {
    id?: string
    referalId?: string | null
    paymentHandler: string
    status?: $Enums.SubscriptionStatus
    subscriptionType: string
    createdAt?: Date | string
    expiresOn: Date | string
    organization: OrganizationCreateNestedOneWithoutOrganizationSubscriptionInput
    user: UserCreateNestedOneWithoutOrganizationSubscriptionInput
  }

  export type OrganizationSubscriptionUncheckedCreateInput = {
    id?: string
    referalId?: string | null
    paymentHandler: string
    organizationId: string
    status?: $Enums.SubscriptionStatus
    subscriptionType: string
    userId: string
    createdAt?: Date | string
    expiresOn: Date | string
  }

  export type OrganizationSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentHandler?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutOrganizationSubscriptionNestedInput
    user?: UserUpdateOneRequiredWithoutOrganizationSubscriptionNestedInput
  }

  export type OrganizationSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentHandler?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationSubscriptionCreateManyInput = {
    id?: string
    referalId?: string | null
    paymentHandler: string
    organizationId: string
    status?: $Enums.SubscriptionStatus
    subscriptionType: string
    userId: string
    createdAt?: Date | string
    expiresOn: Date | string
  }

  export type OrganizationSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentHandler?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentHandler?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    paddlePaymentId: string
    amount: number
    currency: string
    status: $Enums.PaymentStatus
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    organizationId: string
    paddlePaymentId: string
    amount: number
    currency: string
    status: $Enums.PaymentStatus
    createdAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paddlePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    paddlePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    organizationId: string
    paddlePaymentId: string
    amount: number
    currency: string
    status: $Enums.PaymentStatus
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paddlePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    paddlePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationActivityLogCreateInput = {
    id?: string
    action: string
    createdAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutOrganizationActionLogInput
  }

  export type OrganizationActivityLogUncheckedCreateInput = {
    id?: string
    action: string
    organizationId: string
    createdAt?: Date | string
  }

  export type OrganizationActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutOrganizationActionLogNestedInput
  }

  export type OrganizationActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationActivityLogCreateManyInput = {
    id?: string
    action: string
    organizationId: string
    createdAt?: Date | string
  }

  export type OrganizationActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPostCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutJobPostInput
    jobApplication?: JobApplicationCreateNestedManyWithoutJobPostInput
    jobStage?: JobStageCreateNestedManyWithoutJobPostInput
    jobPreview?: JobPreviewCreateNestedManyWithoutJobPostInput
    candidateApplication?: CandidateApplicationCreateNestedManyWithoutJobPostInput
    CandidateTimeline?: CandidateTimelineCreateNestedManyWithoutJobPostInput
    JobMailingTemplate?: JobMailingTemplateCreateNestedManyWithoutJobPostInput
  }

  export type JobPostUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    organizationId: string
    createdAt?: Date | string
    jobApplication?: JobApplicationUncheckedCreateNestedManyWithoutJobPostInput
    jobStage?: JobStageUncheckedCreateNestedManyWithoutJobPostInput
    jobPreview?: JobPreviewUncheckedCreateNestedManyWithoutJobPostInput
    candidateApplication?: CandidateApplicationUncheckedCreateNestedManyWithoutJobPostInput
    CandidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutJobPostInput
    JobMailingTemplate?: JobMailingTemplateUncheckedCreateNestedManyWithoutJobPostInput
  }

  export type JobPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutJobPostNestedInput
    jobApplication?: JobApplicationUpdateManyWithoutJobPostNestedInput
    jobStage?: JobStageUpdateManyWithoutJobPostNestedInput
    jobPreview?: JobPreviewUpdateManyWithoutJobPostNestedInput
    candidateApplication?: CandidateApplicationUpdateManyWithoutJobPostNestedInput
    CandidateTimeline?: CandidateTimelineUpdateManyWithoutJobPostNestedInput
    JobMailingTemplate?: JobMailingTemplateUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobApplication?: JobApplicationUncheckedUpdateManyWithoutJobPostNestedInput
    jobStage?: JobStageUncheckedUpdateManyWithoutJobPostNestedInput
    jobPreview?: JobPreviewUncheckedUpdateManyWithoutJobPostNestedInput
    candidateApplication?: CandidateApplicationUncheckedUpdateManyWithoutJobPostNestedInput
    CandidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutJobPostNestedInput
    JobMailingTemplate?: JobMailingTemplateUncheckedUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    organizationId: string
    createdAt?: Date | string
  }

  export type JobPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationCreateInput = {
    id?: string
    label: string
    dataType: string
    option?: JobApplicationCreateoptionInput | string[]
    rule?: string
    questionType?: string
    isDeleted?: boolean
    createdAt?: Date | string
    jobPost: JobPostCreateNestedOneWithoutJobApplicationInput
    formResponse?: FormResponseCreateNestedManyWithoutJobApplicationInput
  }

  export type JobApplicationUncheckedCreateInput = {
    id?: string
    label: string
    dataType: string
    option?: JobApplicationCreateoptionInput | string[]
    rule?: string
    questionType?: string
    isDeleted?: boolean
    jobId: string
    createdAt?: Date | string
    formResponse?: FormResponseUncheckedCreateNestedManyWithoutJobApplicationInput
  }

  export type JobApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    option?: JobApplicationUpdateoptionInput | string[]
    rule?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobPost?: JobPostUpdateOneRequiredWithoutJobApplicationNestedInput
    formResponse?: FormResponseUpdateManyWithoutJobApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    option?: JobApplicationUpdateoptionInput | string[]
    rule?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formResponse?: FormResponseUncheckedUpdateManyWithoutJobApplicationNestedInput
  }

  export type JobApplicationCreateManyInput = {
    id?: string
    label: string
    dataType: string
    option?: JobApplicationCreateoptionInput | string[]
    rule?: string
    questionType?: string
    isDeleted?: boolean
    jobId: string
    createdAt?: Date | string
  }

  export type JobApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    option?: JobApplicationUpdateoptionInput | string[]
    rule?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    option?: JobApplicationUpdateoptionInput | string[]
    rule?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidateApplicationCreateInput = {
    id?: string
    createdAt?: Date | string
    jobPost: JobPostCreateNestedOneWithoutCandidateApplicationInput
    jobStage: JobStageCreateNestedOneWithoutCandidateStageInput
    formResponses?: FormResponseCreateNestedManyWithoutCandidateApplicationInput
    emailMessage?: EmailMessageCreateNestedManyWithoutCandidateInput
    CandidateTimeline?: CandidateTimelineCreateNestedManyWithoutCandidateApplicationInput
  }

  export type CandidateApplicationUncheckedCreateInput = {
    id?: string
    jobId: string
    createdAt?: Date | string
    stageId: string
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutCandidateApplicationInput
    emailMessage?: EmailMessageUncheckedCreateNestedManyWithoutCandidateInput
    CandidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutCandidateApplicationInput
  }

  export type CandidateApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobPost?: JobPostUpdateOneRequiredWithoutCandidateApplicationNestedInput
    jobStage?: JobStageUpdateOneRequiredWithoutCandidateStageNestedInput
    formResponses?: FormResponseUpdateManyWithoutCandidateApplicationNestedInput
    emailMessage?: EmailMessageUpdateManyWithoutCandidateNestedInput
    CandidateTimeline?: CandidateTimelineUpdateManyWithoutCandidateApplicationNestedInput
  }

  export type CandidateApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stageId?: StringFieldUpdateOperationsInput | string
    formResponses?: FormResponseUncheckedUpdateManyWithoutCandidateApplicationNestedInput
    emailMessage?: EmailMessageUncheckedUpdateManyWithoutCandidateNestedInput
    CandidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutCandidateApplicationNestedInput
  }

  export type CandidateApplicationCreateManyInput = {
    id?: string
    jobId: string
    createdAt?: Date | string
    stageId: string
  }

  export type CandidateApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidateApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stageId?: StringFieldUpdateOperationsInput | string
  }

  export type CandidateReviewCreateInput = {
    id?: string
    description?: string | null
    verdict: string
    createdAt?: Date | string
    candidateTimeline?: CandidateTimelineCreateNestedManyWithoutCandidateReviewInput
  }

  export type CandidateReviewUncheckedCreateInput = {
    id?: string
    description?: string | null
    verdict: string
    createdAt?: Date | string
    candidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutCandidateReviewInput
  }

  export type CandidateReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verdict?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidateTimeline?: CandidateTimelineUpdateManyWithoutCandidateReviewNestedInput
  }

  export type CandidateReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verdict?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutCandidateReviewNestedInput
  }

  export type CandidateReviewCreateManyInput = {
    id?: string
    description?: string | null
    verdict: string
    createdAt?: Date | string
  }

  export type CandidateReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verdict?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidateReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verdict?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidateTimelineCreateInput = {
    id?: string
    createdAt?: Date | string
    actionType: string
    timelineText: string
    comment?: string | null
    candidateReview?: CandidateReviewCreateNestedOneWithoutCandidateTimelineInput
    candidateApplication: CandidateApplicationCreateNestedOneWithoutCandidateTimelineInput
    jobPost: JobPostCreateNestedOneWithoutCandidateTimelineInput
    user?: UserCreateNestedOneWithoutCandidateTimelineInput
  }

  export type CandidateTimelineUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    userId?: string | null
    actionType: string
    jobId: string
    timelineText: string
    comment?: string | null
    reviewId?: string | null
    candidateId: string
  }

  export type CandidateTimelineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionType?: StringFieldUpdateOperationsInput | string
    timelineText?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    candidateReview?: CandidateReviewUpdateOneWithoutCandidateTimelineNestedInput
    candidateApplication?: CandidateApplicationUpdateOneRequiredWithoutCandidateTimelineNestedInput
    jobPost?: JobPostUpdateOneRequiredWithoutCandidateTimelineNestedInput
    user?: UserUpdateOneWithoutCandidateTimelineNestedInput
  }

  export type CandidateTimelineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    timelineText?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateId?: StringFieldUpdateOperationsInput | string
  }

  export type CandidateTimelineCreateManyInput = {
    id?: string
    createdAt?: Date | string
    userId?: string | null
    actionType: string
    jobId: string
    timelineText: string
    comment?: string | null
    reviewId?: string | null
    candidateId: string
  }

  export type CandidateTimelineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionType?: StringFieldUpdateOperationsInput | string
    timelineText?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CandidateTimelineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    timelineText?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateId?: StringFieldUpdateOperationsInput | string
  }

  export type FormResponseCreateInput = {
    id?: string
    label: string
    value?: string | null
    createdAt?: Date | string
    candidateApplication: CandidateApplicationCreateNestedOneWithoutFormResponsesInput
    jobApplication: JobApplicationCreateNestedOneWithoutFormResponseInput
  }

  export type FormResponseUncheckedCreateInput = {
    id?: string
    candidateApplicationId: string
    jobApplicationId: string
    label: string
    value?: string | null
    createdAt?: Date | string
  }

  export type FormResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidateApplication?: CandidateApplicationUpdateOneRequiredWithoutFormResponsesNestedInput
    jobApplication?: JobApplicationUpdateOneRequiredWithoutFormResponseNestedInput
  }

  export type FormResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    candidateApplicationId?: StringFieldUpdateOperationsInput | string
    jobApplicationId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseCreateManyInput = {
    id?: string
    candidateApplicationId: string
    jobApplicationId: string
    label: string
    value?: string | null
    createdAt?: Date | string
  }

  export type FormResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    candidateApplicationId?: StringFieldUpdateOperationsInput | string
    jobApplicationId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPreviewCreateInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    isExpired?: boolean
    organization?: OrganizationCreateNestedOneWithoutJobPreviewInput
    jobPost: JobPostCreateNestedOneWithoutJobPreviewInput
  }

  export type JobPreviewUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    isExpired?: boolean
    organizationId?: string | null
    jobId: string
  }

  export type JobPreviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneWithoutJobPreviewNestedInput
    jobPost?: JobPostUpdateOneRequiredWithoutJobPreviewNestedInput
  }

  export type JobPreviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: StringFieldUpdateOperationsInput | string
  }

  export type JobPreviewCreateManyInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    isExpired?: boolean
    organizationId?: string | null
    jobId: string
  }

  export type JobPreviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isExpired?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JobPreviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: StringFieldUpdateOperationsInput | string
  }

  export type JobStageCreateInput = {
    id?: string
    name: string
    isDeletable?: boolean
    isDeleted?: boolean
    displayOrder: number
    createdAt?: Date | string
    jobPost: JobPostCreateNestedOneWithoutJobStageInput
    candidateStage?: CandidateApplicationCreateNestedManyWithoutJobStageInput
  }

  export type JobStageUncheckedCreateInput = {
    id?: string
    name: string
    isDeletable?: boolean
    isDeleted?: boolean
    displayOrder: number
    jobId: string
    createdAt?: Date | string
    candidateStage?: CandidateApplicationUncheckedCreateNestedManyWithoutJobStageInput
  }

  export type JobStageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeletable?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobPost?: JobPostUpdateOneRequiredWithoutJobStageNestedInput
    candidateStage?: CandidateApplicationUpdateManyWithoutJobStageNestedInput
  }

  export type JobStageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeletable?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidateStage?: CandidateApplicationUncheckedUpdateManyWithoutJobStageNestedInput
  }

  export type JobStageCreateManyInput = {
    id?: string
    name: string
    isDeletable?: boolean
    isDeleted?: boolean
    displayOrder: number
    jobId: string
    createdAt?: Date | string
  }

  export type JobStageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeletable?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobStageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeletable?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobMailingTemplateCreateInput = {
    id?: string
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    jobPost: JobPostCreateNestedOneWithoutJobMailingTemplateInput
  }

  export type JobMailingTemplateUncheckedCreateInput = {
    id?: string
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    jobId: string
  }

  export type JobMailingTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobPost?: JobPostUpdateOneRequiredWithoutJobMailingTemplateNestedInput
  }

  export type JobMailingTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: StringFieldUpdateOperationsInput | string
  }

  export type JobMailingTemplateCreateManyInput = {
    id?: string
    name: string
    subject: string
    body: string
    createdAt?: Date | string
    jobId: string
  }

  export type JobMailingTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobMailingTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailMessageCreateInput = {
    id?: string
    messageId: string
    sender: string
    recipient: string
    subject: string
    body: string
    s3Url?: string | null
    direction: $Enums.EmailDirection
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEmailMessageInput
    candidate: CandidateApplicationCreateNestedOneWithoutEmailMessageInput
    parentMessage?: EmailMessageCreateNestedOneWithoutRepliesInput
    replies?: EmailMessageCreateNestedManyWithoutParentMessageInput
  }

  export type EmailMessageUncheckedCreateInput = {
    id?: string
    messageId: string
    parentMessageId?: string | null
    sender: string
    recipient: string
    subject: string
    body: string
    s3Url?: string | null
    direction: $Enums.EmailDirection
    createdAt?: Date | string
    userId: string
    candidateId: string
    replies?: EmailMessageUncheckedCreateNestedManyWithoutParentMessageInput
  }

  export type EmailMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    s3Url?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumEmailDirectionFieldUpdateOperationsInput | $Enums.EmailDirection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailMessageNestedInput
    candidate?: CandidateApplicationUpdateOneRequiredWithoutEmailMessageNestedInput
    parentMessage?: EmailMessageUpdateOneWithoutRepliesNestedInput
    replies?: EmailMessageUpdateManyWithoutParentMessageNestedInput
  }

  export type EmailMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    s3Url?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumEmailDirectionFieldUpdateOperationsInput | $Enums.EmailDirection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    candidateId?: StringFieldUpdateOperationsInput | string
    replies?: EmailMessageUncheckedUpdateManyWithoutParentMessageNestedInput
  }

  export type EmailMessageCreateManyInput = {
    id?: string
    messageId: string
    parentMessageId?: string | null
    sender: string
    recipient: string
    subject: string
    body: string
    s3Url?: string | null
    direction: $Enums.EmailDirection
    createdAt?: Date | string
    userId: string
    candidateId: string
  }

  export type EmailMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    s3Url?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumEmailDirectionFieldUpdateOperationsInput | $Enums.EmailDirection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    s3Url?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumEmailDirectionFieldUpdateOperationsInput | $Enums.EmailDirection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    candidateId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    id?: string
    message: string
    createdAt?: Date | string
    type?: string
    category?: string
    actionUrl?: string | null
    priority?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserCreateNestedOneWithoutNotificationInput
    organization?: OrganizationCreateNestedOneWithoutNotificationInput
    receipts?: NotificationReceiptCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    message: string
    createdAt?: Date | string
    type?: string
    category?: string
    actionUrl?: string | null
    priority?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    organizationId?: string | null
    receipts?: NotificationReceiptUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneWithoutNotificationNestedInput
    organization?: OrganizationUpdateOneWithoutNotificationNestedInput
    receipts?: NotificationReceiptUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    receipts?: NotificationReceiptUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationCreateManyInput = {
    id?: string
    message: string
    createdAt?: Date | string
    type?: string
    category?: string
    actionUrl?: string | null
    priority?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    organizationId?: string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationReceiptCreateInput = {
    id?: string
    isRead?: boolean
    readAt?: Date | string | null
    notification: NotificationCreateNestedOneWithoutReceiptsInput
    user: UserCreateNestedOneWithoutNotificationReceiptInput
  }

  export type NotificationReceiptUncheckedCreateInput = {
    id?: string
    notificationId: string
    userId: string
    isRead?: boolean
    readAt?: Date | string | null
  }

  export type NotificationReceiptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: NotificationUpdateOneRequiredWithoutReceiptsNestedInput
    user?: UserUpdateOneRequiredWithoutNotificationReceiptNestedInput
  }

  export type NotificationReceiptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationReceiptCreateManyInput = {
    id?: string
    notificationId: string
    userId: string
    isRead?: boolean
    readAt?: Date | string | null
  }

  export type NotificationReceiptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationReceiptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumOrganizationRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.OrganizationRole | EnumOrganizationRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrganizationRole[] | ListEnumOrganizationRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrganizationRole[] | ListEnumOrganizationRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrganizationRoleFilter<$PrismaModel> | $Enums.OrganizationRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type OrganizationNullableRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OrganizationUserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationUserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationUserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumOrganizationRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrganizationRole | EnumOrganizationRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrganizationRole[] | ListEnumOrganizationRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrganizationRole[] | ListEnumOrganizationRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrganizationRoleWithAggregatesFilter<$PrismaModel> | $Enums.OrganizationRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrganizationRoleFilter<$PrismaModel>
    _max?: NestedEnumOrganizationRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type OrganizationUserRoleListRelationFilter = {
    every?: OrganizationUserRoleWhereInput
    some?: OrganizationUserRoleWhereInput
    none?: OrganizationUserRoleWhereInput
  }

  export type TwoFactorConfirmationNullableRelationFilter = {
    is?: TwoFactorConfirmationWhereInput | null
    isNot?: TwoFactorConfirmationWhereInput | null
  }

  export type CandidateTimelineListRelationFilter = {
    every?: CandidateTimelineWhereInput
    some?: CandidateTimelineWhereInput
    none?: CandidateTimelineWhereInput
  }

  export type EmailMessageListRelationFilter = {
    every?: EmailMessageWhereInput
    some?: EmailMessageWhereInput
    none?: EmailMessageWhereInput
  }

  export type OrganizationSubscriptionListRelationFilter = {
    every?: OrganizationSubscriptionWhereInput
    some?: OrganizationSubscriptionWhereInput
    none?: OrganizationSubscriptionWhereInput
  }

  export type NotificationReceiptListRelationFilter = {
    every?: NotificationReceiptWhereInput
    some?: NotificationReceiptWhereInput
    none?: NotificationReceiptWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationUserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CandidateTimelineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationReceiptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isTwoFactorEnabled?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isTwoFactorEnabled?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isTwoFactorEnabled?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type VerificationTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type TwoFactorTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type TwoFactorTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type TwoFactorTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type TwoFactorTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type TwoFactorConfirmationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TwoFactorConfirmationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TwoFactorConfirmationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type OrganizationActivityLogListRelationFilter = {
    every?: OrganizationActivityLogWhereInput
    some?: OrganizationActivityLogWhereInput
    none?: OrganizationActivityLogWhereInput
  }

  export type JobPostListRelationFilter = {
    every?: JobPostWhereInput
    some?: JobPostWhereInput
    none?: JobPostWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type JobPreviewListRelationFilter = {
    every?: JobPreviewWhereInput
    some?: JobPreviewWhereInput
    none?: JobPreviewWhereInput
  }

  export type OrganizationActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobPreviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    logo?: SortOrder
    assignedDomain?: SortOrder
    customDomain?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    logo?: SortOrder
    assignedDomain?: SortOrder
    customDomain?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    logo?: SortOrder
    assignedDomain?: SortOrder
    customDomain?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type OrganizationSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    referalId?: SortOrder
    paymentHandler?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    subscriptionType?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresOn?: SortOrder
  }

  export type OrganizationSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    referalId?: SortOrder
    paymentHandler?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    subscriptionType?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresOn?: SortOrder
  }

  export type OrganizationSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    referalId?: SortOrder
    paymentHandler?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    subscriptionType?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresOn?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    paddlePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    paddlePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    paddlePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type OrganizationActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type JobApplicationListRelationFilter = {
    every?: JobApplicationWhereInput
    some?: JobApplicationWhereInput
    none?: JobApplicationWhereInput
  }

  export type JobStageListRelationFilter = {
    every?: JobStageWhereInput
    some?: JobStageWhereInput
    none?: JobStageWhereInput
  }

  export type CandidateApplicationListRelationFilter = {
    every?: CandidateApplicationWhereInput
    some?: CandidateApplicationWhereInput
    none?: CandidateApplicationWhereInput
  }

  export type JobMailingTemplateListRelationFilter = {
    every?: JobMailingTemplateWhereInput
    some?: JobMailingTemplateWhereInput
    none?: JobMailingTemplateWhereInput
  }

  export type JobApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobStageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CandidateApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobMailingTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobPostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    employmentType?: SortOrder
    country?: SortOrder
    city?: SortOrder
    remoteOption?: SortOrder
    countryResidence?: SortOrder
    countryListResidence?: SortOrder
    displaySalary?: SortOrder
    currency?: SortOrder
    salaryAmount?: SortOrder
    minimumAmount?: SortOrder
    maximumAmount?: SortOrder
    isPublished?: SortOrder
    isScheduled?: SortOrder
    isArchived?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type JobPostAvgOrderByAggregateInput = {
    salaryAmount?: SortOrder
    minimumAmount?: SortOrder
    maximumAmount?: SortOrder
  }

  export type JobPostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    employmentType?: SortOrder
    country?: SortOrder
    city?: SortOrder
    remoteOption?: SortOrder
    countryResidence?: SortOrder
    displaySalary?: SortOrder
    currency?: SortOrder
    salaryAmount?: SortOrder
    minimumAmount?: SortOrder
    maximumAmount?: SortOrder
    isPublished?: SortOrder
    isScheduled?: SortOrder
    isArchived?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type JobPostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    employmentType?: SortOrder
    country?: SortOrder
    city?: SortOrder
    remoteOption?: SortOrder
    countryResidence?: SortOrder
    displaySalary?: SortOrder
    currency?: SortOrder
    salaryAmount?: SortOrder
    minimumAmount?: SortOrder
    maximumAmount?: SortOrder
    isPublished?: SortOrder
    isScheduled?: SortOrder
    isArchived?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type JobPostSumOrderByAggregateInput = {
    salaryAmount?: SortOrder
    minimumAmount?: SortOrder
    maximumAmount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type JobPostRelationFilter = {
    is?: JobPostWhereInput
    isNot?: JobPostWhereInput
  }

  export type FormResponseListRelationFilter = {
    every?: FormResponseWhereInput
    some?: FormResponseWhereInput
    none?: FormResponseWhereInput
  }

  export type FormResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    dataType?: SortOrder
    option?: SortOrder
    rule?: SortOrder
    questionType?: SortOrder
    isDeleted?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
  }

  export type JobApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    dataType?: SortOrder
    rule?: SortOrder
    questionType?: SortOrder
    isDeleted?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
  }

  export type JobApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    dataType?: SortOrder
    rule?: SortOrder
    questionType?: SortOrder
    isDeleted?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
  }

  export type JobStageRelationFilter = {
    is?: JobStageWhereInput
    isNot?: JobStageWhereInput
  }

  export type CandidateApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    stageId?: SortOrder
  }

  export type CandidateApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    stageId?: SortOrder
  }

  export type CandidateApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    stageId?: SortOrder
  }

  export type CandidateReviewCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    verdict?: SortOrder
    createdAt?: SortOrder
  }

  export type CandidateReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    verdict?: SortOrder
    createdAt?: SortOrder
  }

  export type CandidateReviewMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    verdict?: SortOrder
    createdAt?: SortOrder
  }

  export type CandidateReviewNullableRelationFilter = {
    is?: CandidateReviewWhereInput | null
    isNot?: CandidateReviewWhereInput | null
  }

  export type CandidateApplicationRelationFilter = {
    is?: CandidateApplicationWhereInput
    isNot?: CandidateApplicationWhereInput
  }

  export type CandidateTimelineCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    jobId?: SortOrder
    timelineText?: SortOrder
    comment?: SortOrder
    reviewId?: SortOrder
    candidateId?: SortOrder
  }

  export type CandidateTimelineMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    jobId?: SortOrder
    timelineText?: SortOrder
    comment?: SortOrder
    reviewId?: SortOrder
    candidateId?: SortOrder
  }

  export type CandidateTimelineMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    jobId?: SortOrder
    timelineText?: SortOrder
    comment?: SortOrder
    reviewId?: SortOrder
    candidateId?: SortOrder
  }

  export type JobApplicationRelationFilter = {
    is?: JobApplicationWhereInput
    isNot?: JobApplicationWhereInput
  }

  export type FormResponseCountOrderByAggregateInput = {
    id?: SortOrder
    candidateApplicationId?: SortOrder
    jobApplicationId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type FormResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    candidateApplicationId?: SortOrder
    jobApplicationId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type FormResponseMinOrderByAggregateInput = {
    id?: SortOrder
    candidateApplicationId?: SortOrder
    jobApplicationId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type JobPreviewCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    isExpired?: SortOrder
    organizationId?: SortOrder
    jobId?: SortOrder
  }

  export type JobPreviewMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    isExpired?: SortOrder
    organizationId?: SortOrder
    jobId?: SortOrder
  }

  export type JobPreviewMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    isExpired?: SortOrder
    organizationId?: SortOrder
    jobId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type JobStageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isDeletable?: SortOrder
    isDeleted?: SortOrder
    displayOrder?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
  }

  export type JobStageAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type JobStageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isDeletable?: SortOrder
    isDeleted?: SortOrder
    displayOrder?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
  }

  export type JobStageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isDeletable?: SortOrder
    isDeleted?: SortOrder
    displayOrder?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
  }

  export type JobStageSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type JobMailingTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    jobId?: SortOrder
  }

  export type JobMailingTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    jobId?: SortOrder
  }

  export type JobMailingTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    jobId?: SortOrder
  }

  export type EnumEmailDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailDirection | EnumEmailDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.EmailDirection[] | ListEnumEmailDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailDirection[] | ListEnumEmailDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailDirectionFilter<$PrismaModel> | $Enums.EmailDirection
  }

  export type EmailMessageNullableRelationFilter = {
    is?: EmailMessageWhereInput | null
    isNot?: EmailMessageWhereInput | null
  }

  export type EmailMessageCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    parentMessageId?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    s3Url?: SortOrder
    direction?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    candidateId?: SortOrder
  }

  export type EmailMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    parentMessageId?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    s3Url?: SortOrder
    direction?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    candidateId?: SortOrder
  }

  export type EmailMessageMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    parentMessageId?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    s3Url?: SortOrder
    direction?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    candidateId?: SortOrder
  }

  export type EnumEmailDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailDirection | EnumEmailDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.EmailDirection[] | ListEnumEmailDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailDirection[] | ListEnumEmailDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailDirectionWithAggregatesFilter<$PrismaModel> | $Enums.EmailDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailDirectionFilter<$PrismaModel>
    _max?: NestedEnumEmailDirectionFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    category?: SortOrder
    actionUrl?: SortOrder
    priority?: SortOrder
    metadata?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    category?: SortOrder
    actionUrl?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    category?: SortOrder
    actionUrl?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type NotificationRelationFilter = {
    is?: NotificationWhereInput
    isNot?: NotificationWhereInput
  }

  export type NotificationReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
  }

  export type OrganizationCreateNestedOneWithoutOrganizationRoleInput = {
    create?: XOR<OrganizationCreateWithoutOrganizationRoleInput, OrganizationUncheckedCreateWithoutOrganizationRoleInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrganizationRoleInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrganizationsInput = {
    create?: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumOrganizationRoleFieldUpdateOperationsInput = {
    set?: $Enums.OrganizationRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type OrganizationUpdateOneWithoutOrganizationRoleNestedInput = {
    create?: XOR<OrganizationCreateWithoutOrganizationRoleInput, OrganizationUncheckedCreateWithoutOrganizationRoleInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrganizationRoleInput
    upsert?: OrganizationUpsertWithoutOrganizationRoleInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutOrganizationRoleInput, OrganizationUpdateWithoutOrganizationRoleInput>, OrganizationUncheckedUpdateWithoutOrganizationRoleInput>
  }

  export type UserUpdateOneWithoutOrganizationsNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationsInput
    upsert?: UserUpsertWithoutOrganizationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrganizationsInput, UserUpdateWithoutOrganizationsInput>, UserUncheckedUpdateWithoutOrganizationsInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type OrganizationUserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationUserRoleCreateWithoutUserInput, OrganizationUserRoleUncheckedCreateWithoutUserInput> | OrganizationUserRoleCreateWithoutUserInput[] | OrganizationUserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationUserRoleCreateOrConnectWithoutUserInput | OrganizationUserRoleCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationUserRoleCreateManyUserInputEnvelope
    connect?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
  }

  export type TwoFactorConfirmationCreateNestedOneWithoutUserInput = {
    create?: XOR<TwoFactorConfirmationCreateWithoutUserInput, TwoFactorConfirmationUncheckedCreateWithoutUserInput>
    connectOrCreate?: TwoFactorConfirmationCreateOrConnectWithoutUserInput
    connect?: TwoFactorConfirmationWhereUniqueInput
  }

  export type CandidateTimelineCreateNestedManyWithoutUserInput = {
    create?: XOR<CandidateTimelineCreateWithoutUserInput, CandidateTimelineUncheckedCreateWithoutUserInput> | CandidateTimelineCreateWithoutUserInput[] | CandidateTimelineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CandidateTimelineCreateOrConnectWithoutUserInput | CandidateTimelineCreateOrConnectWithoutUserInput[]
    createMany?: CandidateTimelineCreateManyUserInputEnvelope
    connect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
  }

  export type EmailMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailMessageCreateWithoutUserInput, EmailMessageUncheckedCreateWithoutUserInput> | EmailMessageCreateWithoutUserInput[] | EmailMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutUserInput | EmailMessageCreateOrConnectWithoutUserInput[]
    createMany?: EmailMessageCreateManyUserInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type OrganizationSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationSubscriptionCreateWithoutUserInput, OrganizationSubscriptionUncheckedCreateWithoutUserInput> | OrganizationSubscriptionCreateWithoutUserInput[] | OrganizationSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationSubscriptionCreateOrConnectWithoutUserInput | OrganizationSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationSubscriptionCreateManyUserInputEnvelope
    connect?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
  }

  export type NotificationReceiptCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationReceiptCreateWithoutUserInput, NotificationReceiptUncheckedCreateWithoutUserInput> | NotificationReceiptCreateWithoutUserInput[] | NotificationReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationReceiptCreateOrConnectWithoutUserInput | NotificationReceiptCreateOrConnectWithoutUserInput[]
    createMany?: NotificationReceiptCreateManyUserInputEnvelope
    connect?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type OrganizationUserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationUserRoleCreateWithoutUserInput, OrganizationUserRoleUncheckedCreateWithoutUserInput> | OrganizationUserRoleCreateWithoutUserInput[] | OrganizationUserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationUserRoleCreateOrConnectWithoutUserInput | OrganizationUserRoleCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationUserRoleCreateManyUserInputEnvelope
    connect?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
  }

  export type TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TwoFactorConfirmationCreateWithoutUserInput, TwoFactorConfirmationUncheckedCreateWithoutUserInput>
    connectOrCreate?: TwoFactorConfirmationCreateOrConnectWithoutUserInput
    connect?: TwoFactorConfirmationWhereUniqueInput
  }

  export type CandidateTimelineUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CandidateTimelineCreateWithoutUserInput, CandidateTimelineUncheckedCreateWithoutUserInput> | CandidateTimelineCreateWithoutUserInput[] | CandidateTimelineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CandidateTimelineCreateOrConnectWithoutUserInput | CandidateTimelineCreateOrConnectWithoutUserInput[]
    createMany?: CandidateTimelineCreateManyUserInputEnvelope
    connect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
  }

  export type EmailMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailMessageCreateWithoutUserInput, EmailMessageUncheckedCreateWithoutUserInput> | EmailMessageCreateWithoutUserInput[] | EmailMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutUserInput | EmailMessageCreateOrConnectWithoutUserInput[]
    createMany?: EmailMessageCreateManyUserInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type OrganizationSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationSubscriptionCreateWithoutUserInput, OrganizationSubscriptionUncheckedCreateWithoutUserInput> | OrganizationSubscriptionCreateWithoutUserInput[] | OrganizationSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationSubscriptionCreateOrConnectWithoutUserInput | OrganizationSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationSubscriptionCreateManyUserInputEnvelope
    connect?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
  }

  export type NotificationReceiptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationReceiptCreateWithoutUserInput, NotificationReceiptUncheckedCreateWithoutUserInput> | NotificationReceiptCreateWithoutUserInput[] | NotificationReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationReceiptCreateOrConnectWithoutUserInput | NotificationReceiptCreateOrConnectWithoutUserInput[]
    createMany?: NotificationReceiptCreateManyUserInputEnvelope
    connect?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type OrganizationUserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationUserRoleCreateWithoutUserInput, OrganizationUserRoleUncheckedCreateWithoutUserInput> | OrganizationUserRoleCreateWithoutUserInput[] | OrganizationUserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationUserRoleCreateOrConnectWithoutUserInput | OrganizationUserRoleCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationUserRoleUpsertWithWhereUniqueWithoutUserInput | OrganizationUserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationUserRoleCreateManyUserInputEnvelope
    set?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
    disconnect?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
    delete?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
    connect?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
    update?: OrganizationUserRoleUpdateWithWhereUniqueWithoutUserInput | OrganizationUserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationUserRoleUpdateManyWithWhereWithoutUserInput | OrganizationUserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationUserRoleScalarWhereInput | OrganizationUserRoleScalarWhereInput[]
  }

  export type TwoFactorConfirmationUpdateOneWithoutUserNestedInput = {
    create?: XOR<TwoFactorConfirmationCreateWithoutUserInput, TwoFactorConfirmationUncheckedCreateWithoutUserInput>
    connectOrCreate?: TwoFactorConfirmationCreateOrConnectWithoutUserInput
    upsert?: TwoFactorConfirmationUpsertWithoutUserInput
    disconnect?: TwoFactorConfirmationWhereInput | boolean
    delete?: TwoFactorConfirmationWhereInput | boolean
    connect?: TwoFactorConfirmationWhereUniqueInput
    update?: XOR<XOR<TwoFactorConfirmationUpdateToOneWithWhereWithoutUserInput, TwoFactorConfirmationUpdateWithoutUserInput>, TwoFactorConfirmationUncheckedUpdateWithoutUserInput>
  }

  export type CandidateTimelineUpdateManyWithoutUserNestedInput = {
    create?: XOR<CandidateTimelineCreateWithoutUserInput, CandidateTimelineUncheckedCreateWithoutUserInput> | CandidateTimelineCreateWithoutUserInput[] | CandidateTimelineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CandidateTimelineCreateOrConnectWithoutUserInput | CandidateTimelineCreateOrConnectWithoutUserInput[]
    upsert?: CandidateTimelineUpsertWithWhereUniqueWithoutUserInput | CandidateTimelineUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CandidateTimelineCreateManyUserInputEnvelope
    set?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    disconnect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    delete?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    connect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    update?: CandidateTimelineUpdateWithWhereUniqueWithoutUserInput | CandidateTimelineUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CandidateTimelineUpdateManyWithWhereWithoutUserInput | CandidateTimelineUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CandidateTimelineScalarWhereInput | CandidateTimelineScalarWhereInput[]
  }

  export type EmailMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailMessageCreateWithoutUserInput, EmailMessageUncheckedCreateWithoutUserInput> | EmailMessageCreateWithoutUserInput[] | EmailMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutUserInput | EmailMessageCreateOrConnectWithoutUserInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutUserInput | EmailMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailMessageCreateManyUserInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutUserInput | EmailMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutUserInput | EmailMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type OrganizationSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationSubscriptionCreateWithoutUserInput, OrganizationSubscriptionUncheckedCreateWithoutUserInput> | OrganizationSubscriptionCreateWithoutUserInput[] | OrganizationSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationSubscriptionCreateOrConnectWithoutUserInput | OrganizationSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationSubscriptionUpsertWithWhereUniqueWithoutUserInput | OrganizationSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationSubscriptionCreateManyUserInputEnvelope
    set?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
    disconnect?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
    delete?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
    connect?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
    update?: OrganizationSubscriptionUpdateWithWhereUniqueWithoutUserInput | OrganizationSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationSubscriptionUpdateManyWithWhereWithoutUserInput | OrganizationSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationSubscriptionScalarWhereInput | OrganizationSubscriptionScalarWhereInput[]
  }

  export type NotificationReceiptUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationReceiptCreateWithoutUserInput, NotificationReceiptUncheckedCreateWithoutUserInput> | NotificationReceiptCreateWithoutUserInput[] | NotificationReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationReceiptCreateOrConnectWithoutUserInput | NotificationReceiptCreateOrConnectWithoutUserInput[]
    upsert?: NotificationReceiptUpsertWithWhereUniqueWithoutUserInput | NotificationReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationReceiptCreateManyUserInputEnvelope
    set?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
    disconnect?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
    delete?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
    connect?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
    update?: NotificationReceiptUpdateWithWhereUniqueWithoutUserInput | NotificationReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationReceiptUpdateManyWithWhereWithoutUserInput | NotificationReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationReceiptScalarWhereInput | NotificationReceiptScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type OrganizationUserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationUserRoleCreateWithoutUserInput, OrganizationUserRoleUncheckedCreateWithoutUserInput> | OrganizationUserRoleCreateWithoutUserInput[] | OrganizationUserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationUserRoleCreateOrConnectWithoutUserInput | OrganizationUserRoleCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationUserRoleUpsertWithWhereUniqueWithoutUserInput | OrganizationUserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationUserRoleCreateManyUserInputEnvelope
    set?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
    disconnect?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
    delete?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
    connect?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
    update?: OrganizationUserRoleUpdateWithWhereUniqueWithoutUserInput | OrganizationUserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationUserRoleUpdateManyWithWhereWithoutUserInput | OrganizationUserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationUserRoleScalarWhereInput | OrganizationUserRoleScalarWhereInput[]
  }

  export type TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TwoFactorConfirmationCreateWithoutUserInput, TwoFactorConfirmationUncheckedCreateWithoutUserInput>
    connectOrCreate?: TwoFactorConfirmationCreateOrConnectWithoutUserInput
    upsert?: TwoFactorConfirmationUpsertWithoutUserInput
    disconnect?: TwoFactorConfirmationWhereInput | boolean
    delete?: TwoFactorConfirmationWhereInput | boolean
    connect?: TwoFactorConfirmationWhereUniqueInput
    update?: XOR<XOR<TwoFactorConfirmationUpdateToOneWithWhereWithoutUserInput, TwoFactorConfirmationUpdateWithoutUserInput>, TwoFactorConfirmationUncheckedUpdateWithoutUserInput>
  }

  export type CandidateTimelineUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CandidateTimelineCreateWithoutUserInput, CandidateTimelineUncheckedCreateWithoutUserInput> | CandidateTimelineCreateWithoutUserInput[] | CandidateTimelineUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CandidateTimelineCreateOrConnectWithoutUserInput | CandidateTimelineCreateOrConnectWithoutUserInput[]
    upsert?: CandidateTimelineUpsertWithWhereUniqueWithoutUserInput | CandidateTimelineUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CandidateTimelineCreateManyUserInputEnvelope
    set?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    disconnect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    delete?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    connect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    update?: CandidateTimelineUpdateWithWhereUniqueWithoutUserInput | CandidateTimelineUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CandidateTimelineUpdateManyWithWhereWithoutUserInput | CandidateTimelineUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CandidateTimelineScalarWhereInput | CandidateTimelineScalarWhereInput[]
  }

  export type EmailMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailMessageCreateWithoutUserInput, EmailMessageUncheckedCreateWithoutUserInput> | EmailMessageCreateWithoutUserInput[] | EmailMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutUserInput | EmailMessageCreateOrConnectWithoutUserInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutUserInput | EmailMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailMessageCreateManyUserInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutUserInput | EmailMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutUserInput | EmailMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type OrganizationSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationSubscriptionCreateWithoutUserInput, OrganizationSubscriptionUncheckedCreateWithoutUserInput> | OrganizationSubscriptionCreateWithoutUserInput[] | OrganizationSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationSubscriptionCreateOrConnectWithoutUserInput | OrganizationSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationSubscriptionUpsertWithWhereUniqueWithoutUserInput | OrganizationSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationSubscriptionCreateManyUserInputEnvelope
    set?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
    disconnect?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
    delete?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
    connect?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
    update?: OrganizationSubscriptionUpdateWithWhereUniqueWithoutUserInput | OrganizationSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationSubscriptionUpdateManyWithWhereWithoutUserInput | OrganizationSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationSubscriptionScalarWhereInput | OrganizationSubscriptionScalarWhereInput[]
  }

  export type NotificationReceiptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationReceiptCreateWithoutUserInput, NotificationReceiptUncheckedCreateWithoutUserInput> | NotificationReceiptCreateWithoutUserInput[] | NotificationReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationReceiptCreateOrConnectWithoutUserInput | NotificationReceiptCreateOrConnectWithoutUserInput[]
    upsert?: NotificationReceiptUpsertWithWhereUniqueWithoutUserInput | NotificationReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationReceiptCreateManyUserInputEnvelope
    set?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
    disconnect?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
    delete?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
    connect?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
    update?: NotificationReceiptUpdateWithWhereUniqueWithoutUserInput | NotificationReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationReceiptUpdateManyWithWhereWithoutUserInput | NotificationReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationReceiptScalarWhereInput | NotificationReceiptScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutTwoFactorConfirmationInput = {
    create?: XOR<UserCreateWithoutTwoFactorConfirmationInput, UserUncheckedCreateWithoutTwoFactorConfirmationInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwoFactorConfirmationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTwoFactorConfirmationNestedInput = {
    create?: XOR<UserCreateWithoutTwoFactorConfirmationInput, UserUncheckedCreateWithoutTwoFactorConfirmationInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwoFactorConfirmationInput
    upsert?: UserUpsertWithoutTwoFactorConfirmationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTwoFactorConfirmationInput, UserUpdateWithoutTwoFactorConfirmationInput>, UserUncheckedUpdateWithoutTwoFactorConfirmationInput>
  }

  export type OrganizationUserRoleCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationUserRoleCreateWithoutOrganizationInput, OrganizationUserRoleUncheckedCreateWithoutOrganizationInput> | OrganizationUserRoleCreateWithoutOrganizationInput[] | OrganizationUserRoleUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationUserRoleCreateOrConnectWithoutOrganizationInput | OrganizationUserRoleCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationUserRoleCreateManyOrganizationInputEnvelope
    connect?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
  }

  export type OrganizationActivityLogCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationActivityLogCreateWithoutOrganizationInput, OrganizationActivityLogUncheckedCreateWithoutOrganizationInput> | OrganizationActivityLogCreateWithoutOrganizationInput[] | OrganizationActivityLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationActivityLogCreateOrConnectWithoutOrganizationInput | OrganizationActivityLogCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationActivityLogCreateManyOrganizationInputEnvelope
    connect?: OrganizationActivityLogWhereUniqueInput | OrganizationActivityLogWhereUniqueInput[]
  }

  export type JobPostCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<JobPostCreateWithoutOrganizationInput, JobPostUncheckedCreateWithoutOrganizationInput> | JobPostCreateWithoutOrganizationInput[] | JobPostUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: JobPostCreateOrConnectWithoutOrganizationInput | JobPostCreateOrConnectWithoutOrganizationInput[]
    createMany?: JobPostCreateManyOrganizationInputEnvelope
    connect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<PaymentCreateWithoutOrganizationInput, PaymentUncheckedCreateWithoutOrganizationInput> | PaymentCreateWithoutOrganizationInput[] | PaymentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrganizationInput | PaymentCreateOrConnectWithoutOrganizationInput[]
    createMany?: PaymentCreateManyOrganizationInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type JobPreviewCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<JobPreviewCreateWithoutOrganizationInput, JobPreviewUncheckedCreateWithoutOrganizationInput> | JobPreviewCreateWithoutOrganizationInput[] | JobPreviewUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: JobPreviewCreateOrConnectWithoutOrganizationInput | JobPreviewCreateOrConnectWithoutOrganizationInput[]
    createMany?: JobPreviewCreateManyOrganizationInputEnvelope
    connect?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
  }

  export type OrganizationSubscriptionCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationSubscriptionCreateWithoutOrganizationInput, OrganizationSubscriptionUncheckedCreateWithoutOrganizationInput> | OrganizationSubscriptionCreateWithoutOrganizationInput[] | OrganizationSubscriptionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationSubscriptionCreateOrConnectWithoutOrganizationInput | OrganizationSubscriptionCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationSubscriptionCreateManyOrganizationInputEnvelope
    connect?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<NotificationCreateWithoutOrganizationInput, NotificationUncheckedCreateWithoutOrganizationInput> | NotificationCreateWithoutOrganizationInput[] | NotificationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrganizationInput | NotificationCreateOrConnectWithoutOrganizationInput[]
    createMany?: NotificationCreateManyOrganizationInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type OrganizationUserRoleUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationUserRoleCreateWithoutOrganizationInput, OrganizationUserRoleUncheckedCreateWithoutOrganizationInput> | OrganizationUserRoleCreateWithoutOrganizationInput[] | OrganizationUserRoleUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationUserRoleCreateOrConnectWithoutOrganizationInput | OrganizationUserRoleCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationUserRoleCreateManyOrganizationInputEnvelope
    connect?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
  }

  export type OrganizationActivityLogUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationActivityLogCreateWithoutOrganizationInput, OrganizationActivityLogUncheckedCreateWithoutOrganizationInput> | OrganizationActivityLogCreateWithoutOrganizationInput[] | OrganizationActivityLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationActivityLogCreateOrConnectWithoutOrganizationInput | OrganizationActivityLogCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationActivityLogCreateManyOrganizationInputEnvelope
    connect?: OrganizationActivityLogWhereUniqueInput | OrganizationActivityLogWhereUniqueInput[]
  }

  export type JobPostUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<JobPostCreateWithoutOrganizationInput, JobPostUncheckedCreateWithoutOrganizationInput> | JobPostCreateWithoutOrganizationInput[] | JobPostUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: JobPostCreateOrConnectWithoutOrganizationInput | JobPostCreateOrConnectWithoutOrganizationInput[]
    createMany?: JobPostCreateManyOrganizationInputEnvelope
    connect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<PaymentCreateWithoutOrganizationInput, PaymentUncheckedCreateWithoutOrganizationInput> | PaymentCreateWithoutOrganizationInput[] | PaymentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrganizationInput | PaymentCreateOrConnectWithoutOrganizationInput[]
    createMany?: PaymentCreateManyOrganizationInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type JobPreviewUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<JobPreviewCreateWithoutOrganizationInput, JobPreviewUncheckedCreateWithoutOrganizationInput> | JobPreviewCreateWithoutOrganizationInput[] | JobPreviewUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: JobPreviewCreateOrConnectWithoutOrganizationInput | JobPreviewCreateOrConnectWithoutOrganizationInput[]
    createMany?: JobPreviewCreateManyOrganizationInputEnvelope
    connect?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
  }

  export type OrganizationSubscriptionUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationSubscriptionCreateWithoutOrganizationInput, OrganizationSubscriptionUncheckedCreateWithoutOrganizationInput> | OrganizationSubscriptionCreateWithoutOrganizationInput[] | OrganizationSubscriptionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationSubscriptionCreateOrConnectWithoutOrganizationInput | OrganizationSubscriptionCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationSubscriptionCreateManyOrganizationInputEnvelope
    connect?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<NotificationCreateWithoutOrganizationInput, NotificationUncheckedCreateWithoutOrganizationInput> | NotificationCreateWithoutOrganizationInput[] | NotificationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrganizationInput | NotificationCreateOrConnectWithoutOrganizationInput[]
    createMany?: NotificationCreateManyOrganizationInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type OrganizationUserRoleUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationUserRoleCreateWithoutOrganizationInput, OrganizationUserRoleUncheckedCreateWithoutOrganizationInput> | OrganizationUserRoleCreateWithoutOrganizationInput[] | OrganizationUserRoleUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationUserRoleCreateOrConnectWithoutOrganizationInput | OrganizationUserRoleCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationUserRoleUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationUserRoleUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationUserRoleCreateManyOrganizationInputEnvelope
    set?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
    disconnect?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
    delete?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
    connect?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
    update?: OrganizationUserRoleUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationUserRoleUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationUserRoleUpdateManyWithWhereWithoutOrganizationInput | OrganizationUserRoleUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationUserRoleScalarWhereInput | OrganizationUserRoleScalarWhereInput[]
  }

  export type OrganizationActivityLogUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationActivityLogCreateWithoutOrganizationInput, OrganizationActivityLogUncheckedCreateWithoutOrganizationInput> | OrganizationActivityLogCreateWithoutOrganizationInput[] | OrganizationActivityLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationActivityLogCreateOrConnectWithoutOrganizationInput | OrganizationActivityLogCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationActivityLogUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationActivityLogUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationActivityLogCreateManyOrganizationInputEnvelope
    set?: OrganizationActivityLogWhereUniqueInput | OrganizationActivityLogWhereUniqueInput[]
    disconnect?: OrganizationActivityLogWhereUniqueInput | OrganizationActivityLogWhereUniqueInput[]
    delete?: OrganizationActivityLogWhereUniqueInput | OrganizationActivityLogWhereUniqueInput[]
    connect?: OrganizationActivityLogWhereUniqueInput | OrganizationActivityLogWhereUniqueInput[]
    update?: OrganizationActivityLogUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationActivityLogUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationActivityLogUpdateManyWithWhereWithoutOrganizationInput | OrganizationActivityLogUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationActivityLogScalarWhereInput | OrganizationActivityLogScalarWhereInput[]
  }

  export type JobPostUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<JobPostCreateWithoutOrganizationInput, JobPostUncheckedCreateWithoutOrganizationInput> | JobPostCreateWithoutOrganizationInput[] | JobPostUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: JobPostCreateOrConnectWithoutOrganizationInput | JobPostCreateOrConnectWithoutOrganizationInput[]
    upsert?: JobPostUpsertWithWhereUniqueWithoutOrganizationInput | JobPostUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: JobPostCreateManyOrganizationInputEnvelope
    set?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    disconnect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    delete?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    connect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    update?: JobPostUpdateWithWhereUniqueWithoutOrganizationInput | JobPostUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: JobPostUpdateManyWithWhereWithoutOrganizationInput | JobPostUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: JobPostScalarWhereInput | JobPostScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<PaymentCreateWithoutOrganizationInput, PaymentUncheckedCreateWithoutOrganizationInput> | PaymentCreateWithoutOrganizationInput[] | PaymentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrganizationInput | PaymentCreateOrConnectWithoutOrganizationInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrganizationInput | PaymentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: PaymentCreateManyOrganizationInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrganizationInput | PaymentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrganizationInput | PaymentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type JobPreviewUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<JobPreviewCreateWithoutOrganizationInput, JobPreviewUncheckedCreateWithoutOrganizationInput> | JobPreviewCreateWithoutOrganizationInput[] | JobPreviewUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: JobPreviewCreateOrConnectWithoutOrganizationInput | JobPreviewCreateOrConnectWithoutOrganizationInput[]
    upsert?: JobPreviewUpsertWithWhereUniqueWithoutOrganizationInput | JobPreviewUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: JobPreviewCreateManyOrganizationInputEnvelope
    set?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
    disconnect?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
    delete?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
    connect?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
    update?: JobPreviewUpdateWithWhereUniqueWithoutOrganizationInput | JobPreviewUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: JobPreviewUpdateManyWithWhereWithoutOrganizationInput | JobPreviewUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: JobPreviewScalarWhereInput | JobPreviewScalarWhereInput[]
  }

  export type OrganizationSubscriptionUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationSubscriptionCreateWithoutOrganizationInput, OrganizationSubscriptionUncheckedCreateWithoutOrganizationInput> | OrganizationSubscriptionCreateWithoutOrganizationInput[] | OrganizationSubscriptionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationSubscriptionCreateOrConnectWithoutOrganizationInput | OrganizationSubscriptionCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationSubscriptionUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationSubscriptionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationSubscriptionCreateManyOrganizationInputEnvelope
    set?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
    disconnect?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
    delete?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
    connect?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
    update?: OrganizationSubscriptionUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationSubscriptionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationSubscriptionUpdateManyWithWhereWithoutOrganizationInput | OrganizationSubscriptionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationSubscriptionScalarWhereInput | OrganizationSubscriptionScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<NotificationCreateWithoutOrganizationInput, NotificationUncheckedCreateWithoutOrganizationInput> | NotificationCreateWithoutOrganizationInput[] | NotificationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrganizationInput | NotificationCreateOrConnectWithoutOrganizationInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutOrganizationInput | NotificationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: NotificationCreateManyOrganizationInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutOrganizationInput | NotificationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutOrganizationInput | NotificationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type OrganizationUserRoleUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationUserRoleCreateWithoutOrganizationInput, OrganizationUserRoleUncheckedCreateWithoutOrganizationInput> | OrganizationUserRoleCreateWithoutOrganizationInput[] | OrganizationUserRoleUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationUserRoleCreateOrConnectWithoutOrganizationInput | OrganizationUserRoleCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationUserRoleUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationUserRoleUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationUserRoleCreateManyOrganizationInputEnvelope
    set?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
    disconnect?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
    delete?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
    connect?: OrganizationUserRoleWhereUniqueInput | OrganizationUserRoleWhereUniqueInput[]
    update?: OrganizationUserRoleUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationUserRoleUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationUserRoleUpdateManyWithWhereWithoutOrganizationInput | OrganizationUserRoleUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationUserRoleScalarWhereInput | OrganizationUserRoleScalarWhereInput[]
  }

  export type OrganizationActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationActivityLogCreateWithoutOrganizationInput, OrganizationActivityLogUncheckedCreateWithoutOrganizationInput> | OrganizationActivityLogCreateWithoutOrganizationInput[] | OrganizationActivityLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationActivityLogCreateOrConnectWithoutOrganizationInput | OrganizationActivityLogCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationActivityLogUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationActivityLogUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationActivityLogCreateManyOrganizationInputEnvelope
    set?: OrganizationActivityLogWhereUniqueInput | OrganizationActivityLogWhereUniqueInput[]
    disconnect?: OrganizationActivityLogWhereUniqueInput | OrganizationActivityLogWhereUniqueInput[]
    delete?: OrganizationActivityLogWhereUniqueInput | OrganizationActivityLogWhereUniqueInput[]
    connect?: OrganizationActivityLogWhereUniqueInput | OrganizationActivityLogWhereUniqueInput[]
    update?: OrganizationActivityLogUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationActivityLogUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationActivityLogUpdateManyWithWhereWithoutOrganizationInput | OrganizationActivityLogUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationActivityLogScalarWhereInput | OrganizationActivityLogScalarWhereInput[]
  }

  export type JobPostUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<JobPostCreateWithoutOrganizationInput, JobPostUncheckedCreateWithoutOrganizationInput> | JobPostCreateWithoutOrganizationInput[] | JobPostUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: JobPostCreateOrConnectWithoutOrganizationInput | JobPostCreateOrConnectWithoutOrganizationInput[]
    upsert?: JobPostUpsertWithWhereUniqueWithoutOrganizationInput | JobPostUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: JobPostCreateManyOrganizationInputEnvelope
    set?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    disconnect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    delete?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    connect?: JobPostWhereUniqueInput | JobPostWhereUniqueInput[]
    update?: JobPostUpdateWithWhereUniqueWithoutOrganizationInput | JobPostUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: JobPostUpdateManyWithWhereWithoutOrganizationInput | JobPostUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: JobPostScalarWhereInput | JobPostScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<PaymentCreateWithoutOrganizationInput, PaymentUncheckedCreateWithoutOrganizationInput> | PaymentCreateWithoutOrganizationInput[] | PaymentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrganizationInput | PaymentCreateOrConnectWithoutOrganizationInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrganizationInput | PaymentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: PaymentCreateManyOrganizationInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrganizationInput | PaymentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrganizationInput | PaymentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type JobPreviewUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<JobPreviewCreateWithoutOrganizationInput, JobPreviewUncheckedCreateWithoutOrganizationInput> | JobPreviewCreateWithoutOrganizationInput[] | JobPreviewUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: JobPreviewCreateOrConnectWithoutOrganizationInput | JobPreviewCreateOrConnectWithoutOrganizationInput[]
    upsert?: JobPreviewUpsertWithWhereUniqueWithoutOrganizationInput | JobPreviewUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: JobPreviewCreateManyOrganizationInputEnvelope
    set?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
    disconnect?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
    delete?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
    connect?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
    update?: JobPreviewUpdateWithWhereUniqueWithoutOrganizationInput | JobPreviewUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: JobPreviewUpdateManyWithWhereWithoutOrganizationInput | JobPreviewUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: JobPreviewScalarWhereInput | JobPreviewScalarWhereInput[]
  }

  export type OrganizationSubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationSubscriptionCreateWithoutOrganizationInput, OrganizationSubscriptionUncheckedCreateWithoutOrganizationInput> | OrganizationSubscriptionCreateWithoutOrganizationInput[] | OrganizationSubscriptionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationSubscriptionCreateOrConnectWithoutOrganizationInput | OrganizationSubscriptionCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationSubscriptionUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationSubscriptionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationSubscriptionCreateManyOrganizationInputEnvelope
    set?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
    disconnect?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
    delete?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
    connect?: OrganizationSubscriptionWhereUniqueInput | OrganizationSubscriptionWhereUniqueInput[]
    update?: OrganizationSubscriptionUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationSubscriptionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationSubscriptionUpdateManyWithWhereWithoutOrganizationInput | OrganizationSubscriptionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationSubscriptionScalarWhereInput | OrganizationSubscriptionScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<NotificationCreateWithoutOrganizationInput, NotificationUncheckedCreateWithoutOrganizationInput> | NotificationCreateWithoutOrganizationInput[] | NotificationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutOrganizationInput | NotificationCreateOrConnectWithoutOrganizationInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutOrganizationInput | NotificationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: NotificationCreateManyOrganizationInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutOrganizationInput | NotificationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutOrganizationInput | NotificationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutOrganizationSubscriptionInput = {
    create?: XOR<OrganizationCreateWithoutOrganizationSubscriptionInput, OrganizationUncheckedCreateWithoutOrganizationSubscriptionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrganizationSubscriptionInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrganizationSubscriptionInput = {
    create?: XOR<UserCreateWithoutOrganizationSubscriptionInput, UserUncheckedCreateWithoutOrganizationSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type OrganizationUpdateOneRequiredWithoutOrganizationSubscriptionNestedInput = {
    create?: XOR<OrganizationCreateWithoutOrganizationSubscriptionInput, OrganizationUncheckedCreateWithoutOrganizationSubscriptionInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrganizationSubscriptionInput
    upsert?: OrganizationUpsertWithoutOrganizationSubscriptionInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutOrganizationSubscriptionInput, OrganizationUpdateWithoutOrganizationSubscriptionInput>, OrganizationUncheckedUpdateWithoutOrganizationSubscriptionInput>
  }

  export type UserUpdateOneRequiredWithoutOrganizationSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationSubscriptionInput, UserUncheckedCreateWithoutOrganizationSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationSubscriptionInput
    upsert?: UserUpsertWithoutOrganizationSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrganizationSubscriptionInput, UserUpdateWithoutOrganizationSubscriptionInput>, UserUncheckedUpdateWithoutOrganizationSubscriptionInput>
  }

  export type OrganizationCreateNestedOneWithoutPaymentInput = {
    create?: XOR<OrganizationCreateWithoutPaymentInput, OrganizationUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPaymentInput
    connect?: OrganizationWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type OrganizationUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<OrganizationCreateWithoutPaymentInput, OrganizationUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPaymentInput
    upsert?: OrganizationUpsertWithoutPaymentInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutPaymentInput, OrganizationUpdateWithoutPaymentInput>, OrganizationUncheckedUpdateWithoutPaymentInput>
  }

  export type OrganizationCreateNestedOneWithoutOrganizationActionLogInput = {
    create?: XOR<OrganizationCreateWithoutOrganizationActionLogInput, OrganizationUncheckedCreateWithoutOrganizationActionLogInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrganizationActionLogInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneWithoutOrganizationActionLogNestedInput = {
    create?: XOR<OrganizationCreateWithoutOrganizationActionLogInput, OrganizationUncheckedCreateWithoutOrganizationActionLogInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrganizationActionLogInput
    upsert?: OrganizationUpsertWithoutOrganizationActionLogInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutOrganizationActionLogInput, OrganizationUpdateWithoutOrganizationActionLogInput>, OrganizationUncheckedUpdateWithoutOrganizationActionLogInput>
  }

  export type JobPostCreatecountryListResidenceInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutJobPostInput = {
    create?: XOR<OrganizationCreateWithoutJobPostInput, OrganizationUncheckedCreateWithoutJobPostInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutJobPostInput
    connect?: OrganizationWhereUniqueInput
  }

  export type JobApplicationCreateNestedManyWithoutJobPostInput = {
    create?: XOR<JobApplicationCreateWithoutJobPostInput, JobApplicationUncheckedCreateWithoutJobPostInput> | JobApplicationCreateWithoutJobPostInput[] | JobApplicationUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobPostInput | JobApplicationCreateOrConnectWithoutJobPostInput[]
    createMany?: JobApplicationCreateManyJobPostInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type JobStageCreateNestedManyWithoutJobPostInput = {
    create?: XOR<JobStageCreateWithoutJobPostInput, JobStageUncheckedCreateWithoutJobPostInput> | JobStageCreateWithoutJobPostInput[] | JobStageUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: JobStageCreateOrConnectWithoutJobPostInput | JobStageCreateOrConnectWithoutJobPostInput[]
    createMany?: JobStageCreateManyJobPostInputEnvelope
    connect?: JobStageWhereUniqueInput | JobStageWhereUniqueInput[]
  }

  export type JobPreviewCreateNestedManyWithoutJobPostInput = {
    create?: XOR<JobPreviewCreateWithoutJobPostInput, JobPreviewUncheckedCreateWithoutJobPostInput> | JobPreviewCreateWithoutJobPostInput[] | JobPreviewUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: JobPreviewCreateOrConnectWithoutJobPostInput | JobPreviewCreateOrConnectWithoutJobPostInput[]
    createMany?: JobPreviewCreateManyJobPostInputEnvelope
    connect?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
  }

  export type CandidateApplicationCreateNestedManyWithoutJobPostInput = {
    create?: XOR<CandidateApplicationCreateWithoutJobPostInput, CandidateApplicationUncheckedCreateWithoutJobPostInput> | CandidateApplicationCreateWithoutJobPostInput[] | CandidateApplicationUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: CandidateApplicationCreateOrConnectWithoutJobPostInput | CandidateApplicationCreateOrConnectWithoutJobPostInput[]
    createMany?: CandidateApplicationCreateManyJobPostInputEnvelope
    connect?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
  }

  export type CandidateTimelineCreateNestedManyWithoutJobPostInput = {
    create?: XOR<CandidateTimelineCreateWithoutJobPostInput, CandidateTimelineUncheckedCreateWithoutJobPostInput> | CandidateTimelineCreateWithoutJobPostInput[] | CandidateTimelineUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: CandidateTimelineCreateOrConnectWithoutJobPostInput | CandidateTimelineCreateOrConnectWithoutJobPostInput[]
    createMany?: CandidateTimelineCreateManyJobPostInputEnvelope
    connect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
  }

  export type JobMailingTemplateCreateNestedManyWithoutJobPostInput = {
    create?: XOR<JobMailingTemplateCreateWithoutJobPostInput, JobMailingTemplateUncheckedCreateWithoutJobPostInput> | JobMailingTemplateCreateWithoutJobPostInput[] | JobMailingTemplateUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: JobMailingTemplateCreateOrConnectWithoutJobPostInput | JobMailingTemplateCreateOrConnectWithoutJobPostInput[]
    createMany?: JobMailingTemplateCreateManyJobPostInputEnvelope
    connect?: JobMailingTemplateWhereUniqueInput | JobMailingTemplateWhereUniqueInput[]
  }

  export type JobApplicationUncheckedCreateNestedManyWithoutJobPostInput = {
    create?: XOR<JobApplicationCreateWithoutJobPostInput, JobApplicationUncheckedCreateWithoutJobPostInput> | JobApplicationCreateWithoutJobPostInput[] | JobApplicationUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobPostInput | JobApplicationCreateOrConnectWithoutJobPostInput[]
    createMany?: JobApplicationCreateManyJobPostInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type JobStageUncheckedCreateNestedManyWithoutJobPostInput = {
    create?: XOR<JobStageCreateWithoutJobPostInput, JobStageUncheckedCreateWithoutJobPostInput> | JobStageCreateWithoutJobPostInput[] | JobStageUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: JobStageCreateOrConnectWithoutJobPostInput | JobStageCreateOrConnectWithoutJobPostInput[]
    createMany?: JobStageCreateManyJobPostInputEnvelope
    connect?: JobStageWhereUniqueInput | JobStageWhereUniqueInput[]
  }

  export type JobPreviewUncheckedCreateNestedManyWithoutJobPostInput = {
    create?: XOR<JobPreviewCreateWithoutJobPostInput, JobPreviewUncheckedCreateWithoutJobPostInput> | JobPreviewCreateWithoutJobPostInput[] | JobPreviewUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: JobPreviewCreateOrConnectWithoutJobPostInput | JobPreviewCreateOrConnectWithoutJobPostInput[]
    createMany?: JobPreviewCreateManyJobPostInputEnvelope
    connect?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
  }

  export type CandidateApplicationUncheckedCreateNestedManyWithoutJobPostInput = {
    create?: XOR<CandidateApplicationCreateWithoutJobPostInput, CandidateApplicationUncheckedCreateWithoutJobPostInput> | CandidateApplicationCreateWithoutJobPostInput[] | CandidateApplicationUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: CandidateApplicationCreateOrConnectWithoutJobPostInput | CandidateApplicationCreateOrConnectWithoutJobPostInput[]
    createMany?: CandidateApplicationCreateManyJobPostInputEnvelope
    connect?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
  }

  export type CandidateTimelineUncheckedCreateNestedManyWithoutJobPostInput = {
    create?: XOR<CandidateTimelineCreateWithoutJobPostInput, CandidateTimelineUncheckedCreateWithoutJobPostInput> | CandidateTimelineCreateWithoutJobPostInput[] | CandidateTimelineUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: CandidateTimelineCreateOrConnectWithoutJobPostInput | CandidateTimelineCreateOrConnectWithoutJobPostInput[]
    createMany?: CandidateTimelineCreateManyJobPostInputEnvelope
    connect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
  }

  export type JobMailingTemplateUncheckedCreateNestedManyWithoutJobPostInput = {
    create?: XOR<JobMailingTemplateCreateWithoutJobPostInput, JobMailingTemplateUncheckedCreateWithoutJobPostInput> | JobMailingTemplateCreateWithoutJobPostInput[] | JobMailingTemplateUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: JobMailingTemplateCreateOrConnectWithoutJobPostInput | JobMailingTemplateCreateOrConnectWithoutJobPostInput[]
    createMany?: JobMailingTemplateCreateManyJobPostInputEnvelope
    connect?: JobMailingTemplateWhereUniqueInput | JobMailingTemplateWhereUniqueInput[]
  }

  export type JobPostUpdatecountryListResidenceInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrganizationUpdateOneRequiredWithoutJobPostNestedInput = {
    create?: XOR<OrganizationCreateWithoutJobPostInput, OrganizationUncheckedCreateWithoutJobPostInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutJobPostInput
    upsert?: OrganizationUpsertWithoutJobPostInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutJobPostInput, OrganizationUpdateWithoutJobPostInput>, OrganizationUncheckedUpdateWithoutJobPostInput>
  }

  export type JobApplicationUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<JobApplicationCreateWithoutJobPostInput, JobApplicationUncheckedCreateWithoutJobPostInput> | JobApplicationCreateWithoutJobPostInput[] | JobApplicationUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobPostInput | JobApplicationCreateOrConnectWithoutJobPostInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutJobPostInput | JobApplicationUpsertWithWhereUniqueWithoutJobPostInput[]
    createMany?: JobApplicationCreateManyJobPostInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutJobPostInput | JobApplicationUpdateWithWhereUniqueWithoutJobPostInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutJobPostInput | JobApplicationUpdateManyWithWhereWithoutJobPostInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type JobStageUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<JobStageCreateWithoutJobPostInput, JobStageUncheckedCreateWithoutJobPostInput> | JobStageCreateWithoutJobPostInput[] | JobStageUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: JobStageCreateOrConnectWithoutJobPostInput | JobStageCreateOrConnectWithoutJobPostInput[]
    upsert?: JobStageUpsertWithWhereUniqueWithoutJobPostInput | JobStageUpsertWithWhereUniqueWithoutJobPostInput[]
    createMany?: JobStageCreateManyJobPostInputEnvelope
    set?: JobStageWhereUniqueInput | JobStageWhereUniqueInput[]
    disconnect?: JobStageWhereUniqueInput | JobStageWhereUniqueInput[]
    delete?: JobStageWhereUniqueInput | JobStageWhereUniqueInput[]
    connect?: JobStageWhereUniqueInput | JobStageWhereUniqueInput[]
    update?: JobStageUpdateWithWhereUniqueWithoutJobPostInput | JobStageUpdateWithWhereUniqueWithoutJobPostInput[]
    updateMany?: JobStageUpdateManyWithWhereWithoutJobPostInput | JobStageUpdateManyWithWhereWithoutJobPostInput[]
    deleteMany?: JobStageScalarWhereInput | JobStageScalarWhereInput[]
  }

  export type JobPreviewUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<JobPreviewCreateWithoutJobPostInput, JobPreviewUncheckedCreateWithoutJobPostInput> | JobPreviewCreateWithoutJobPostInput[] | JobPreviewUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: JobPreviewCreateOrConnectWithoutJobPostInput | JobPreviewCreateOrConnectWithoutJobPostInput[]
    upsert?: JobPreviewUpsertWithWhereUniqueWithoutJobPostInput | JobPreviewUpsertWithWhereUniqueWithoutJobPostInput[]
    createMany?: JobPreviewCreateManyJobPostInputEnvelope
    set?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
    disconnect?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
    delete?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
    connect?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
    update?: JobPreviewUpdateWithWhereUniqueWithoutJobPostInput | JobPreviewUpdateWithWhereUniqueWithoutJobPostInput[]
    updateMany?: JobPreviewUpdateManyWithWhereWithoutJobPostInput | JobPreviewUpdateManyWithWhereWithoutJobPostInput[]
    deleteMany?: JobPreviewScalarWhereInput | JobPreviewScalarWhereInput[]
  }

  export type CandidateApplicationUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<CandidateApplicationCreateWithoutJobPostInput, CandidateApplicationUncheckedCreateWithoutJobPostInput> | CandidateApplicationCreateWithoutJobPostInput[] | CandidateApplicationUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: CandidateApplicationCreateOrConnectWithoutJobPostInput | CandidateApplicationCreateOrConnectWithoutJobPostInput[]
    upsert?: CandidateApplicationUpsertWithWhereUniqueWithoutJobPostInput | CandidateApplicationUpsertWithWhereUniqueWithoutJobPostInput[]
    createMany?: CandidateApplicationCreateManyJobPostInputEnvelope
    set?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
    disconnect?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
    delete?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
    connect?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
    update?: CandidateApplicationUpdateWithWhereUniqueWithoutJobPostInput | CandidateApplicationUpdateWithWhereUniqueWithoutJobPostInput[]
    updateMany?: CandidateApplicationUpdateManyWithWhereWithoutJobPostInput | CandidateApplicationUpdateManyWithWhereWithoutJobPostInput[]
    deleteMany?: CandidateApplicationScalarWhereInput | CandidateApplicationScalarWhereInput[]
  }

  export type CandidateTimelineUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<CandidateTimelineCreateWithoutJobPostInput, CandidateTimelineUncheckedCreateWithoutJobPostInput> | CandidateTimelineCreateWithoutJobPostInput[] | CandidateTimelineUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: CandidateTimelineCreateOrConnectWithoutJobPostInput | CandidateTimelineCreateOrConnectWithoutJobPostInput[]
    upsert?: CandidateTimelineUpsertWithWhereUniqueWithoutJobPostInput | CandidateTimelineUpsertWithWhereUniqueWithoutJobPostInput[]
    createMany?: CandidateTimelineCreateManyJobPostInputEnvelope
    set?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    disconnect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    delete?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    connect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    update?: CandidateTimelineUpdateWithWhereUniqueWithoutJobPostInput | CandidateTimelineUpdateWithWhereUniqueWithoutJobPostInput[]
    updateMany?: CandidateTimelineUpdateManyWithWhereWithoutJobPostInput | CandidateTimelineUpdateManyWithWhereWithoutJobPostInput[]
    deleteMany?: CandidateTimelineScalarWhereInput | CandidateTimelineScalarWhereInput[]
  }

  export type JobMailingTemplateUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<JobMailingTemplateCreateWithoutJobPostInput, JobMailingTemplateUncheckedCreateWithoutJobPostInput> | JobMailingTemplateCreateWithoutJobPostInput[] | JobMailingTemplateUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: JobMailingTemplateCreateOrConnectWithoutJobPostInput | JobMailingTemplateCreateOrConnectWithoutJobPostInput[]
    upsert?: JobMailingTemplateUpsertWithWhereUniqueWithoutJobPostInput | JobMailingTemplateUpsertWithWhereUniqueWithoutJobPostInput[]
    createMany?: JobMailingTemplateCreateManyJobPostInputEnvelope
    set?: JobMailingTemplateWhereUniqueInput | JobMailingTemplateWhereUniqueInput[]
    disconnect?: JobMailingTemplateWhereUniqueInput | JobMailingTemplateWhereUniqueInput[]
    delete?: JobMailingTemplateWhereUniqueInput | JobMailingTemplateWhereUniqueInput[]
    connect?: JobMailingTemplateWhereUniqueInput | JobMailingTemplateWhereUniqueInput[]
    update?: JobMailingTemplateUpdateWithWhereUniqueWithoutJobPostInput | JobMailingTemplateUpdateWithWhereUniqueWithoutJobPostInput[]
    updateMany?: JobMailingTemplateUpdateManyWithWhereWithoutJobPostInput | JobMailingTemplateUpdateManyWithWhereWithoutJobPostInput[]
    deleteMany?: JobMailingTemplateScalarWhereInput | JobMailingTemplateScalarWhereInput[]
  }

  export type JobApplicationUncheckedUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<JobApplicationCreateWithoutJobPostInput, JobApplicationUncheckedCreateWithoutJobPostInput> | JobApplicationCreateWithoutJobPostInput[] | JobApplicationUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobPostInput | JobApplicationCreateOrConnectWithoutJobPostInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutJobPostInput | JobApplicationUpsertWithWhereUniqueWithoutJobPostInput[]
    createMany?: JobApplicationCreateManyJobPostInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutJobPostInput | JobApplicationUpdateWithWhereUniqueWithoutJobPostInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutJobPostInput | JobApplicationUpdateManyWithWhereWithoutJobPostInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type JobStageUncheckedUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<JobStageCreateWithoutJobPostInput, JobStageUncheckedCreateWithoutJobPostInput> | JobStageCreateWithoutJobPostInput[] | JobStageUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: JobStageCreateOrConnectWithoutJobPostInput | JobStageCreateOrConnectWithoutJobPostInput[]
    upsert?: JobStageUpsertWithWhereUniqueWithoutJobPostInput | JobStageUpsertWithWhereUniqueWithoutJobPostInput[]
    createMany?: JobStageCreateManyJobPostInputEnvelope
    set?: JobStageWhereUniqueInput | JobStageWhereUniqueInput[]
    disconnect?: JobStageWhereUniqueInput | JobStageWhereUniqueInput[]
    delete?: JobStageWhereUniqueInput | JobStageWhereUniqueInput[]
    connect?: JobStageWhereUniqueInput | JobStageWhereUniqueInput[]
    update?: JobStageUpdateWithWhereUniqueWithoutJobPostInput | JobStageUpdateWithWhereUniqueWithoutJobPostInput[]
    updateMany?: JobStageUpdateManyWithWhereWithoutJobPostInput | JobStageUpdateManyWithWhereWithoutJobPostInput[]
    deleteMany?: JobStageScalarWhereInput | JobStageScalarWhereInput[]
  }

  export type JobPreviewUncheckedUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<JobPreviewCreateWithoutJobPostInput, JobPreviewUncheckedCreateWithoutJobPostInput> | JobPreviewCreateWithoutJobPostInput[] | JobPreviewUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: JobPreviewCreateOrConnectWithoutJobPostInput | JobPreviewCreateOrConnectWithoutJobPostInput[]
    upsert?: JobPreviewUpsertWithWhereUniqueWithoutJobPostInput | JobPreviewUpsertWithWhereUniqueWithoutJobPostInput[]
    createMany?: JobPreviewCreateManyJobPostInputEnvelope
    set?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
    disconnect?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
    delete?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
    connect?: JobPreviewWhereUniqueInput | JobPreviewWhereUniqueInput[]
    update?: JobPreviewUpdateWithWhereUniqueWithoutJobPostInput | JobPreviewUpdateWithWhereUniqueWithoutJobPostInput[]
    updateMany?: JobPreviewUpdateManyWithWhereWithoutJobPostInput | JobPreviewUpdateManyWithWhereWithoutJobPostInput[]
    deleteMany?: JobPreviewScalarWhereInput | JobPreviewScalarWhereInput[]
  }

  export type CandidateApplicationUncheckedUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<CandidateApplicationCreateWithoutJobPostInput, CandidateApplicationUncheckedCreateWithoutJobPostInput> | CandidateApplicationCreateWithoutJobPostInput[] | CandidateApplicationUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: CandidateApplicationCreateOrConnectWithoutJobPostInput | CandidateApplicationCreateOrConnectWithoutJobPostInput[]
    upsert?: CandidateApplicationUpsertWithWhereUniqueWithoutJobPostInput | CandidateApplicationUpsertWithWhereUniqueWithoutJobPostInput[]
    createMany?: CandidateApplicationCreateManyJobPostInputEnvelope
    set?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
    disconnect?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
    delete?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
    connect?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
    update?: CandidateApplicationUpdateWithWhereUniqueWithoutJobPostInput | CandidateApplicationUpdateWithWhereUniqueWithoutJobPostInput[]
    updateMany?: CandidateApplicationUpdateManyWithWhereWithoutJobPostInput | CandidateApplicationUpdateManyWithWhereWithoutJobPostInput[]
    deleteMany?: CandidateApplicationScalarWhereInput | CandidateApplicationScalarWhereInput[]
  }

  export type CandidateTimelineUncheckedUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<CandidateTimelineCreateWithoutJobPostInput, CandidateTimelineUncheckedCreateWithoutJobPostInput> | CandidateTimelineCreateWithoutJobPostInput[] | CandidateTimelineUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: CandidateTimelineCreateOrConnectWithoutJobPostInput | CandidateTimelineCreateOrConnectWithoutJobPostInput[]
    upsert?: CandidateTimelineUpsertWithWhereUniqueWithoutJobPostInput | CandidateTimelineUpsertWithWhereUniqueWithoutJobPostInput[]
    createMany?: CandidateTimelineCreateManyJobPostInputEnvelope
    set?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    disconnect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    delete?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    connect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    update?: CandidateTimelineUpdateWithWhereUniqueWithoutJobPostInput | CandidateTimelineUpdateWithWhereUniqueWithoutJobPostInput[]
    updateMany?: CandidateTimelineUpdateManyWithWhereWithoutJobPostInput | CandidateTimelineUpdateManyWithWhereWithoutJobPostInput[]
    deleteMany?: CandidateTimelineScalarWhereInput | CandidateTimelineScalarWhereInput[]
  }

  export type JobMailingTemplateUncheckedUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<JobMailingTemplateCreateWithoutJobPostInput, JobMailingTemplateUncheckedCreateWithoutJobPostInput> | JobMailingTemplateCreateWithoutJobPostInput[] | JobMailingTemplateUncheckedCreateWithoutJobPostInput[]
    connectOrCreate?: JobMailingTemplateCreateOrConnectWithoutJobPostInput | JobMailingTemplateCreateOrConnectWithoutJobPostInput[]
    upsert?: JobMailingTemplateUpsertWithWhereUniqueWithoutJobPostInput | JobMailingTemplateUpsertWithWhereUniqueWithoutJobPostInput[]
    createMany?: JobMailingTemplateCreateManyJobPostInputEnvelope
    set?: JobMailingTemplateWhereUniqueInput | JobMailingTemplateWhereUniqueInput[]
    disconnect?: JobMailingTemplateWhereUniqueInput | JobMailingTemplateWhereUniqueInput[]
    delete?: JobMailingTemplateWhereUniqueInput | JobMailingTemplateWhereUniqueInput[]
    connect?: JobMailingTemplateWhereUniqueInput | JobMailingTemplateWhereUniqueInput[]
    update?: JobMailingTemplateUpdateWithWhereUniqueWithoutJobPostInput | JobMailingTemplateUpdateWithWhereUniqueWithoutJobPostInput[]
    updateMany?: JobMailingTemplateUpdateManyWithWhereWithoutJobPostInput | JobMailingTemplateUpdateManyWithWhereWithoutJobPostInput[]
    deleteMany?: JobMailingTemplateScalarWhereInput | JobMailingTemplateScalarWhereInput[]
  }

  export type JobApplicationCreateoptionInput = {
    set: string[]
  }

  export type JobPostCreateNestedOneWithoutJobApplicationInput = {
    create?: XOR<JobPostCreateWithoutJobApplicationInput, JobPostUncheckedCreateWithoutJobApplicationInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutJobApplicationInput
    connect?: JobPostWhereUniqueInput
  }

  export type FormResponseCreateNestedManyWithoutJobApplicationInput = {
    create?: XOR<FormResponseCreateWithoutJobApplicationInput, FormResponseUncheckedCreateWithoutJobApplicationInput> | FormResponseCreateWithoutJobApplicationInput[] | FormResponseUncheckedCreateWithoutJobApplicationInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutJobApplicationInput | FormResponseCreateOrConnectWithoutJobApplicationInput[]
    createMany?: FormResponseCreateManyJobApplicationInputEnvelope
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
  }

  export type FormResponseUncheckedCreateNestedManyWithoutJobApplicationInput = {
    create?: XOR<FormResponseCreateWithoutJobApplicationInput, FormResponseUncheckedCreateWithoutJobApplicationInput> | FormResponseCreateWithoutJobApplicationInput[] | FormResponseUncheckedCreateWithoutJobApplicationInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutJobApplicationInput | FormResponseCreateOrConnectWithoutJobApplicationInput[]
    createMany?: FormResponseCreateManyJobApplicationInputEnvelope
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
  }

  export type JobApplicationUpdateoptionInput = {
    set?: string[]
    push?: string | string[]
  }

  export type JobPostUpdateOneRequiredWithoutJobApplicationNestedInput = {
    create?: XOR<JobPostCreateWithoutJobApplicationInput, JobPostUncheckedCreateWithoutJobApplicationInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutJobApplicationInput
    upsert?: JobPostUpsertWithoutJobApplicationInput
    connect?: JobPostWhereUniqueInput
    update?: XOR<XOR<JobPostUpdateToOneWithWhereWithoutJobApplicationInput, JobPostUpdateWithoutJobApplicationInput>, JobPostUncheckedUpdateWithoutJobApplicationInput>
  }

  export type FormResponseUpdateManyWithoutJobApplicationNestedInput = {
    create?: XOR<FormResponseCreateWithoutJobApplicationInput, FormResponseUncheckedCreateWithoutJobApplicationInput> | FormResponseCreateWithoutJobApplicationInput[] | FormResponseUncheckedCreateWithoutJobApplicationInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutJobApplicationInput | FormResponseCreateOrConnectWithoutJobApplicationInput[]
    upsert?: FormResponseUpsertWithWhereUniqueWithoutJobApplicationInput | FormResponseUpsertWithWhereUniqueWithoutJobApplicationInput[]
    createMany?: FormResponseCreateManyJobApplicationInputEnvelope
    set?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    disconnect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    delete?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    update?: FormResponseUpdateWithWhereUniqueWithoutJobApplicationInput | FormResponseUpdateWithWhereUniqueWithoutJobApplicationInput[]
    updateMany?: FormResponseUpdateManyWithWhereWithoutJobApplicationInput | FormResponseUpdateManyWithWhereWithoutJobApplicationInput[]
    deleteMany?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
  }

  export type FormResponseUncheckedUpdateManyWithoutJobApplicationNestedInput = {
    create?: XOR<FormResponseCreateWithoutJobApplicationInput, FormResponseUncheckedCreateWithoutJobApplicationInput> | FormResponseCreateWithoutJobApplicationInput[] | FormResponseUncheckedCreateWithoutJobApplicationInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutJobApplicationInput | FormResponseCreateOrConnectWithoutJobApplicationInput[]
    upsert?: FormResponseUpsertWithWhereUniqueWithoutJobApplicationInput | FormResponseUpsertWithWhereUniqueWithoutJobApplicationInput[]
    createMany?: FormResponseCreateManyJobApplicationInputEnvelope
    set?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    disconnect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    delete?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    update?: FormResponseUpdateWithWhereUniqueWithoutJobApplicationInput | FormResponseUpdateWithWhereUniqueWithoutJobApplicationInput[]
    updateMany?: FormResponseUpdateManyWithWhereWithoutJobApplicationInput | FormResponseUpdateManyWithWhereWithoutJobApplicationInput[]
    deleteMany?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
  }

  export type JobPostCreateNestedOneWithoutCandidateApplicationInput = {
    create?: XOR<JobPostCreateWithoutCandidateApplicationInput, JobPostUncheckedCreateWithoutCandidateApplicationInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutCandidateApplicationInput
    connect?: JobPostWhereUniqueInput
  }

  export type JobStageCreateNestedOneWithoutCandidateStageInput = {
    create?: XOR<JobStageCreateWithoutCandidateStageInput, JobStageUncheckedCreateWithoutCandidateStageInput>
    connectOrCreate?: JobStageCreateOrConnectWithoutCandidateStageInput
    connect?: JobStageWhereUniqueInput
  }

  export type FormResponseCreateNestedManyWithoutCandidateApplicationInput = {
    create?: XOR<FormResponseCreateWithoutCandidateApplicationInput, FormResponseUncheckedCreateWithoutCandidateApplicationInput> | FormResponseCreateWithoutCandidateApplicationInput[] | FormResponseUncheckedCreateWithoutCandidateApplicationInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutCandidateApplicationInput | FormResponseCreateOrConnectWithoutCandidateApplicationInput[]
    createMany?: FormResponseCreateManyCandidateApplicationInputEnvelope
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
  }

  export type EmailMessageCreateNestedManyWithoutCandidateInput = {
    create?: XOR<EmailMessageCreateWithoutCandidateInput, EmailMessageUncheckedCreateWithoutCandidateInput> | EmailMessageCreateWithoutCandidateInput[] | EmailMessageUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutCandidateInput | EmailMessageCreateOrConnectWithoutCandidateInput[]
    createMany?: EmailMessageCreateManyCandidateInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type CandidateTimelineCreateNestedManyWithoutCandidateApplicationInput = {
    create?: XOR<CandidateTimelineCreateWithoutCandidateApplicationInput, CandidateTimelineUncheckedCreateWithoutCandidateApplicationInput> | CandidateTimelineCreateWithoutCandidateApplicationInput[] | CandidateTimelineUncheckedCreateWithoutCandidateApplicationInput[]
    connectOrCreate?: CandidateTimelineCreateOrConnectWithoutCandidateApplicationInput | CandidateTimelineCreateOrConnectWithoutCandidateApplicationInput[]
    createMany?: CandidateTimelineCreateManyCandidateApplicationInputEnvelope
    connect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
  }

  export type FormResponseUncheckedCreateNestedManyWithoutCandidateApplicationInput = {
    create?: XOR<FormResponseCreateWithoutCandidateApplicationInput, FormResponseUncheckedCreateWithoutCandidateApplicationInput> | FormResponseCreateWithoutCandidateApplicationInput[] | FormResponseUncheckedCreateWithoutCandidateApplicationInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutCandidateApplicationInput | FormResponseCreateOrConnectWithoutCandidateApplicationInput[]
    createMany?: FormResponseCreateManyCandidateApplicationInputEnvelope
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
  }

  export type EmailMessageUncheckedCreateNestedManyWithoutCandidateInput = {
    create?: XOR<EmailMessageCreateWithoutCandidateInput, EmailMessageUncheckedCreateWithoutCandidateInput> | EmailMessageCreateWithoutCandidateInput[] | EmailMessageUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutCandidateInput | EmailMessageCreateOrConnectWithoutCandidateInput[]
    createMany?: EmailMessageCreateManyCandidateInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type CandidateTimelineUncheckedCreateNestedManyWithoutCandidateApplicationInput = {
    create?: XOR<CandidateTimelineCreateWithoutCandidateApplicationInput, CandidateTimelineUncheckedCreateWithoutCandidateApplicationInput> | CandidateTimelineCreateWithoutCandidateApplicationInput[] | CandidateTimelineUncheckedCreateWithoutCandidateApplicationInput[]
    connectOrCreate?: CandidateTimelineCreateOrConnectWithoutCandidateApplicationInput | CandidateTimelineCreateOrConnectWithoutCandidateApplicationInput[]
    createMany?: CandidateTimelineCreateManyCandidateApplicationInputEnvelope
    connect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
  }

  export type JobPostUpdateOneRequiredWithoutCandidateApplicationNestedInput = {
    create?: XOR<JobPostCreateWithoutCandidateApplicationInput, JobPostUncheckedCreateWithoutCandidateApplicationInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutCandidateApplicationInput
    upsert?: JobPostUpsertWithoutCandidateApplicationInput
    connect?: JobPostWhereUniqueInput
    update?: XOR<XOR<JobPostUpdateToOneWithWhereWithoutCandidateApplicationInput, JobPostUpdateWithoutCandidateApplicationInput>, JobPostUncheckedUpdateWithoutCandidateApplicationInput>
  }

  export type JobStageUpdateOneRequiredWithoutCandidateStageNestedInput = {
    create?: XOR<JobStageCreateWithoutCandidateStageInput, JobStageUncheckedCreateWithoutCandidateStageInput>
    connectOrCreate?: JobStageCreateOrConnectWithoutCandidateStageInput
    upsert?: JobStageUpsertWithoutCandidateStageInput
    connect?: JobStageWhereUniqueInput
    update?: XOR<XOR<JobStageUpdateToOneWithWhereWithoutCandidateStageInput, JobStageUpdateWithoutCandidateStageInput>, JobStageUncheckedUpdateWithoutCandidateStageInput>
  }

  export type FormResponseUpdateManyWithoutCandidateApplicationNestedInput = {
    create?: XOR<FormResponseCreateWithoutCandidateApplicationInput, FormResponseUncheckedCreateWithoutCandidateApplicationInput> | FormResponseCreateWithoutCandidateApplicationInput[] | FormResponseUncheckedCreateWithoutCandidateApplicationInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutCandidateApplicationInput | FormResponseCreateOrConnectWithoutCandidateApplicationInput[]
    upsert?: FormResponseUpsertWithWhereUniqueWithoutCandidateApplicationInput | FormResponseUpsertWithWhereUniqueWithoutCandidateApplicationInput[]
    createMany?: FormResponseCreateManyCandidateApplicationInputEnvelope
    set?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    disconnect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    delete?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    update?: FormResponseUpdateWithWhereUniqueWithoutCandidateApplicationInput | FormResponseUpdateWithWhereUniqueWithoutCandidateApplicationInput[]
    updateMany?: FormResponseUpdateManyWithWhereWithoutCandidateApplicationInput | FormResponseUpdateManyWithWhereWithoutCandidateApplicationInput[]
    deleteMany?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
  }

  export type EmailMessageUpdateManyWithoutCandidateNestedInput = {
    create?: XOR<EmailMessageCreateWithoutCandidateInput, EmailMessageUncheckedCreateWithoutCandidateInput> | EmailMessageCreateWithoutCandidateInput[] | EmailMessageUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutCandidateInput | EmailMessageCreateOrConnectWithoutCandidateInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutCandidateInput | EmailMessageUpsertWithWhereUniqueWithoutCandidateInput[]
    createMany?: EmailMessageCreateManyCandidateInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutCandidateInput | EmailMessageUpdateWithWhereUniqueWithoutCandidateInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutCandidateInput | EmailMessageUpdateManyWithWhereWithoutCandidateInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type CandidateTimelineUpdateManyWithoutCandidateApplicationNestedInput = {
    create?: XOR<CandidateTimelineCreateWithoutCandidateApplicationInput, CandidateTimelineUncheckedCreateWithoutCandidateApplicationInput> | CandidateTimelineCreateWithoutCandidateApplicationInput[] | CandidateTimelineUncheckedCreateWithoutCandidateApplicationInput[]
    connectOrCreate?: CandidateTimelineCreateOrConnectWithoutCandidateApplicationInput | CandidateTimelineCreateOrConnectWithoutCandidateApplicationInput[]
    upsert?: CandidateTimelineUpsertWithWhereUniqueWithoutCandidateApplicationInput | CandidateTimelineUpsertWithWhereUniqueWithoutCandidateApplicationInput[]
    createMany?: CandidateTimelineCreateManyCandidateApplicationInputEnvelope
    set?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    disconnect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    delete?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    connect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    update?: CandidateTimelineUpdateWithWhereUniqueWithoutCandidateApplicationInput | CandidateTimelineUpdateWithWhereUniqueWithoutCandidateApplicationInput[]
    updateMany?: CandidateTimelineUpdateManyWithWhereWithoutCandidateApplicationInput | CandidateTimelineUpdateManyWithWhereWithoutCandidateApplicationInput[]
    deleteMany?: CandidateTimelineScalarWhereInput | CandidateTimelineScalarWhereInput[]
  }

  export type FormResponseUncheckedUpdateManyWithoutCandidateApplicationNestedInput = {
    create?: XOR<FormResponseCreateWithoutCandidateApplicationInput, FormResponseUncheckedCreateWithoutCandidateApplicationInput> | FormResponseCreateWithoutCandidateApplicationInput[] | FormResponseUncheckedCreateWithoutCandidateApplicationInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutCandidateApplicationInput | FormResponseCreateOrConnectWithoutCandidateApplicationInput[]
    upsert?: FormResponseUpsertWithWhereUniqueWithoutCandidateApplicationInput | FormResponseUpsertWithWhereUniqueWithoutCandidateApplicationInput[]
    createMany?: FormResponseCreateManyCandidateApplicationInputEnvelope
    set?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    disconnect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    delete?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    update?: FormResponseUpdateWithWhereUniqueWithoutCandidateApplicationInput | FormResponseUpdateWithWhereUniqueWithoutCandidateApplicationInput[]
    updateMany?: FormResponseUpdateManyWithWhereWithoutCandidateApplicationInput | FormResponseUpdateManyWithWhereWithoutCandidateApplicationInput[]
    deleteMany?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
  }

  export type EmailMessageUncheckedUpdateManyWithoutCandidateNestedInput = {
    create?: XOR<EmailMessageCreateWithoutCandidateInput, EmailMessageUncheckedCreateWithoutCandidateInput> | EmailMessageCreateWithoutCandidateInput[] | EmailMessageUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutCandidateInput | EmailMessageCreateOrConnectWithoutCandidateInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutCandidateInput | EmailMessageUpsertWithWhereUniqueWithoutCandidateInput[]
    createMany?: EmailMessageCreateManyCandidateInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutCandidateInput | EmailMessageUpdateWithWhereUniqueWithoutCandidateInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutCandidateInput | EmailMessageUpdateManyWithWhereWithoutCandidateInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type CandidateTimelineUncheckedUpdateManyWithoutCandidateApplicationNestedInput = {
    create?: XOR<CandidateTimelineCreateWithoutCandidateApplicationInput, CandidateTimelineUncheckedCreateWithoutCandidateApplicationInput> | CandidateTimelineCreateWithoutCandidateApplicationInput[] | CandidateTimelineUncheckedCreateWithoutCandidateApplicationInput[]
    connectOrCreate?: CandidateTimelineCreateOrConnectWithoutCandidateApplicationInput | CandidateTimelineCreateOrConnectWithoutCandidateApplicationInput[]
    upsert?: CandidateTimelineUpsertWithWhereUniqueWithoutCandidateApplicationInput | CandidateTimelineUpsertWithWhereUniqueWithoutCandidateApplicationInput[]
    createMany?: CandidateTimelineCreateManyCandidateApplicationInputEnvelope
    set?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    disconnect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    delete?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    connect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    update?: CandidateTimelineUpdateWithWhereUniqueWithoutCandidateApplicationInput | CandidateTimelineUpdateWithWhereUniqueWithoutCandidateApplicationInput[]
    updateMany?: CandidateTimelineUpdateManyWithWhereWithoutCandidateApplicationInput | CandidateTimelineUpdateManyWithWhereWithoutCandidateApplicationInput[]
    deleteMany?: CandidateTimelineScalarWhereInput | CandidateTimelineScalarWhereInput[]
  }

  export type CandidateTimelineCreateNestedManyWithoutCandidateReviewInput = {
    create?: XOR<CandidateTimelineCreateWithoutCandidateReviewInput, CandidateTimelineUncheckedCreateWithoutCandidateReviewInput> | CandidateTimelineCreateWithoutCandidateReviewInput[] | CandidateTimelineUncheckedCreateWithoutCandidateReviewInput[]
    connectOrCreate?: CandidateTimelineCreateOrConnectWithoutCandidateReviewInput | CandidateTimelineCreateOrConnectWithoutCandidateReviewInput[]
    createMany?: CandidateTimelineCreateManyCandidateReviewInputEnvelope
    connect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
  }

  export type CandidateTimelineUncheckedCreateNestedManyWithoutCandidateReviewInput = {
    create?: XOR<CandidateTimelineCreateWithoutCandidateReviewInput, CandidateTimelineUncheckedCreateWithoutCandidateReviewInput> | CandidateTimelineCreateWithoutCandidateReviewInput[] | CandidateTimelineUncheckedCreateWithoutCandidateReviewInput[]
    connectOrCreate?: CandidateTimelineCreateOrConnectWithoutCandidateReviewInput | CandidateTimelineCreateOrConnectWithoutCandidateReviewInput[]
    createMany?: CandidateTimelineCreateManyCandidateReviewInputEnvelope
    connect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
  }

  export type CandidateTimelineUpdateManyWithoutCandidateReviewNestedInput = {
    create?: XOR<CandidateTimelineCreateWithoutCandidateReviewInput, CandidateTimelineUncheckedCreateWithoutCandidateReviewInput> | CandidateTimelineCreateWithoutCandidateReviewInput[] | CandidateTimelineUncheckedCreateWithoutCandidateReviewInput[]
    connectOrCreate?: CandidateTimelineCreateOrConnectWithoutCandidateReviewInput | CandidateTimelineCreateOrConnectWithoutCandidateReviewInput[]
    upsert?: CandidateTimelineUpsertWithWhereUniqueWithoutCandidateReviewInput | CandidateTimelineUpsertWithWhereUniqueWithoutCandidateReviewInput[]
    createMany?: CandidateTimelineCreateManyCandidateReviewInputEnvelope
    set?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    disconnect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    delete?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    connect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    update?: CandidateTimelineUpdateWithWhereUniqueWithoutCandidateReviewInput | CandidateTimelineUpdateWithWhereUniqueWithoutCandidateReviewInput[]
    updateMany?: CandidateTimelineUpdateManyWithWhereWithoutCandidateReviewInput | CandidateTimelineUpdateManyWithWhereWithoutCandidateReviewInput[]
    deleteMany?: CandidateTimelineScalarWhereInput | CandidateTimelineScalarWhereInput[]
  }

  export type CandidateTimelineUncheckedUpdateManyWithoutCandidateReviewNestedInput = {
    create?: XOR<CandidateTimelineCreateWithoutCandidateReviewInput, CandidateTimelineUncheckedCreateWithoutCandidateReviewInput> | CandidateTimelineCreateWithoutCandidateReviewInput[] | CandidateTimelineUncheckedCreateWithoutCandidateReviewInput[]
    connectOrCreate?: CandidateTimelineCreateOrConnectWithoutCandidateReviewInput | CandidateTimelineCreateOrConnectWithoutCandidateReviewInput[]
    upsert?: CandidateTimelineUpsertWithWhereUniqueWithoutCandidateReviewInput | CandidateTimelineUpsertWithWhereUniqueWithoutCandidateReviewInput[]
    createMany?: CandidateTimelineCreateManyCandidateReviewInputEnvelope
    set?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    disconnect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    delete?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    connect?: CandidateTimelineWhereUniqueInput | CandidateTimelineWhereUniqueInput[]
    update?: CandidateTimelineUpdateWithWhereUniqueWithoutCandidateReviewInput | CandidateTimelineUpdateWithWhereUniqueWithoutCandidateReviewInput[]
    updateMany?: CandidateTimelineUpdateManyWithWhereWithoutCandidateReviewInput | CandidateTimelineUpdateManyWithWhereWithoutCandidateReviewInput[]
    deleteMany?: CandidateTimelineScalarWhereInput | CandidateTimelineScalarWhereInput[]
  }

  export type CandidateReviewCreateNestedOneWithoutCandidateTimelineInput = {
    create?: XOR<CandidateReviewCreateWithoutCandidateTimelineInput, CandidateReviewUncheckedCreateWithoutCandidateTimelineInput>
    connectOrCreate?: CandidateReviewCreateOrConnectWithoutCandidateTimelineInput
    connect?: CandidateReviewWhereUniqueInput
  }

  export type CandidateApplicationCreateNestedOneWithoutCandidateTimelineInput = {
    create?: XOR<CandidateApplicationCreateWithoutCandidateTimelineInput, CandidateApplicationUncheckedCreateWithoutCandidateTimelineInput>
    connectOrCreate?: CandidateApplicationCreateOrConnectWithoutCandidateTimelineInput
    connect?: CandidateApplicationWhereUniqueInput
  }

  export type JobPostCreateNestedOneWithoutCandidateTimelineInput = {
    create?: XOR<JobPostCreateWithoutCandidateTimelineInput, JobPostUncheckedCreateWithoutCandidateTimelineInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutCandidateTimelineInput
    connect?: JobPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCandidateTimelineInput = {
    create?: XOR<UserCreateWithoutCandidateTimelineInput, UserUncheckedCreateWithoutCandidateTimelineInput>
    connectOrCreate?: UserCreateOrConnectWithoutCandidateTimelineInput
    connect?: UserWhereUniqueInput
  }

  export type CandidateReviewUpdateOneWithoutCandidateTimelineNestedInput = {
    create?: XOR<CandidateReviewCreateWithoutCandidateTimelineInput, CandidateReviewUncheckedCreateWithoutCandidateTimelineInput>
    connectOrCreate?: CandidateReviewCreateOrConnectWithoutCandidateTimelineInput
    upsert?: CandidateReviewUpsertWithoutCandidateTimelineInput
    disconnect?: CandidateReviewWhereInput | boolean
    delete?: CandidateReviewWhereInput | boolean
    connect?: CandidateReviewWhereUniqueInput
    update?: XOR<XOR<CandidateReviewUpdateToOneWithWhereWithoutCandidateTimelineInput, CandidateReviewUpdateWithoutCandidateTimelineInput>, CandidateReviewUncheckedUpdateWithoutCandidateTimelineInput>
  }

  export type CandidateApplicationUpdateOneRequiredWithoutCandidateTimelineNestedInput = {
    create?: XOR<CandidateApplicationCreateWithoutCandidateTimelineInput, CandidateApplicationUncheckedCreateWithoutCandidateTimelineInput>
    connectOrCreate?: CandidateApplicationCreateOrConnectWithoutCandidateTimelineInput
    upsert?: CandidateApplicationUpsertWithoutCandidateTimelineInput
    connect?: CandidateApplicationWhereUniqueInput
    update?: XOR<XOR<CandidateApplicationUpdateToOneWithWhereWithoutCandidateTimelineInput, CandidateApplicationUpdateWithoutCandidateTimelineInput>, CandidateApplicationUncheckedUpdateWithoutCandidateTimelineInput>
  }

  export type JobPostUpdateOneRequiredWithoutCandidateTimelineNestedInput = {
    create?: XOR<JobPostCreateWithoutCandidateTimelineInput, JobPostUncheckedCreateWithoutCandidateTimelineInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutCandidateTimelineInput
    upsert?: JobPostUpsertWithoutCandidateTimelineInput
    connect?: JobPostWhereUniqueInput
    update?: XOR<XOR<JobPostUpdateToOneWithWhereWithoutCandidateTimelineInput, JobPostUpdateWithoutCandidateTimelineInput>, JobPostUncheckedUpdateWithoutCandidateTimelineInput>
  }

  export type UserUpdateOneWithoutCandidateTimelineNestedInput = {
    create?: XOR<UserCreateWithoutCandidateTimelineInput, UserUncheckedCreateWithoutCandidateTimelineInput>
    connectOrCreate?: UserCreateOrConnectWithoutCandidateTimelineInput
    upsert?: UserUpsertWithoutCandidateTimelineInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCandidateTimelineInput, UserUpdateWithoutCandidateTimelineInput>, UserUncheckedUpdateWithoutCandidateTimelineInput>
  }

  export type CandidateApplicationCreateNestedOneWithoutFormResponsesInput = {
    create?: XOR<CandidateApplicationCreateWithoutFormResponsesInput, CandidateApplicationUncheckedCreateWithoutFormResponsesInput>
    connectOrCreate?: CandidateApplicationCreateOrConnectWithoutFormResponsesInput
    connect?: CandidateApplicationWhereUniqueInput
  }

  export type JobApplicationCreateNestedOneWithoutFormResponseInput = {
    create?: XOR<JobApplicationCreateWithoutFormResponseInput, JobApplicationUncheckedCreateWithoutFormResponseInput>
    connectOrCreate?: JobApplicationCreateOrConnectWithoutFormResponseInput
    connect?: JobApplicationWhereUniqueInput
  }

  export type CandidateApplicationUpdateOneRequiredWithoutFormResponsesNestedInput = {
    create?: XOR<CandidateApplicationCreateWithoutFormResponsesInput, CandidateApplicationUncheckedCreateWithoutFormResponsesInput>
    connectOrCreate?: CandidateApplicationCreateOrConnectWithoutFormResponsesInput
    upsert?: CandidateApplicationUpsertWithoutFormResponsesInput
    connect?: CandidateApplicationWhereUniqueInput
    update?: XOR<XOR<CandidateApplicationUpdateToOneWithWhereWithoutFormResponsesInput, CandidateApplicationUpdateWithoutFormResponsesInput>, CandidateApplicationUncheckedUpdateWithoutFormResponsesInput>
  }

  export type JobApplicationUpdateOneRequiredWithoutFormResponseNestedInput = {
    create?: XOR<JobApplicationCreateWithoutFormResponseInput, JobApplicationUncheckedCreateWithoutFormResponseInput>
    connectOrCreate?: JobApplicationCreateOrConnectWithoutFormResponseInput
    upsert?: JobApplicationUpsertWithoutFormResponseInput
    connect?: JobApplicationWhereUniqueInput
    update?: XOR<XOR<JobApplicationUpdateToOneWithWhereWithoutFormResponseInput, JobApplicationUpdateWithoutFormResponseInput>, JobApplicationUncheckedUpdateWithoutFormResponseInput>
  }

  export type OrganizationCreateNestedOneWithoutJobPreviewInput = {
    create?: XOR<OrganizationCreateWithoutJobPreviewInput, OrganizationUncheckedCreateWithoutJobPreviewInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutJobPreviewInput
    connect?: OrganizationWhereUniqueInput
  }

  export type JobPostCreateNestedOneWithoutJobPreviewInput = {
    create?: XOR<JobPostCreateWithoutJobPreviewInput, JobPostUncheckedCreateWithoutJobPreviewInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutJobPreviewInput
    connect?: JobPostWhereUniqueInput
  }

  export type OrganizationUpdateOneWithoutJobPreviewNestedInput = {
    create?: XOR<OrganizationCreateWithoutJobPreviewInput, OrganizationUncheckedCreateWithoutJobPreviewInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutJobPreviewInput
    upsert?: OrganizationUpsertWithoutJobPreviewInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutJobPreviewInput, OrganizationUpdateWithoutJobPreviewInput>, OrganizationUncheckedUpdateWithoutJobPreviewInput>
  }

  export type JobPostUpdateOneRequiredWithoutJobPreviewNestedInput = {
    create?: XOR<JobPostCreateWithoutJobPreviewInput, JobPostUncheckedCreateWithoutJobPreviewInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutJobPreviewInput
    upsert?: JobPostUpsertWithoutJobPreviewInput
    connect?: JobPostWhereUniqueInput
    update?: XOR<XOR<JobPostUpdateToOneWithWhereWithoutJobPreviewInput, JobPostUpdateWithoutJobPreviewInput>, JobPostUncheckedUpdateWithoutJobPreviewInput>
  }

  export type JobPostCreateNestedOneWithoutJobStageInput = {
    create?: XOR<JobPostCreateWithoutJobStageInput, JobPostUncheckedCreateWithoutJobStageInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutJobStageInput
    connect?: JobPostWhereUniqueInput
  }

  export type CandidateApplicationCreateNestedManyWithoutJobStageInput = {
    create?: XOR<CandidateApplicationCreateWithoutJobStageInput, CandidateApplicationUncheckedCreateWithoutJobStageInput> | CandidateApplicationCreateWithoutJobStageInput[] | CandidateApplicationUncheckedCreateWithoutJobStageInput[]
    connectOrCreate?: CandidateApplicationCreateOrConnectWithoutJobStageInput | CandidateApplicationCreateOrConnectWithoutJobStageInput[]
    createMany?: CandidateApplicationCreateManyJobStageInputEnvelope
    connect?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
  }

  export type CandidateApplicationUncheckedCreateNestedManyWithoutJobStageInput = {
    create?: XOR<CandidateApplicationCreateWithoutJobStageInput, CandidateApplicationUncheckedCreateWithoutJobStageInput> | CandidateApplicationCreateWithoutJobStageInput[] | CandidateApplicationUncheckedCreateWithoutJobStageInput[]
    connectOrCreate?: CandidateApplicationCreateOrConnectWithoutJobStageInput | CandidateApplicationCreateOrConnectWithoutJobStageInput[]
    createMany?: CandidateApplicationCreateManyJobStageInputEnvelope
    connect?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JobPostUpdateOneRequiredWithoutJobStageNestedInput = {
    create?: XOR<JobPostCreateWithoutJobStageInput, JobPostUncheckedCreateWithoutJobStageInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutJobStageInput
    upsert?: JobPostUpsertWithoutJobStageInput
    connect?: JobPostWhereUniqueInput
    update?: XOR<XOR<JobPostUpdateToOneWithWhereWithoutJobStageInput, JobPostUpdateWithoutJobStageInput>, JobPostUncheckedUpdateWithoutJobStageInput>
  }

  export type CandidateApplicationUpdateManyWithoutJobStageNestedInput = {
    create?: XOR<CandidateApplicationCreateWithoutJobStageInput, CandidateApplicationUncheckedCreateWithoutJobStageInput> | CandidateApplicationCreateWithoutJobStageInput[] | CandidateApplicationUncheckedCreateWithoutJobStageInput[]
    connectOrCreate?: CandidateApplicationCreateOrConnectWithoutJobStageInput | CandidateApplicationCreateOrConnectWithoutJobStageInput[]
    upsert?: CandidateApplicationUpsertWithWhereUniqueWithoutJobStageInput | CandidateApplicationUpsertWithWhereUniqueWithoutJobStageInput[]
    createMany?: CandidateApplicationCreateManyJobStageInputEnvelope
    set?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
    disconnect?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
    delete?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
    connect?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
    update?: CandidateApplicationUpdateWithWhereUniqueWithoutJobStageInput | CandidateApplicationUpdateWithWhereUniqueWithoutJobStageInput[]
    updateMany?: CandidateApplicationUpdateManyWithWhereWithoutJobStageInput | CandidateApplicationUpdateManyWithWhereWithoutJobStageInput[]
    deleteMany?: CandidateApplicationScalarWhereInput | CandidateApplicationScalarWhereInput[]
  }

  export type CandidateApplicationUncheckedUpdateManyWithoutJobStageNestedInput = {
    create?: XOR<CandidateApplicationCreateWithoutJobStageInput, CandidateApplicationUncheckedCreateWithoutJobStageInput> | CandidateApplicationCreateWithoutJobStageInput[] | CandidateApplicationUncheckedCreateWithoutJobStageInput[]
    connectOrCreate?: CandidateApplicationCreateOrConnectWithoutJobStageInput | CandidateApplicationCreateOrConnectWithoutJobStageInput[]
    upsert?: CandidateApplicationUpsertWithWhereUniqueWithoutJobStageInput | CandidateApplicationUpsertWithWhereUniqueWithoutJobStageInput[]
    createMany?: CandidateApplicationCreateManyJobStageInputEnvelope
    set?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
    disconnect?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
    delete?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
    connect?: CandidateApplicationWhereUniqueInput | CandidateApplicationWhereUniqueInput[]
    update?: CandidateApplicationUpdateWithWhereUniqueWithoutJobStageInput | CandidateApplicationUpdateWithWhereUniqueWithoutJobStageInput[]
    updateMany?: CandidateApplicationUpdateManyWithWhereWithoutJobStageInput | CandidateApplicationUpdateManyWithWhereWithoutJobStageInput[]
    deleteMany?: CandidateApplicationScalarWhereInput | CandidateApplicationScalarWhereInput[]
  }

  export type JobPostCreateNestedOneWithoutJobMailingTemplateInput = {
    create?: XOR<JobPostCreateWithoutJobMailingTemplateInput, JobPostUncheckedCreateWithoutJobMailingTemplateInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutJobMailingTemplateInput
    connect?: JobPostWhereUniqueInput
  }

  export type JobPostUpdateOneRequiredWithoutJobMailingTemplateNestedInput = {
    create?: XOR<JobPostCreateWithoutJobMailingTemplateInput, JobPostUncheckedCreateWithoutJobMailingTemplateInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutJobMailingTemplateInput
    upsert?: JobPostUpsertWithoutJobMailingTemplateInput
    connect?: JobPostWhereUniqueInput
    update?: XOR<XOR<JobPostUpdateToOneWithWhereWithoutJobMailingTemplateInput, JobPostUpdateWithoutJobMailingTemplateInput>, JobPostUncheckedUpdateWithoutJobMailingTemplateInput>
  }

  export type UserCreateNestedOneWithoutEmailMessageInput = {
    create?: XOR<UserCreateWithoutEmailMessageInput, UserUncheckedCreateWithoutEmailMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailMessageInput
    connect?: UserWhereUniqueInput
  }

  export type CandidateApplicationCreateNestedOneWithoutEmailMessageInput = {
    create?: XOR<CandidateApplicationCreateWithoutEmailMessageInput, CandidateApplicationUncheckedCreateWithoutEmailMessageInput>
    connectOrCreate?: CandidateApplicationCreateOrConnectWithoutEmailMessageInput
    connect?: CandidateApplicationWhereUniqueInput
  }

  export type EmailMessageCreateNestedOneWithoutRepliesInput = {
    create?: XOR<EmailMessageCreateWithoutRepliesInput, EmailMessageUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: EmailMessageCreateOrConnectWithoutRepliesInput
    connect?: EmailMessageWhereUniqueInput
  }

  export type EmailMessageCreateNestedManyWithoutParentMessageInput = {
    create?: XOR<EmailMessageCreateWithoutParentMessageInput, EmailMessageUncheckedCreateWithoutParentMessageInput> | EmailMessageCreateWithoutParentMessageInput[] | EmailMessageUncheckedCreateWithoutParentMessageInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutParentMessageInput | EmailMessageCreateOrConnectWithoutParentMessageInput[]
    createMany?: EmailMessageCreateManyParentMessageInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type EmailMessageUncheckedCreateNestedManyWithoutParentMessageInput = {
    create?: XOR<EmailMessageCreateWithoutParentMessageInput, EmailMessageUncheckedCreateWithoutParentMessageInput> | EmailMessageCreateWithoutParentMessageInput[] | EmailMessageUncheckedCreateWithoutParentMessageInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutParentMessageInput | EmailMessageCreateOrConnectWithoutParentMessageInput[]
    createMany?: EmailMessageCreateManyParentMessageInputEnvelope
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
  }

  export type EnumEmailDirectionFieldUpdateOperationsInput = {
    set?: $Enums.EmailDirection
  }

  export type UserUpdateOneRequiredWithoutEmailMessageNestedInput = {
    create?: XOR<UserCreateWithoutEmailMessageInput, UserUncheckedCreateWithoutEmailMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailMessageInput
    upsert?: UserUpsertWithoutEmailMessageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailMessageInput, UserUpdateWithoutEmailMessageInput>, UserUncheckedUpdateWithoutEmailMessageInput>
  }

  export type CandidateApplicationUpdateOneRequiredWithoutEmailMessageNestedInput = {
    create?: XOR<CandidateApplicationCreateWithoutEmailMessageInput, CandidateApplicationUncheckedCreateWithoutEmailMessageInput>
    connectOrCreate?: CandidateApplicationCreateOrConnectWithoutEmailMessageInput
    upsert?: CandidateApplicationUpsertWithoutEmailMessageInput
    connect?: CandidateApplicationWhereUniqueInput
    update?: XOR<XOR<CandidateApplicationUpdateToOneWithWhereWithoutEmailMessageInput, CandidateApplicationUpdateWithoutEmailMessageInput>, CandidateApplicationUncheckedUpdateWithoutEmailMessageInput>
  }

  export type EmailMessageUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<EmailMessageCreateWithoutRepliesInput, EmailMessageUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: EmailMessageCreateOrConnectWithoutRepliesInput
    upsert?: EmailMessageUpsertWithoutRepliesInput
    disconnect?: EmailMessageWhereInput | boolean
    delete?: EmailMessageWhereInput | boolean
    connect?: EmailMessageWhereUniqueInput
    update?: XOR<XOR<EmailMessageUpdateToOneWithWhereWithoutRepliesInput, EmailMessageUpdateWithoutRepliesInput>, EmailMessageUncheckedUpdateWithoutRepliesInput>
  }

  export type EmailMessageUpdateManyWithoutParentMessageNestedInput = {
    create?: XOR<EmailMessageCreateWithoutParentMessageInput, EmailMessageUncheckedCreateWithoutParentMessageInput> | EmailMessageCreateWithoutParentMessageInput[] | EmailMessageUncheckedCreateWithoutParentMessageInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutParentMessageInput | EmailMessageCreateOrConnectWithoutParentMessageInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutParentMessageInput | EmailMessageUpsertWithWhereUniqueWithoutParentMessageInput[]
    createMany?: EmailMessageCreateManyParentMessageInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutParentMessageInput | EmailMessageUpdateWithWhereUniqueWithoutParentMessageInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutParentMessageInput | EmailMessageUpdateManyWithWhereWithoutParentMessageInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type EmailMessageUncheckedUpdateManyWithoutParentMessageNestedInput = {
    create?: XOR<EmailMessageCreateWithoutParentMessageInput, EmailMessageUncheckedCreateWithoutParentMessageInput> | EmailMessageCreateWithoutParentMessageInput[] | EmailMessageUncheckedCreateWithoutParentMessageInput[]
    connectOrCreate?: EmailMessageCreateOrConnectWithoutParentMessageInput | EmailMessageCreateOrConnectWithoutParentMessageInput[]
    upsert?: EmailMessageUpsertWithWhereUniqueWithoutParentMessageInput | EmailMessageUpsertWithWhereUniqueWithoutParentMessageInput[]
    createMany?: EmailMessageCreateManyParentMessageInputEnvelope
    set?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    disconnect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    delete?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    connect?: EmailMessageWhereUniqueInput | EmailMessageWhereUniqueInput[]
    update?: EmailMessageUpdateWithWhereUniqueWithoutParentMessageInput | EmailMessageUpdateWithWhereUniqueWithoutParentMessageInput[]
    updateMany?: EmailMessageUpdateManyWithWhereWithoutParentMessageInput | EmailMessageUpdateManyWithWhereWithoutParentMessageInput[]
    deleteMany?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutNotificationInput = {
    create?: XOR<OrganizationCreateWithoutNotificationInput, OrganizationUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutNotificationInput
    connect?: OrganizationWhereUniqueInput
  }

  export type NotificationReceiptCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationReceiptCreateWithoutNotificationInput, NotificationReceiptUncheckedCreateWithoutNotificationInput> | NotificationReceiptCreateWithoutNotificationInput[] | NotificationReceiptUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationReceiptCreateOrConnectWithoutNotificationInput | NotificationReceiptCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationReceiptCreateManyNotificationInputEnvelope
    connect?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
  }

  export type NotificationReceiptUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationReceiptCreateWithoutNotificationInput, NotificationReceiptUncheckedCreateWithoutNotificationInput> | NotificationReceiptCreateWithoutNotificationInput[] | NotificationReceiptUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationReceiptCreateOrConnectWithoutNotificationInput | NotificationReceiptCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationReceiptCreateManyNotificationInputEnvelope
    connect?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type OrganizationUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<OrganizationCreateWithoutNotificationInput, OrganizationUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutNotificationInput
    upsert?: OrganizationUpsertWithoutNotificationInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutNotificationInput, OrganizationUpdateWithoutNotificationInput>, OrganizationUncheckedUpdateWithoutNotificationInput>
  }

  export type NotificationReceiptUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationReceiptCreateWithoutNotificationInput, NotificationReceiptUncheckedCreateWithoutNotificationInput> | NotificationReceiptCreateWithoutNotificationInput[] | NotificationReceiptUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationReceiptCreateOrConnectWithoutNotificationInput | NotificationReceiptCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationReceiptUpsertWithWhereUniqueWithoutNotificationInput | NotificationReceiptUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationReceiptCreateManyNotificationInputEnvelope
    set?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
    disconnect?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
    delete?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
    connect?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
    update?: NotificationReceiptUpdateWithWhereUniqueWithoutNotificationInput | NotificationReceiptUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationReceiptUpdateManyWithWhereWithoutNotificationInput | NotificationReceiptUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationReceiptScalarWhereInput | NotificationReceiptScalarWhereInput[]
  }

  export type NotificationReceiptUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationReceiptCreateWithoutNotificationInput, NotificationReceiptUncheckedCreateWithoutNotificationInput> | NotificationReceiptCreateWithoutNotificationInput[] | NotificationReceiptUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationReceiptCreateOrConnectWithoutNotificationInput | NotificationReceiptCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationReceiptUpsertWithWhereUniqueWithoutNotificationInput | NotificationReceiptUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationReceiptCreateManyNotificationInputEnvelope
    set?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
    disconnect?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
    delete?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
    connect?: NotificationReceiptWhereUniqueInput | NotificationReceiptWhereUniqueInput[]
    update?: NotificationReceiptUpdateWithWhereUniqueWithoutNotificationInput | NotificationReceiptUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationReceiptUpdateManyWithWhereWithoutNotificationInput | NotificationReceiptUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationReceiptScalarWhereInput | NotificationReceiptScalarWhereInput[]
  }

  export type NotificationCreateNestedOneWithoutReceiptsInput = {
    create?: XOR<NotificationCreateWithoutReceiptsInput, NotificationUncheckedCreateWithoutReceiptsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutReceiptsInput
    connect?: NotificationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationReceiptInput = {
    create?: XOR<UserCreateWithoutNotificationReceiptInput, UserUncheckedCreateWithoutNotificationReceiptInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationReceiptInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationUpdateOneRequiredWithoutReceiptsNestedInput = {
    create?: XOR<NotificationCreateWithoutReceiptsInput, NotificationUncheckedCreateWithoutReceiptsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutReceiptsInput
    upsert?: NotificationUpsertWithoutReceiptsInput
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutReceiptsInput, NotificationUpdateWithoutReceiptsInput>, NotificationUncheckedUpdateWithoutReceiptsInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationReceiptNestedInput = {
    create?: XOR<UserCreateWithoutNotificationReceiptInput, UserUncheckedCreateWithoutNotificationReceiptInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationReceiptInput
    upsert?: UserUpsertWithoutNotificationReceiptInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationReceiptInput, UserUpdateWithoutNotificationReceiptInput>, UserUncheckedUpdateWithoutNotificationReceiptInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumOrganizationRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.OrganizationRole | EnumOrganizationRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrganizationRole[] | ListEnumOrganizationRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrganizationRole[] | ListEnumOrganizationRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrganizationRoleFilter<$PrismaModel> | $Enums.OrganizationRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumOrganizationRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrganizationRole | EnumOrganizationRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrganizationRole[] | ListEnumOrganizationRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrganizationRole[] | ListEnumOrganizationRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrganizationRoleWithAggregatesFilter<$PrismaModel> | $Enums.OrganizationRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrganizationRoleFilter<$PrismaModel>
    _max?: NestedEnumOrganizationRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumEmailDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailDirection | EnumEmailDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.EmailDirection[] | ListEnumEmailDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailDirection[] | ListEnumEmailDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailDirectionFilter<$PrismaModel> | $Enums.EmailDirection
  }

  export type NestedEnumEmailDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailDirection | EnumEmailDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.EmailDirection[] | ListEnumEmailDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailDirection[] | ListEnumEmailDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailDirectionWithAggregatesFilter<$PrismaModel> | $Enums.EmailDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailDirectionFilter<$PrismaModel>
    _max?: NestedEnumEmailDirectionFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type OrganizationCreateWithoutOrganizationRoleInput = {
    id?: string
    name: string
    url?: string | null
    logo?: string | null
    assignedDomain?: string | null
    customDomain?: string | null
    createdAt?: Date | string
    organizationActionLog?: OrganizationActivityLogCreateNestedManyWithoutOrganizationInput
    jobPost?: JobPostCreateNestedManyWithoutOrganizationInput
    payment?: PaymentCreateNestedManyWithoutOrganizationInput
    jobPreview?: JobPreviewCreateNestedManyWithoutOrganizationInput
    organizationSubscription?: OrganizationSubscriptionCreateNestedManyWithoutOrganizationInput
    Notification?: NotificationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutOrganizationRoleInput = {
    id?: string
    name: string
    url?: string | null
    logo?: string | null
    assignedDomain?: string | null
    customDomain?: string | null
    createdAt?: Date | string
    organizationActionLog?: OrganizationActivityLogUncheckedCreateNestedManyWithoutOrganizationInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutOrganizationInput
    payment?: PaymentUncheckedCreateNestedManyWithoutOrganizationInput
    jobPreview?: JobPreviewUncheckedCreateNestedManyWithoutOrganizationInput
    organizationSubscription?: OrganizationSubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutOrganizationRoleInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutOrganizationRoleInput, OrganizationUncheckedCreateWithoutOrganizationRoleInput>
  }

  export type UserCreateWithoutOrganizationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    twoFactorConfirmation?: TwoFactorConfirmationCreateNestedOneWithoutUserInput
    candidateTimeline?: CandidateTimelineCreateNestedManyWithoutUserInput
    emailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    organizationSubscription?: OrganizationSubscriptionCreateNestedManyWithoutUserInput
    NotificationReceipt?: NotificationReceiptCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInput
    candidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutUserInput
    emailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    organizationSubscription?: OrganizationSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationReceipt?: NotificationReceiptUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
  }

  export type OrganizationUpsertWithoutOrganizationRoleInput = {
    update: XOR<OrganizationUpdateWithoutOrganizationRoleInput, OrganizationUncheckedUpdateWithoutOrganizationRoleInput>
    create: XOR<OrganizationCreateWithoutOrganizationRoleInput, OrganizationUncheckedCreateWithoutOrganizationRoleInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutOrganizationRoleInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutOrganizationRoleInput, OrganizationUncheckedUpdateWithoutOrganizationRoleInput>
  }

  export type OrganizationUpdateWithoutOrganizationRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationActionLog?: OrganizationActivityLogUpdateManyWithoutOrganizationNestedInput
    jobPost?: JobPostUpdateManyWithoutOrganizationNestedInput
    payment?: PaymentUpdateManyWithoutOrganizationNestedInput
    jobPreview?: JobPreviewUpdateManyWithoutOrganizationNestedInput
    organizationSubscription?: OrganizationSubscriptionUpdateManyWithoutOrganizationNestedInput
    Notification?: NotificationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutOrganizationRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationActionLog?: OrganizationActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutOrganizationNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    jobPreview?: JobPreviewUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationSubscription?: OrganizationSubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutOrganizationsInput = {
    update: XOR<UserUpdateWithoutOrganizationsInput, UserUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrganizationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrganizationsInput, UserUncheckedUpdateWithoutOrganizationsInput>
  }

  export type UserUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    twoFactorConfirmation?: TwoFactorConfirmationUpdateOneWithoutUserNestedInput
    candidateTimeline?: CandidateTimelineUpdateManyWithoutUserNestedInput
    emailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    organizationSubscription?: OrganizationSubscriptionUpdateManyWithoutUserNestedInput
    NotificationReceipt?: NotificationReceiptUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInput
    candidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutUserNestedInput
    emailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    organizationSubscription?: OrganizationSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationReceipt?: NotificationReceiptUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUserRoleCreateWithoutUserInput = {
    id?: string
    role: $Enums.OrganizationRole
    email: string
    status?: string
    createdAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutOrganizationRoleInput
  }

  export type OrganizationUserRoleUncheckedCreateWithoutUserInput = {
    id?: string
    role: $Enums.OrganizationRole
    organizationId: string
    email: string
    status?: string
    createdAt?: Date | string
  }

  export type OrganizationUserRoleCreateOrConnectWithoutUserInput = {
    where: OrganizationUserRoleWhereUniqueInput
    create: XOR<OrganizationUserRoleCreateWithoutUserInput, OrganizationUserRoleUncheckedCreateWithoutUserInput>
  }

  export type OrganizationUserRoleCreateManyUserInputEnvelope = {
    data: OrganizationUserRoleCreateManyUserInput | OrganizationUserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TwoFactorConfirmationCreateWithoutUserInput = {
    id?: string
  }

  export type TwoFactorConfirmationUncheckedCreateWithoutUserInput = {
    id?: string
  }

  export type TwoFactorConfirmationCreateOrConnectWithoutUserInput = {
    where: TwoFactorConfirmationWhereUniqueInput
    create: XOR<TwoFactorConfirmationCreateWithoutUserInput, TwoFactorConfirmationUncheckedCreateWithoutUserInput>
  }

  export type CandidateTimelineCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    actionType: string
    timelineText: string
    comment?: string | null
    candidateReview?: CandidateReviewCreateNestedOneWithoutCandidateTimelineInput
    candidateApplication: CandidateApplicationCreateNestedOneWithoutCandidateTimelineInput
    jobPost: JobPostCreateNestedOneWithoutCandidateTimelineInput
  }

  export type CandidateTimelineUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    actionType: string
    jobId: string
    timelineText: string
    comment?: string | null
    reviewId?: string | null
    candidateId: string
  }

  export type CandidateTimelineCreateOrConnectWithoutUserInput = {
    where: CandidateTimelineWhereUniqueInput
    create: XOR<CandidateTimelineCreateWithoutUserInput, CandidateTimelineUncheckedCreateWithoutUserInput>
  }

  export type CandidateTimelineCreateManyUserInputEnvelope = {
    data: CandidateTimelineCreateManyUserInput | CandidateTimelineCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailMessageCreateWithoutUserInput = {
    id?: string
    messageId: string
    sender: string
    recipient: string
    subject: string
    body: string
    s3Url?: string | null
    direction: $Enums.EmailDirection
    createdAt?: Date | string
    candidate: CandidateApplicationCreateNestedOneWithoutEmailMessageInput
    parentMessage?: EmailMessageCreateNestedOneWithoutRepliesInput
    replies?: EmailMessageCreateNestedManyWithoutParentMessageInput
  }

  export type EmailMessageUncheckedCreateWithoutUserInput = {
    id?: string
    messageId: string
    parentMessageId?: string | null
    sender: string
    recipient: string
    subject: string
    body: string
    s3Url?: string | null
    direction: $Enums.EmailDirection
    createdAt?: Date | string
    candidateId: string
    replies?: EmailMessageUncheckedCreateNestedManyWithoutParentMessageInput
  }

  export type EmailMessageCreateOrConnectWithoutUserInput = {
    where: EmailMessageWhereUniqueInput
    create: XOR<EmailMessageCreateWithoutUserInput, EmailMessageUncheckedCreateWithoutUserInput>
  }

  export type EmailMessageCreateManyUserInputEnvelope = {
    data: EmailMessageCreateManyUserInput | EmailMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationSubscriptionCreateWithoutUserInput = {
    id?: string
    referalId?: string | null
    paymentHandler: string
    status?: $Enums.SubscriptionStatus
    subscriptionType: string
    createdAt?: Date | string
    expiresOn: Date | string
    organization: OrganizationCreateNestedOneWithoutOrganizationSubscriptionInput
  }

  export type OrganizationSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    referalId?: string | null
    paymentHandler: string
    organizationId: string
    status?: $Enums.SubscriptionStatus
    subscriptionType: string
    createdAt?: Date | string
    expiresOn: Date | string
  }

  export type OrganizationSubscriptionCreateOrConnectWithoutUserInput = {
    where: OrganizationSubscriptionWhereUniqueInput
    create: XOR<OrganizationSubscriptionCreateWithoutUserInput, OrganizationSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type OrganizationSubscriptionCreateManyUserInputEnvelope = {
    data: OrganizationSubscriptionCreateManyUserInput | OrganizationSubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationReceiptCreateWithoutUserInput = {
    id?: string
    isRead?: boolean
    readAt?: Date | string | null
    notification: NotificationCreateNestedOneWithoutReceiptsInput
  }

  export type NotificationReceiptUncheckedCreateWithoutUserInput = {
    id?: string
    notificationId: string
    isRead?: boolean
    readAt?: Date | string | null
  }

  export type NotificationReceiptCreateOrConnectWithoutUserInput = {
    where: NotificationReceiptWhereUniqueInput
    create: XOR<NotificationReceiptCreateWithoutUserInput, NotificationReceiptUncheckedCreateWithoutUserInput>
  }

  export type NotificationReceiptCreateManyUserInputEnvelope = {
    data: NotificationReceiptCreateManyUserInput | NotificationReceiptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    message: string
    createdAt?: Date | string
    type?: string
    category?: string
    actionUrl?: string | null
    priority?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    organization?: OrganizationCreateNestedOneWithoutNotificationInput
    receipts?: NotificationReceiptCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    message: string
    createdAt?: Date | string
    type?: string
    category?: string
    actionUrl?: string | null
    priority?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    organizationId?: string | null
    receipts?: NotificationReceiptUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type OrganizationUserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: OrganizationUserRoleWhereUniqueInput
    update: XOR<OrganizationUserRoleUpdateWithoutUserInput, OrganizationUserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<OrganizationUserRoleCreateWithoutUserInput, OrganizationUserRoleUncheckedCreateWithoutUserInput>
  }

  export type OrganizationUserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: OrganizationUserRoleWhereUniqueInput
    data: XOR<OrganizationUserRoleUpdateWithoutUserInput, OrganizationUserRoleUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationUserRoleUpdateManyWithWhereWithoutUserInput = {
    where: OrganizationUserRoleScalarWhereInput
    data: XOR<OrganizationUserRoleUpdateManyMutationInput, OrganizationUserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type OrganizationUserRoleScalarWhereInput = {
    AND?: OrganizationUserRoleScalarWhereInput | OrganizationUserRoleScalarWhereInput[]
    OR?: OrganizationUserRoleScalarWhereInput[]
    NOT?: OrganizationUserRoleScalarWhereInput | OrganizationUserRoleScalarWhereInput[]
    id?: StringFilter<"OrganizationUserRole"> | string
    role?: EnumOrganizationRoleFilter<"OrganizationUserRole"> | $Enums.OrganizationRole
    organizationId?: StringFilter<"OrganizationUserRole"> | string
    email?: StringFilter<"OrganizationUserRole"> | string
    userId?: StringNullableFilter<"OrganizationUserRole"> | string | null
    status?: StringFilter<"OrganizationUserRole"> | string
    createdAt?: DateTimeFilter<"OrganizationUserRole"> | Date | string
  }

  export type TwoFactorConfirmationUpsertWithoutUserInput = {
    update: XOR<TwoFactorConfirmationUpdateWithoutUserInput, TwoFactorConfirmationUncheckedUpdateWithoutUserInput>
    create: XOR<TwoFactorConfirmationCreateWithoutUserInput, TwoFactorConfirmationUncheckedCreateWithoutUserInput>
    where?: TwoFactorConfirmationWhereInput
  }

  export type TwoFactorConfirmationUpdateToOneWithWhereWithoutUserInput = {
    where?: TwoFactorConfirmationWhereInput
    data: XOR<TwoFactorConfirmationUpdateWithoutUserInput, TwoFactorConfirmationUncheckedUpdateWithoutUserInput>
  }

  export type TwoFactorConfirmationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TwoFactorConfirmationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type CandidateTimelineUpsertWithWhereUniqueWithoutUserInput = {
    where: CandidateTimelineWhereUniqueInput
    update: XOR<CandidateTimelineUpdateWithoutUserInput, CandidateTimelineUncheckedUpdateWithoutUserInput>
    create: XOR<CandidateTimelineCreateWithoutUserInput, CandidateTimelineUncheckedCreateWithoutUserInput>
  }

  export type CandidateTimelineUpdateWithWhereUniqueWithoutUserInput = {
    where: CandidateTimelineWhereUniqueInput
    data: XOR<CandidateTimelineUpdateWithoutUserInput, CandidateTimelineUncheckedUpdateWithoutUserInput>
  }

  export type CandidateTimelineUpdateManyWithWhereWithoutUserInput = {
    where: CandidateTimelineScalarWhereInput
    data: XOR<CandidateTimelineUpdateManyMutationInput, CandidateTimelineUncheckedUpdateManyWithoutUserInput>
  }

  export type CandidateTimelineScalarWhereInput = {
    AND?: CandidateTimelineScalarWhereInput | CandidateTimelineScalarWhereInput[]
    OR?: CandidateTimelineScalarWhereInput[]
    NOT?: CandidateTimelineScalarWhereInput | CandidateTimelineScalarWhereInput[]
    id?: StringFilter<"CandidateTimeline"> | string
    createdAt?: DateTimeFilter<"CandidateTimeline"> | Date | string
    userId?: StringNullableFilter<"CandidateTimeline"> | string | null
    actionType?: StringFilter<"CandidateTimeline"> | string
    jobId?: StringFilter<"CandidateTimeline"> | string
    timelineText?: StringFilter<"CandidateTimeline"> | string
    comment?: StringNullableFilter<"CandidateTimeline"> | string | null
    reviewId?: StringNullableFilter<"CandidateTimeline"> | string | null
    candidateId?: StringFilter<"CandidateTimeline"> | string
  }

  export type EmailMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailMessageWhereUniqueInput
    update: XOR<EmailMessageUpdateWithoutUserInput, EmailMessageUncheckedUpdateWithoutUserInput>
    create: XOR<EmailMessageCreateWithoutUserInput, EmailMessageUncheckedCreateWithoutUserInput>
  }

  export type EmailMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailMessageWhereUniqueInput
    data: XOR<EmailMessageUpdateWithoutUserInput, EmailMessageUncheckedUpdateWithoutUserInput>
  }

  export type EmailMessageUpdateManyWithWhereWithoutUserInput = {
    where: EmailMessageScalarWhereInput
    data: XOR<EmailMessageUpdateManyMutationInput, EmailMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailMessageScalarWhereInput = {
    AND?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
    OR?: EmailMessageScalarWhereInput[]
    NOT?: EmailMessageScalarWhereInput | EmailMessageScalarWhereInput[]
    id?: StringFilter<"EmailMessage"> | string
    messageId?: StringFilter<"EmailMessage"> | string
    parentMessageId?: StringNullableFilter<"EmailMessage"> | string | null
    sender?: StringFilter<"EmailMessage"> | string
    recipient?: StringFilter<"EmailMessage"> | string
    subject?: StringFilter<"EmailMessage"> | string
    body?: StringFilter<"EmailMessage"> | string
    s3Url?: StringNullableFilter<"EmailMessage"> | string | null
    direction?: EnumEmailDirectionFilter<"EmailMessage"> | $Enums.EmailDirection
    createdAt?: DateTimeFilter<"EmailMessage"> | Date | string
    userId?: StringFilter<"EmailMessage"> | string
    candidateId?: StringFilter<"EmailMessage"> | string
  }

  export type OrganizationSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: OrganizationSubscriptionWhereUniqueInput
    update: XOR<OrganizationSubscriptionUpdateWithoutUserInput, OrganizationSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<OrganizationSubscriptionCreateWithoutUserInput, OrganizationSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type OrganizationSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: OrganizationSubscriptionWhereUniqueInput
    data: XOR<OrganizationSubscriptionUpdateWithoutUserInput, OrganizationSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: OrganizationSubscriptionScalarWhereInput
    data: XOR<OrganizationSubscriptionUpdateManyMutationInput, OrganizationSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type OrganizationSubscriptionScalarWhereInput = {
    AND?: OrganizationSubscriptionScalarWhereInput | OrganizationSubscriptionScalarWhereInput[]
    OR?: OrganizationSubscriptionScalarWhereInput[]
    NOT?: OrganizationSubscriptionScalarWhereInput | OrganizationSubscriptionScalarWhereInput[]
    id?: StringFilter<"OrganizationSubscription"> | string
    referalId?: StringNullableFilter<"OrganizationSubscription"> | string | null
    paymentHandler?: StringFilter<"OrganizationSubscription"> | string
    organizationId?: StringFilter<"OrganizationSubscription"> | string
    status?: EnumSubscriptionStatusFilter<"OrganizationSubscription"> | $Enums.SubscriptionStatus
    subscriptionType?: StringFilter<"OrganizationSubscription"> | string
    userId?: StringFilter<"OrganizationSubscription"> | string
    createdAt?: DateTimeFilter<"OrganizationSubscription"> | Date | string
    expiresOn?: DateTimeFilter<"OrganizationSubscription"> | Date | string
  }

  export type NotificationReceiptUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationReceiptWhereUniqueInput
    update: XOR<NotificationReceiptUpdateWithoutUserInput, NotificationReceiptUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationReceiptCreateWithoutUserInput, NotificationReceiptUncheckedCreateWithoutUserInput>
  }

  export type NotificationReceiptUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationReceiptWhereUniqueInput
    data: XOR<NotificationReceiptUpdateWithoutUserInput, NotificationReceiptUncheckedUpdateWithoutUserInput>
  }

  export type NotificationReceiptUpdateManyWithWhereWithoutUserInput = {
    where: NotificationReceiptScalarWhereInput
    data: XOR<NotificationReceiptUpdateManyMutationInput, NotificationReceiptUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationReceiptScalarWhereInput = {
    AND?: NotificationReceiptScalarWhereInput | NotificationReceiptScalarWhereInput[]
    OR?: NotificationReceiptScalarWhereInput[]
    NOT?: NotificationReceiptScalarWhereInput | NotificationReceiptScalarWhereInput[]
    id?: StringFilter<"NotificationReceipt"> | string
    notificationId?: StringFilter<"NotificationReceipt"> | string
    userId?: StringFilter<"NotificationReceipt"> | string
    isRead?: BoolFilter<"NotificationReceipt"> | boolean
    readAt?: DateTimeNullableFilter<"NotificationReceipt"> | Date | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    type?: StringFilter<"Notification"> | string
    category?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    priority?: StringFilter<"Notification"> | string
    metadata?: JsonNullableFilter<"Notification">
    userId?: StringNullableFilter<"Notification"> | string | null
    organizationId?: StringNullableFilter<"Notification"> | string | null
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    organizations?: OrganizationUserRoleCreateNestedManyWithoutUserInput
    twoFactorConfirmation?: TwoFactorConfirmationCreateNestedOneWithoutUserInput
    candidateTimeline?: CandidateTimelineCreateNestedManyWithoutUserInput
    emailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    organizationSubscription?: OrganizationSubscriptionCreateNestedManyWithoutUserInput
    NotificationReceipt?: NotificationReceiptCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    organizations?: OrganizationUserRoleUncheckedCreateNestedManyWithoutUserInput
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInput
    candidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutUserInput
    emailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    organizationSubscription?: OrganizationSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationReceipt?: NotificationReceiptUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    organizations?: OrganizationUserRoleUpdateManyWithoutUserNestedInput
    twoFactorConfirmation?: TwoFactorConfirmationUpdateOneWithoutUserNestedInput
    candidateTimeline?: CandidateTimelineUpdateManyWithoutUserNestedInput
    emailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    organizationSubscription?: OrganizationSubscriptionUpdateManyWithoutUserNestedInput
    NotificationReceipt?: NotificationReceiptUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    organizations?: OrganizationUserRoleUncheckedUpdateManyWithoutUserNestedInput
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInput
    candidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutUserNestedInput
    emailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    organizationSubscription?: OrganizationSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationReceipt?: NotificationReceiptUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTwoFactorConfirmationInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizations?: OrganizationUserRoleCreateNestedManyWithoutUserInput
    candidateTimeline?: CandidateTimelineCreateNestedManyWithoutUserInput
    emailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    organizationSubscription?: OrganizationSubscriptionCreateNestedManyWithoutUserInput
    NotificationReceipt?: NotificationReceiptCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTwoFactorConfirmationInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationUserRoleUncheckedCreateNestedManyWithoutUserInput
    candidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutUserInput
    emailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    organizationSubscription?: OrganizationSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationReceipt?: NotificationReceiptUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTwoFactorConfirmationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTwoFactorConfirmationInput, UserUncheckedCreateWithoutTwoFactorConfirmationInput>
  }

  export type UserUpsertWithoutTwoFactorConfirmationInput = {
    update: XOR<UserUpdateWithoutTwoFactorConfirmationInput, UserUncheckedUpdateWithoutTwoFactorConfirmationInput>
    create: XOR<UserCreateWithoutTwoFactorConfirmationInput, UserUncheckedCreateWithoutTwoFactorConfirmationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTwoFactorConfirmationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTwoFactorConfirmationInput, UserUncheckedUpdateWithoutTwoFactorConfirmationInput>
  }

  export type UserUpdateWithoutTwoFactorConfirmationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizations?: OrganizationUserRoleUpdateManyWithoutUserNestedInput
    candidateTimeline?: CandidateTimelineUpdateManyWithoutUserNestedInput
    emailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    organizationSubscription?: OrganizationSubscriptionUpdateManyWithoutUserNestedInput
    NotificationReceipt?: NotificationReceiptUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTwoFactorConfirmationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationUserRoleUncheckedUpdateManyWithoutUserNestedInput
    candidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutUserNestedInput
    emailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    organizationSubscription?: OrganizationSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationReceipt?: NotificationReceiptUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationUserRoleCreateWithoutOrganizationInput = {
    id?: string
    role: $Enums.OrganizationRole
    email: string
    status?: string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutOrganizationsInput
  }

  export type OrganizationUserRoleUncheckedCreateWithoutOrganizationInput = {
    id?: string
    role: $Enums.OrganizationRole
    email: string
    userId?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type OrganizationUserRoleCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationUserRoleWhereUniqueInput
    create: XOR<OrganizationUserRoleCreateWithoutOrganizationInput, OrganizationUserRoleUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationUserRoleCreateManyOrganizationInputEnvelope = {
    data: OrganizationUserRoleCreateManyOrganizationInput | OrganizationUserRoleCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationActivityLogCreateWithoutOrganizationInput = {
    id?: string
    action: string
    createdAt?: Date | string
  }

  export type OrganizationActivityLogUncheckedCreateWithoutOrganizationInput = {
    id?: string
    action: string
    createdAt?: Date | string
  }

  export type OrganizationActivityLogCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationActivityLogWhereUniqueInput
    create: XOR<OrganizationActivityLogCreateWithoutOrganizationInput, OrganizationActivityLogUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationActivityLogCreateManyOrganizationInputEnvelope = {
    data: OrganizationActivityLogCreateManyOrganizationInput | OrganizationActivityLogCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type JobPostCreateWithoutOrganizationInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    createdAt?: Date | string
    jobApplication?: JobApplicationCreateNestedManyWithoutJobPostInput
    jobStage?: JobStageCreateNestedManyWithoutJobPostInput
    jobPreview?: JobPreviewCreateNestedManyWithoutJobPostInput
    candidateApplication?: CandidateApplicationCreateNestedManyWithoutJobPostInput
    CandidateTimeline?: CandidateTimelineCreateNestedManyWithoutJobPostInput
    JobMailingTemplate?: JobMailingTemplateCreateNestedManyWithoutJobPostInput
  }

  export type JobPostUncheckedCreateWithoutOrganizationInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    createdAt?: Date | string
    jobApplication?: JobApplicationUncheckedCreateNestedManyWithoutJobPostInput
    jobStage?: JobStageUncheckedCreateNestedManyWithoutJobPostInput
    jobPreview?: JobPreviewUncheckedCreateNestedManyWithoutJobPostInput
    candidateApplication?: CandidateApplicationUncheckedCreateNestedManyWithoutJobPostInput
    CandidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutJobPostInput
    JobMailingTemplate?: JobMailingTemplateUncheckedCreateNestedManyWithoutJobPostInput
  }

  export type JobPostCreateOrConnectWithoutOrganizationInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutOrganizationInput, JobPostUncheckedCreateWithoutOrganizationInput>
  }

  export type JobPostCreateManyOrganizationInputEnvelope = {
    data: JobPostCreateManyOrganizationInput | JobPostCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutOrganizationInput = {
    id?: string
    paddlePaymentId: string
    amount: number
    currency: string
    status: $Enums.PaymentStatus
    createdAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutOrganizationInput = {
    id?: string
    paddlePaymentId: string
    amount: number
    currency: string
    status: $Enums.PaymentStatus
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutOrganizationInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrganizationInput, PaymentUncheckedCreateWithoutOrganizationInput>
  }

  export type PaymentCreateManyOrganizationInputEnvelope = {
    data: PaymentCreateManyOrganizationInput | PaymentCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type JobPreviewCreateWithoutOrganizationInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    isExpired?: boolean
    jobPost: JobPostCreateNestedOneWithoutJobPreviewInput
  }

  export type JobPreviewUncheckedCreateWithoutOrganizationInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    isExpired?: boolean
    jobId: string
  }

  export type JobPreviewCreateOrConnectWithoutOrganizationInput = {
    where: JobPreviewWhereUniqueInput
    create: XOR<JobPreviewCreateWithoutOrganizationInput, JobPreviewUncheckedCreateWithoutOrganizationInput>
  }

  export type JobPreviewCreateManyOrganizationInputEnvelope = {
    data: JobPreviewCreateManyOrganizationInput | JobPreviewCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationSubscriptionCreateWithoutOrganizationInput = {
    id?: string
    referalId?: string | null
    paymentHandler: string
    status?: $Enums.SubscriptionStatus
    subscriptionType: string
    createdAt?: Date | string
    expiresOn: Date | string
    user: UserCreateNestedOneWithoutOrganizationSubscriptionInput
  }

  export type OrganizationSubscriptionUncheckedCreateWithoutOrganizationInput = {
    id?: string
    referalId?: string | null
    paymentHandler: string
    status?: $Enums.SubscriptionStatus
    subscriptionType: string
    userId: string
    createdAt?: Date | string
    expiresOn: Date | string
  }

  export type OrganizationSubscriptionCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationSubscriptionWhereUniqueInput
    create: XOR<OrganizationSubscriptionCreateWithoutOrganizationInput, OrganizationSubscriptionUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationSubscriptionCreateManyOrganizationInputEnvelope = {
    data: OrganizationSubscriptionCreateManyOrganizationInput | OrganizationSubscriptionCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutOrganizationInput = {
    id?: string
    message: string
    createdAt?: Date | string
    type?: string
    category?: string
    actionUrl?: string | null
    priority?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserCreateNestedOneWithoutNotificationInput
    receipts?: NotificationReceiptCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    message: string
    createdAt?: Date | string
    type?: string
    category?: string
    actionUrl?: string | null
    priority?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    receipts?: NotificationReceiptUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationCreateOrConnectWithoutOrganizationInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutOrganizationInput, NotificationUncheckedCreateWithoutOrganizationInput>
  }

  export type NotificationCreateManyOrganizationInputEnvelope = {
    data: NotificationCreateManyOrganizationInput | NotificationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUserRoleUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationUserRoleWhereUniqueInput
    update: XOR<OrganizationUserRoleUpdateWithoutOrganizationInput, OrganizationUserRoleUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationUserRoleCreateWithoutOrganizationInput, OrganizationUserRoleUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationUserRoleUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationUserRoleWhereUniqueInput
    data: XOR<OrganizationUserRoleUpdateWithoutOrganizationInput, OrganizationUserRoleUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationUserRoleUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationUserRoleScalarWhereInput
    data: XOR<OrganizationUserRoleUpdateManyMutationInput, OrganizationUserRoleUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrganizationActivityLogUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationActivityLogWhereUniqueInput
    update: XOR<OrganizationActivityLogUpdateWithoutOrganizationInput, OrganizationActivityLogUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationActivityLogCreateWithoutOrganizationInput, OrganizationActivityLogUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationActivityLogUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationActivityLogWhereUniqueInput
    data: XOR<OrganizationActivityLogUpdateWithoutOrganizationInput, OrganizationActivityLogUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationActivityLogUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationActivityLogScalarWhereInput
    data: XOR<OrganizationActivityLogUpdateManyMutationInput, OrganizationActivityLogUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrganizationActivityLogScalarWhereInput = {
    AND?: OrganizationActivityLogScalarWhereInput | OrganizationActivityLogScalarWhereInput[]
    OR?: OrganizationActivityLogScalarWhereInput[]
    NOT?: OrganizationActivityLogScalarWhereInput | OrganizationActivityLogScalarWhereInput[]
    id?: StringFilter<"OrganizationActivityLog"> | string
    action?: StringFilter<"OrganizationActivityLog"> | string
    organizationId?: StringFilter<"OrganizationActivityLog"> | string
    createdAt?: DateTimeFilter<"OrganizationActivityLog"> | Date | string
  }

  export type JobPostUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: JobPostWhereUniqueInput
    update: XOR<JobPostUpdateWithoutOrganizationInput, JobPostUncheckedUpdateWithoutOrganizationInput>
    create: XOR<JobPostCreateWithoutOrganizationInput, JobPostUncheckedCreateWithoutOrganizationInput>
  }

  export type JobPostUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: JobPostWhereUniqueInput
    data: XOR<JobPostUpdateWithoutOrganizationInput, JobPostUncheckedUpdateWithoutOrganizationInput>
  }

  export type JobPostUpdateManyWithWhereWithoutOrganizationInput = {
    where: JobPostScalarWhereInput
    data: XOR<JobPostUpdateManyMutationInput, JobPostUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type JobPostScalarWhereInput = {
    AND?: JobPostScalarWhereInput | JobPostScalarWhereInput[]
    OR?: JobPostScalarWhereInput[]
    NOT?: JobPostScalarWhereInput | JobPostScalarWhereInput[]
    id?: StringFilter<"JobPost"> | string
    title?: StringFilter<"JobPost"> | string
    description?: StringNullableFilter<"JobPost"> | string | null
    category?: StringNullableFilter<"JobPost"> | string | null
    employmentType?: StringNullableFilter<"JobPost"> | string | null
    country?: StringNullableFilter<"JobPost"> | string | null
    city?: StringNullableFilter<"JobPost"> | string | null
    remoteOption?: StringNullableFilter<"JobPost"> | string | null
    countryResidence?: StringNullableFilter<"JobPost"> | string | null
    countryListResidence?: StringNullableListFilter<"JobPost">
    displaySalary?: StringNullableFilter<"JobPost"> | string | null
    currency?: StringNullableFilter<"JobPost"> | string | null
    salaryAmount?: FloatNullableFilter<"JobPost"> | number | null
    minimumAmount?: FloatNullableFilter<"JobPost"> | number | null
    maximumAmount?: FloatNullableFilter<"JobPost"> | number | null
    isPublished?: BoolFilter<"JobPost"> | boolean
    isScheduled?: BoolFilter<"JobPost"> | boolean
    isArchived?: BoolFilter<"JobPost"> | boolean
    dateStart?: DateTimeNullableFilter<"JobPost"> | Date | string | null
    dateEnd?: DateTimeNullableFilter<"JobPost"> | Date | string | null
    organizationId?: StringFilter<"JobPost"> | string
    createdAt?: DateTimeFilter<"JobPost"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutOrganizationInput, PaymentUncheckedUpdateWithoutOrganizationInput>
    create: XOR<PaymentCreateWithoutOrganizationInput, PaymentUncheckedCreateWithoutOrganizationInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutOrganizationInput, PaymentUncheckedUpdateWithoutOrganizationInput>
  }

  export type PaymentUpdateManyWithWhereWithoutOrganizationInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    organizationId?: StringFilter<"Payment"> | string
    paddlePaymentId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type JobPreviewUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: JobPreviewWhereUniqueInput
    update: XOR<JobPreviewUpdateWithoutOrganizationInput, JobPreviewUncheckedUpdateWithoutOrganizationInput>
    create: XOR<JobPreviewCreateWithoutOrganizationInput, JobPreviewUncheckedCreateWithoutOrganizationInput>
  }

  export type JobPreviewUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: JobPreviewWhereUniqueInput
    data: XOR<JobPreviewUpdateWithoutOrganizationInput, JobPreviewUncheckedUpdateWithoutOrganizationInput>
  }

  export type JobPreviewUpdateManyWithWhereWithoutOrganizationInput = {
    where: JobPreviewScalarWhereInput
    data: XOR<JobPreviewUpdateManyMutationInput, JobPreviewUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type JobPreviewScalarWhereInput = {
    AND?: JobPreviewScalarWhereInput | JobPreviewScalarWhereInput[]
    OR?: JobPreviewScalarWhereInput[]
    NOT?: JobPreviewScalarWhereInput | JobPreviewScalarWhereInput[]
    id?: StringFilter<"JobPreview"> | string
    createdAt?: DateTimeFilter<"JobPreview"> | Date | string
    expiresAt?: DateTimeFilter<"JobPreview"> | Date | string
    isExpired?: BoolFilter<"JobPreview"> | boolean
    organizationId?: StringNullableFilter<"JobPreview"> | string | null
    jobId?: StringFilter<"JobPreview"> | string
  }

  export type OrganizationSubscriptionUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationSubscriptionWhereUniqueInput
    update: XOR<OrganizationSubscriptionUpdateWithoutOrganizationInput, OrganizationSubscriptionUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationSubscriptionCreateWithoutOrganizationInput, OrganizationSubscriptionUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationSubscriptionUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationSubscriptionWhereUniqueInput
    data: XOR<OrganizationSubscriptionUpdateWithoutOrganizationInput, OrganizationSubscriptionUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationSubscriptionUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationSubscriptionScalarWhereInput
    data: XOR<OrganizationSubscriptionUpdateManyMutationInput, OrganizationSubscriptionUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutOrganizationInput, NotificationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<NotificationCreateWithoutOrganizationInput, NotificationUncheckedCreateWithoutOrganizationInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutOrganizationInput, NotificationUncheckedUpdateWithoutOrganizationInput>
  }

  export type NotificationUpdateManyWithWhereWithoutOrganizationInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrganizationCreateWithoutOrganizationSubscriptionInput = {
    id?: string
    name: string
    url?: string | null
    logo?: string | null
    assignedDomain?: string | null
    customDomain?: string | null
    createdAt?: Date | string
    organizationRole?: OrganizationUserRoleCreateNestedManyWithoutOrganizationInput
    organizationActionLog?: OrganizationActivityLogCreateNestedManyWithoutOrganizationInput
    jobPost?: JobPostCreateNestedManyWithoutOrganizationInput
    payment?: PaymentCreateNestedManyWithoutOrganizationInput
    jobPreview?: JobPreviewCreateNestedManyWithoutOrganizationInput
    Notification?: NotificationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutOrganizationSubscriptionInput = {
    id?: string
    name: string
    url?: string | null
    logo?: string | null
    assignedDomain?: string | null
    customDomain?: string | null
    createdAt?: Date | string
    organizationRole?: OrganizationUserRoleUncheckedCreateNestedManyWithoutOrganizationInput
    organizationActionLog?: OrganizationActivityLogUncheckedCreateNestedManyWithoutOrganizationInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutOrganizationInput
    payment?: PaymentUncheckedCreateNestedManyWithoutOrganizationInput
    jobPreview?: JobPreviewUncheckedCreateNestedManyWithoutOrganizationInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutOrganizationSubscriptionInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutOrganizationSubscriptionInput, OrganizationUncheckedCreateWithoutOrganizationSubscriptionInput>
  }

  export type UserCreateWithoutOrganizationSubscriptionInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizations?: OrganizationUserRoleCreateNestedManyWithoutUserInput
    twoFactorConfirmation?: TwoFactorConfirmationCreateNestedOneWithoutUserInput
    candidateTimeline?: CandidateTimelineCreateNestedManyWithoutUserInput
    emailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    NotificationReceipt?: NotificationReceiptCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationSubscriptionInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationUserRoleUncheckedCreateNestedManyWithoutUserInput
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInput
    candidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutUserInput
    emailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    NotificationReceipt?: NotificationReceiptUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationSubscriptionInput, UserUncheckedCreateWithoutOrganizationSubscriptionInput>
  }

  export type OrganizationUpsertWithoutOrganizationSubscriptionInput = {
    update: XOR<OrganizationUpdateWithoutOrganizationSubscriptionInput, OrganizationUncheckedUpdateWithoutOrganizationSubscriptionInput>
    create: XOR<OrganizationCreateWithoutOrganizationSubscriptionInput, OrganizationUncheckedCreateWithoutOrganizationSubscriptionInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutOrganizationSubscriptionInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutOrganizationSubscriptionInput, OrganizationUncheckedUpdateWithoutOrganizationSubscriptionInput>
  }

  export type OrganizationUpdateWithoutOrganizationSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationRole?: OrganizationUserRoleUpdateManyWithoutOrganizationNestedInput
    organizationActionLog?: OrganizationActivityLogUpdateManyWithoutOrganizationNestedInput
    jobPost?: JobPostUpdateManyWithoutOrganizationNestedInput
    payment?: PaymentUpdateManyWithoutOrganizationNestedInput
    jobPreview?: JobPreviewUpdateManyWithoutOrganizationNestedInput
    Notification?: NotificationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutOrganizationSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationRole?: OrganizationUserRoleUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationActionLog?: OrganizationActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutOrganizationNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    jobPreview?: JobPreviewUncheckedUpdateManyWithoutOrganizationNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutOrganizationSubscriptionInput = {
    update: XOR<UserUpdateWithoutOrganizationSubscriptionInput, UserUncheckedUpdateWithoutOrganizationSubscriptionInput>
    create: XOR<UserCreateWithoutOrganizationSubscriptionInput, UserUncheckedCreateWithoutOrganizationSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrganizationSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrganizationSubscriptionInput, UserUncheckedUpdateWithoutOrganizationSubscriptionInput>
  }

  export type UserUpdateWithoutOrganizationSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizations?: OrganizationUserRoleUpdateManyWithoutUserNestedInput
    twoFactorConfirmation?: TwoFactorConfirmationUpdateOneWithoutUserNestedInput
    candidateTimeline?: CandidateTimelineUpdateManyWithoutUserNestedInput
    emailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    NotificationReceipt?: NotificationReceiptUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationUserRoleUncheckedUpdateManyWithoutUserNestedInput
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInput
    candidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutUserNestedInput
    emailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    NotificationReceipt?: NotificationReceiptUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutPaymentInput = {
    id?: string
    name: string
    url?: string | null
    logo?: string | null
    assignedDomain?: string | null
    customDomain?: string | null
    createdAt?: Date | string
    organizationRole?: OrganizationUserRoleCreateNestedManyWithoutOrganizationInput
    organizationActionLog?: OrganizationActivityLogCreateNestedManyWithoutOrganizationInput
    jobPost?: JobPostCreateNestedManyWithoutOrganizationInput
    jobPreview?: JobPreviewCreateNestedManyWithoutOrganizationInput
    organizationSubscription?: OrganizationSubscriptionCreateNestedManyWithoutOrganizationInput
    Notification?: NotificationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutPaymentInput = {
    id?: string
    name: string
    url?: string | null
    logo?: string | null
    assignedDomain?: string | null
    customDomain?: string | null
    createdAt?: Date | string
    organizationRole?: OrganizationUserRoleUncheckedCreateNestedManyWithoutOrganizationInput
    organizationActionLog?: OrganizationActivityLogUncheckedCreateNestedManyWithoutOrganizationInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutOrganizationInput
    jobPreview?: JobPreviewUncheckedCreateNestedManyWithoutOrganizationInput
    organizationSubscription?: OrganizationSubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutPaymentInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutPaymentInput, OrganizationUncheckedCreateWithoutPaymentInput>
  }

  export type OrganizationUpsertWithoutPaymentInput = {
    update: XOR<OrganizationUpdateWithoutPaymentInput, OrganizationUncheckedUpdateWithoutPaymentInput>
    create: XOR<OrganizationCreateWithoutPaymentInput, OrganizationUncheckedCreateWithoutPaymentInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutPaymentInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutPaymentInput, OrganizationUncheckedUpdateWithoutPaymentInput>
  }

  export type OrganizationUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationRole?: OrganizationUserRoleUpdateManyWithoutOrganizationNestedInput
    organizationActionLog?: OrganizationActivityLogUpdateManyWithoutOrganizationNestedInput
    jobPost?: JobPostUpdateManyWithoutOrganizationNestedInput
    jobPreview?: JobPreviewUpdateManyWithoutOrganizationNestedInput
    organizationSubscription?: OrganizationSubscriptionUpdateManyWithoutOrganizationNestedInput
    Notification?: NotificationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationRole?: OrganizationUserRoleUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationActionLog?: OrganizationActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutOrganizationNestedInput
    jobPreview?: JobPreviewUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationSubscription?: OrganizationSubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutOrganizationActionLogInput = {
    id?: string
    name: string
    url?: string | null
    logo?: string | null
    assignedDomain?: string | null
    customDomain?: string | null
    createdAt?: Date | string
    organizationRole?: OrganizationUserRoleCreateNestedManyWithoutOrganizationInput
    jobPost?: JobPostCreateNestedManyWithoutOrganizationInput
    payment?: PaymentCreateNestedManyWithoutOrganizationInput
    jobPreview?: JobPreviewCreateNestedManyWithoutOrganizationInput
    organizationSubscription?: OrganizationSubscriptionCreateNestedManyWithoutOrganizationInput
    Notification?: NotificationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutOrganizationActionLogInput = {
    id?: string
    name: string
    url?: string | null
    logo?: string | null
    assignedDomain?: string | null
    customDomain?: string | null
    createdAt?: Date | string
    organizationRole?: OrganizationUserRoleUncheckedCreateNestedManyWithoutOrganizationInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutOrganizationInput
    payment?: PaymentUncheckedCreateNestedManyWithoutOrganizationInput
    jobPreview?: JobPreviewUncheckedCreateNestedManyWithoutOrganizationInput
    organizationSubscription?: OrganizationSubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutOrganizationActionLogInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutOrganizationActionLogInput, OrganizationUncheckedCreateWithoutOrganizationActionLogInput>
  }

  export type OrganizationUpsertWithoutOrganizationActionLogInput = {
    update: XOR<OrganizationUpdateWithoutOrganizationActionLogInput, OrganizationUncheckedUpdateWithoutOrganizationActionLogInput>
    create: XOR<OrganizationCreateWithoutOrganizationActionLogInput, OrganizationUncheckedCreateWithoutOrganizationActionLogInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutOrganizationActionLogInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutOrganizationActionLogInput, OrganizationUncheckedUpdateWithoutOrganizationActionLogInput>
  }

  export type OrganizationUpdateWithoutOrganizationActionLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationRole?: OrganizationUserRoleUpdateManyWithoutOrganizationNestedInput
    jobPost?: JobPostUpdateManyWithoutOrganizationNestedInput
    payment?: PaymentUpdateManyWithoutOrganizationNestedInput
    jobPreview?: JobPreviewUpdateManyWithoutOrganizationNestedInput
    organizationSubscription?: OrganizationSubscriptionUpdateManyWithoutOrganizationNestedInput
    Notification?: NotificationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutOrganizationActionLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationRole?: OrganizationUserRoleUncheckedUpdateManyWithoutOrganizationNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutOrganizationNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    jobPreview?: JobPreviewUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationSubscription?: OrganizationSubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutJobPostInput = {
    id?: string
    name: string
    url?: string | null
    logo?: string | null
    assignedDomain?: string | null
    customDomain?: string | null
    createdAt?: Date | string
    organizationRole?: OrganizationUserRoleCreateNestedManyWithoutOrganizationInput
    organizationActionLog?: OrganizationActivityLogCreateNestedManyWithoutOrganizationInput
    payment?: PaymentCreateNestedManyWithoutOrganizationInput
    jobPreview?: JobPreviewCreateNestedManyWithoutOrganizationInput
    organizationSubscription?: OrganizationSubscriptionCreateNestedManyWithoutOrganizationInput
    Notification?: NotificationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutJobPostInput = {
    id?: string
    name: string
    url?: string | null
    logo?: string | null
    assignedDomain?: string | null
    customDomain?: string | null
    createdAt?: Date | string
    organizationRole?: OrganizationUserRoleUncheckedCreateNestedManyWithoutOrganizationInput
    organizationActionLog?: OrganizationActivityLogUncheckedCreateNestedManyWithoutOrganizationInput
    payment?: PaymentUncheckedCreateNestedManyWithoutOrganizationInput
    jobPreview?: JobPreviewUncheckedCreateNestedManyWithoutOrganizationInput
    organizationSubscription?: OrganizationSubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutJobPostInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutJobPostInput, OrganizationUncheckedCreateWithoutJobPostInput>
  }

  export type JobApplicationCreateWithoutJobPostInput = {
    id?: string
    label: string
    dataType: string
    option?: JobApplicationCreateoptionInput | string[]
    rule?: string
    questionType?: string
    isDeleted?: boolean
    createdAt?: Date | string
    formResponse?: FormResponseCreateNestedManyWithoutJobApplicationInput
  }

  export type JobApplicationUncheckedCreateWithoutJobPostInput = {
    id?: string
    label: string
    dataType: string
    option?: JobApplicationCreateoptionInput | string[]
    rule?: string
    questionType?: string
    isDeleted?: boolean
    createdAt?: Date | string
    formResponse?: FormResponseUncheckedCreateNestedManyWithoutJobApplicationInput
  }

  export type JobApplicationCreateOrConnectWithoutJobPostInput = {
    where: JobApplicationWhereUniqueInput
    create: XOR<JobApplicationCreateWithoutJobPostInput, JobApplicationUncheckedCreateWithoutJobPostInput>
  }

  export type JobApplicationCreateManyJobPostInputEnvelope = {
    data: JobApplicationCreateManyJobPostInput | JobApplicationCreateManyJobPostInput[]
    skipDuplicates?: boolean
  }

  export type JobStageCreateWithoutJobPostInput = {
    id?: string
    name: string
    isDeletable?: boolean
    isDeleted?: boolean
    displayOrder: number
    createdAt?: Date | string
    candidateStage?: CandidateApplicationCreateNestedManyWithoutJobStageInput
  }

  export type JobStageUncheckedCreateWithoutJobPostInput = {
    id?: string
    name: string
    isDeletable?: boolean
    isDeleted?: boolean
    displayOrder: number
    createdAt?: Date | string
    candidateStage?: CandidateApplicationUncheckedCreateNestedManyWithoutJobStageInput
  }

  export type JobStageCreateOrConnectWithoutJobPostInput = {
    where: JobStageWhereUniqueInput
    create: XOR<JobStageCreateWithoutJobPostInput, JobStageUncheckedCreateWithoutJobPostInput>
  }

  export type JobStageCreateManyJobPostInputEnvelope = {
    data: JobStageCreateManyJobPostInput | JobStageCreateManyJobPostInput[]
    skipDuplicates?: boolean
  }

  export type JobPreviewCreateWithoutJobPostInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    isExpired?: boolean
    organization?: OrganizationCreateNestedOneWithoutJobPreviewInput
  }

  export type JobPreviewUncheckedCreateWithoutJobPostInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    isExpired?: boolean
    organizationId?: string | null
  }

  export type JobPreviewCreateOrConnectWithoutJobPostInput = {
    where: JobPreviewWhereUniqueInput
    create: XOR<JobPreviewCreateWithoutJobPostInput, JobPreviewUncheckedCreateWithoutJobPostInput>
  }

  export type JobPreviewCreateManyJobPostInputEnvelope = {
    data: JobPreviewCreateManyJobPostInput | JobPreviewCreateManyJobPostInput[]
    skipDuplicates?: boolean
  }

  export type CandidateApplicationCreateWithoutJobPostInput = {
    id?: string
    createdAt?: Date | string
    jobStage: JobStageCreateNestedOneWithoutCandidateStageInput
    formResponses?: FormResponseCreateNestedManyWithoutCandidateApplicationInput
    emailMessage?: EmailMessageCreateNestedManyWithoutCandidateInput
    CandidateTimeline?: CandidateTimelineCreateNestedManyWithoutCandidateApplicationInput
  }

  export type CandidateApplicationUncheckedCreateWithoutJobPostInput = {
    id?: string
    createdAt?: Date | string
    stageId: string
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutCandidateApplicationInput
    emailMessage?: EmailMessageUncheckedCreateNestedManyWithoutCandidateInput
    CandidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutCandidateApplicationInput
  }

  export type CandidateApplicationCreateOrConnectWithoutJobPostInput = {
    where: CandidateApplicationWhereUniqueInput
    create: XOR<CandidateApplicationCreateWithoutJobPostInput, CandidateApplicationUncheckedCreateWithoutJobPostInput>
  }

  export type CandidateApplicationCreateManyJobPostInputEnvelope = {
    data: CandidateApplicationCreateManyJobPostInput | CandidateApplicationCreateManyJobPostInput[]
    skipDuplicates?: boolean
  }

  export type CandidateTimelineCreateWithoutJobPostInput = {
    id?: string
    createdAt?: Date | string
    actionType: string
    timelineText: string
    comment?: string | null
    candidateReview?: CandidateReviewCreateNestedOneWithoutCandidateTimelineInput
    candidateApplication: CandidateApplicationCreateNestedOneWithoutCandidateTimelineInput
    user?: UserCreateNestedOneWithoutCandidateTimelineInput
  }

  export type CandidateTimelineUncheckedCreateWithoutJobPostInput = {
    id?: string
    createdAt?: Date | string
    userId?: string | null
    actionType: string
    timelineText: string
    comment?: string | null
    reviewId?: string | null
    candidateId: string
  }

  export type CandidateTimelineCreateOrConnectWithoutJobPostInput = {
    where: CandidateTimelineWhereUniqueInput
    create: XOR<CandidateTimelineCreateWithoutJobPostInput, CandidateTimelineUncheckedCreateWithoutJobPostInput>
  }

  export type CandidateTimelineCreateManyJobPostInputEnvelope = {
    data: CandidateTimelineCreateManyJobPostInput | CandidateTimelineCreateManyJobPostInput[]
    skipDuplicates?: boolean
  }

  export type JobMailingTemplateCreateWithoutJobPostInput = {
    id?: string
    name: string
    subject: string
    body: string
    createdAt?: Date | string
  }

  export type JobMailingTemplateUncheckedCreateWithoutJobPostInput = {
    id?: string
    name: string
    subject: string
    body: string
    createdAt?: Date | string
  }

  export type JobMailingTemplateCreateOrConnectWithoutJobPostInput = {
    where: JobMailingTemplateWhereUniqueInput
    create: XOR<JobMailingTemplateCreateWithoutJobPostInput, JobMailingTemplateUncheckedCreateWithoutJobPostInput>
  }

  export type JobMailingTemplateCreateManyJobPostInputEnvelope = {
    data: JobMailingTemplateCreateManyJobPostInput | JobMailingTemplateCreateManyJobPostInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutJobPostInput = {
    update: XOR<OrganizationUpdateWithoutJobPostInput, OrganizationUncheckedUpdateWithoutJobPostInput>
    create: XOR<OrganizationCreateWithoutJobPostInput, OrganizationUncheckedCreateWithoutJobPostInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutJobPostInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutJobPostInput, OrganizationUncheckedUpdateWithoutJobPostInput>
  }

  export type OrganizationUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationRole?: OrganizationUserRoleUpdateManyWithoutOrganizationNestedInput
    organizationActionLog?: OrganizationActivityLogUpdateManyWithoutOrganizationNestedInput
    payment?: PaymentUpdateManyWithoutOrganizationNestedInput
    jobPreview?: JobPreviewUpdateManyWithoutOrganizationNestedInput
    organizationSubscription?: OrganizationSubscriptionUpdateManyWithoutOrganizationNestedInput
    Notification?: NotificationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationRole?: OrganizationUserRoleUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationActionLog?: OrganizationActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    jobPreview?: JobPreviewUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationSubscription?: OrganizationSubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type JobApplicationUpsertWithWhereUniqueWithoutJobPostInput = {
    where: JobApplicationWhereUniqueInput
    update: XOR<JobApplicationUpdateWithoutJobPostInput, JobApplicationUncheckedUpdateWithoutJobPostInput>
    create: XOR<JobApplicationCreateWithoutJobPostInput, JobApplicationUncheckedCreateWithoutJobPostInput>
  }

  export type JobApplicationUpdateWithWhereUniqueWithoutJobPostInput = {
    where: JobApplicationWhereUniqueInput
    data: XOR<JobApplicationUpdateWithoutJobPostInput, JobApplicationUncheckedUpdateWithoutJobPostInput>
  }

  export type JobApplicationUpdateManyWithWhereWithoutJobPostInput = {
    where: JobApplicationScalarWhereInput
    data: XOR<JobApplicationUpdateManyMutationInput, JobApplicationUncheckedUpdateManyWithoutJobPostInput>
  }

  export type JobApplicationScalarWhereInput = {
    AND?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
    OR?: JobApplicationScalarWhereInput[]
    NOT?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
    id?: StringFilter<"JobApplication"> | string
    label?: StringFilter<"JobApplication"> | string
    dataType?: StringFilter<"JobApplication"> | string
    option?: StringNullableListFilter<"JobApplication">
    rule?: StringFilter<"JobApplication"> | string
    questionType?: StringFilter<"JobApplication"> | string
    isDeleted?: BoolFilter<"JobApplication"> | boolean
    jobId?: StringFilter<"JobApplication"> | string
    createdAt?: DateTimeFilter<"JobApplication"> | Date | string
  }

  export type JobStageUpsertWithWhereUniqueWithoutJobPostInput = {
    where: JobStageWhereUniqueInput
    update: XOR<JobStageUpdateWithoutJobPostInput, JobStageUncheckedUpdateWithoutJobPostInput>
    create: XOR<JobStageCreateWithoutJobPostInput, JobStageUncheckedCreateWithoutJobPostInput>
  }

  export type JobStageUpdateWithWhereUniqueWithoutJobPostInput = {
    where: JobStageWhereUniqueInput
    data: XOR<JobStageUpdateWithoutJobPostInput, JobStageUncheckedUpdateWithoutJobPostInput>
  }

  export type JobStageUpdateManyWithWhereWithoutJobPostInput = {
    where: JobStageScalarWhereInput
    data: XOR<JobStageUpdateManyMutationInput, JobStageUncheckedUpdateManyWithoutJobPostInput>
  }

  export type JobStageScalarWhereInput = {
    AND?: JobStageScalarWhereInput | JobStageScalarWhereInput[]
    OR?: JobStageScalarWhereInput[]
    NOT?: JobStageScalarWhereInput | JobStageScalarWhereInput[]
    id?: StringFilter<"JobStage"> | string
    name?: StringFilter<"JobStage"> | string
    isDeletable?: BoolFilter<"JobStage"> | boolean
    isDeleted?: BoolFilter<"JobStage"> | boolean
    displayOrder?: IntFilter<"JobStage"> | number
    jobId?: StringFilter<"JobStage"> | string
    createdAt?: DateTimeFilter<"JobStage"> | Date | string
  }

  export type JobPreviewUpsertWithWhereUniqueWithoutJobPostInput = {
    where: JobPreviewWhereUniqueInput
    update: XOR<JobPreviewUpdateWithoutJobPostInput, JobPreviewUncheckedUpdateWithoutJobPostInput>
    create: XOR<JobPreviewCreateWithoutJobPostInput, JobPreviewUncheckedCreateWithoutJobPostInput>
  }

  export type JobPreviewUpdateWithWhereUniqueWithoutJobPostInput = {
    where: JobPreviewWhereUniqueInput
    data: XOR<JobPreviewUpdateWithoutJobPostInput, JobPreviewUncheckedUpdateWithoutJobPostInput>
  }

  export type JobPreviewUpdateManyWithWhereWithoutJobPostInput = {
    where: JobPreviewScalarWhereInput
    data: XOR<JobPreviewUpdateManyMutationInput, JobPreviewUncheckedUpdateManyWithoutJobPostInput>
  }

  export type CandidateApplicationUpsertWithWhereUniqueWithoutJobPostInput = {
    where: CandidateApplicationWhereUniqueInput
    update: XOR<CandidateApplicationUpdateWithoutJobPostInput, CandidateApplicationUncheckedUpdateWithoutJobPostInput>
    create: XOR<CandidateApplicationCreateWithoutJobPostInput, CandidateApplicationUncheckedCreateWithoutJobPostInput>
  }

  export type CandidateApplicationUpdateWithWhereUniqueWithoutJobPostInput = {
    where: CandidateApplicationWhereUniqueInput
    data: XOR<CandidateApplicationUpdateWithoutJobPostInput, CandidateApplicationUncheckedUpdateWithoutJobPostInput>
  }

  export type CandidateApplicationUpdateManyWithWhereWithoutJobPostInput = {
    where: CandidateApplicationScalarWhereInput
    data: XOR<CandidateApplicationUpdateManyMutationInput, CandidateApplicationUncheckedUpdateManyWithoutJobPostInput>
  }

  export type CandidateApplicationScalarWhereInput = {
    AND?: CandidateApplicationScalarWhereInput | CandidateApplicationScalarWhereInput[]
    OR?: CandidateApplicationScalarWhereInput[]
    NOT?: CandidateApplicationScalarWhereInput | CandidateApplicationScalarWhereInput[]
    id?: StringFilter<"CandidateApplication"> | string
    jobId?: StringFilter<"CandidateApplication"> | string
    createdAt?: DateTimeFilter<"CandidateApplication"> | Date | string
    stageId?: StringFilter<"CandidateApplication"> | string
  }

  export type CandidateTimelineUpsertWithWhereUniqueWithoutJobPostInput = {
    where: CandidateTimelineWhereUniqueInput
    update: XOR<CandidateTimelineUpdateWithoutJobPostInput, CandidateTimelineUncheckedUpdateWithoutJobPostInput>
    create: XOR<CandidateTimelineCreateWithoutJobPostInput, CandidateTimelineUncheckedCreateWithoutJobPostInput>
  }

  export type CandidateTimelineUpdateWithWhereUniqueWithoutJobPostInput = {
    where: CandidateTimelineWhereUniqueInput
    data: XOR<CandidateTimelineUpdateWithoutJobPostInput, CandidateTimelineUncheckedUpdateWithoutJobPostInput>
  }

  export type CandidateTimelineUpdateManyWithWhereWithoutJobPostInput = {
    where: CandidateTimelineScalarWhereInput
    data: XOR<CandidateTimelineUpdateManyMutationInput, CandidateTimelineUncheckedUpdateManyWithoutJobPostInput>
  }

  export type JobMailingTemplateUpsertWithWhereUniqueWithoutJobPostInput = {
    where: JobMailingTemplateWhereUniqueInput
    update: XOR<JobMailingTemplateUpdateWithoutJobPostInput, JobMailingTemplateUncheckedUpdateWithoutJobPostInput>
    create: XOR<JobMailingTemplateCreateWithoutJobPostInput, JobMailingTemplateUncheckedCreateWithoutJobPostInput>
  }

  export type JobMailingTemplateUpdateWithWhereUniqueWithoutJobPostInput = {
    where: JobMailingTemplateWhereUniqueInput
    data: XOR<JobMailingTemplateUpdateWithoutJobPostInput, JobMailingTemplateUncheckedUpdateWithoutJobPostInput>
  }

  export type JobMailingTemplateUpdateManyWithWhereWithoutJobPostInput = {
    where: JobMailingTemplateScalarWhereInput
    data: XOR<JobMailingTemplateUpdateManyMutationInput, JobMailingTemplateUncheckedUpdateManyWithoutJobPostInput>
  }

  export type JobMailingTemplateScalarWhereInput = {
    AND?: JobMailingTemplateScalarWhereInput | JobMailingTemplateScalarWhereInput[]
    OR?: JobMailingTemplateScalarWhereInput[]
    NOT?: JobMailingTemplateScalarWhereInput | JobMailingTemplateScalarWhereInput[]
    id?: StringFilter<"JobMailingTemplate"> | string
    name?: StringFilter<"JobMailingTemplate"> | string
    subject?: StringFilter<"JobMailingTemplate"> | string
    body?: StringFilter<"JobMailingTemplate"> | string
    createdAt?: DateTimeFilter<"JobMailingTemplate"> | Date | string
    jobId?: StringFilter<"JobMailingTemplate"> | string
  }

  export type JobPostCreateWithoutJobApplicationInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutJobPostInput
    jobStage?: JobStageCreateNestedManyWithoutJobPostInput
    jobPreview?: JobPreviewCreateNestedManyWithoutJobPostInput
    candidateApplication?: CandidateApplicationCreateNestedManyWithoutJobPostInput
    CandidateTimeline?: CandidateTimelineCreateNestedManyWithoutJobPostInput
    JobMailingTemplate?: JobMailingTemplateCreateNestedManyWithoutJobPostInput
  }

  export type JobPostUncheckedCreateWithoutJobApplicationInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    organizationId: string
    createdAt?: Date | string
    jobStage?: JobStageUncheckedCreateNestedManyWithoutJobPostInput
    jobPreview?: JobPreviewUncheckedCreateNestedManyWithoutJobPostInput
    candidateApplication?: CandidateApplicationUncheckedCreateNestedManyWithoutJobPostInput
    CandidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutJobPostInput
    JobMailingTemplate?: JobMailingTemplateUncheckedCreateNestedManyWithoutJobPostInput
  }

  export type JobPostCreateOrConnectWithoutJobApplicationInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutJobApplicationInput, JobPostUncheckedCreateWithoutJobApplicationInput>
  }

  export type FormResponseCreateWithoutJobApplicationInput = {
    id?: string
    label: string
    value?: string | null
    createdAt?: Date | string
    candidateApplication: CandidateApplicationCreateNestedOneWithoutFormResponsesInput
  }

  export type FormResponseUncheckedCreateWithoutJobApplicationInput = {
    id?: string
    candidateApplicationId: string
    label: string
    value?: string | null
    createdAt?: Date | string
  }

  export type FormResponseCreateOrConnectWithoutJobApplicationInput = {
    where: FormResponseWhereUniqueInput
    create: XOR<FormResponseCreateWithoutJobApplicationInput, FormResponseUncheckedCreateWithoutJobApplicationInput>
  }

  export type FormResponseCreateManyJobApplicationInputEnvelope = {
    data: FormResponseCreateManyJobApplicationInput | FormResponseCreateManyJobApplicationInput[]
    skipDuplicates?: boolean
  }

  export type JobPostUpsertWithoutJobApplicationInput = {
    update: XOR<JobPostUpdateWithoutJobApplicationInput, JobPostUncheckedUpdateWithoutJobApplicationInput>
    create: XOR<JobPostCreateWithoutJobApplicationInput, JobPostUncheckedCreateWithoutJobApplicationInput>
    where?: JobPostWhereInput
  }

  export type JobPostUpdateToOneWithWhereWithoutJobApplicationInput = {
    where?: JobPostWhereInput
    data: XOR<JobPostUpdateWithoutJobApplicationInput, JobPostUncheckedUpdateWithoutJobApplicationInput>
  }

  export type JobPostUpdateWithoutJobApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutJobPostNestedInput
    jobStage?: JobStageUpdateManyWithoutJobPostNestedInput
    jobPreview?: JobPreviewUpdateManyWithoutJobPostNestedInput
    candidateApplication?: CandidateApplicationUpdateManyWithoutJobPostNestedInput
    CandidateTimeline?: CandidateTimelineUpdateManyWithoutJobPostNestedInput
    JobMailingTemplate?: JobMailingTemplateUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateWithoutJobApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobStage?: JobStageUncheckedUpdateManyWithoutJobPostNestedInput
    jobPreview?: JobPreviewUncheckedUpdateManyWithoutJobPostNestedInput
    candidateApplication?: CandidateApplicationUncheckedUpdateManyWithoutJobPostNestedInput
    CandidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutJobPostNestedInput
    JobMailingTemplate?: JobMailingTemplateUncheckedUpdateManyWithoutJobPostNestedInput
  }

  export type FormResponseUpsertWithWhereUniqueWithoutJobApplicationInput = {
    where: FormResponseWhereUniqueInput
    update: XOR<FormResponseUpdateWithoutJobApplicationInput, FormResponseUncheckedUpdateWithoutJobApplicationInput>
    create: XOR<FormResponseCreateWithoutJobApplicationInput, FormResponseUncheckedCreateWithoutJobApplicationInput>
  }

  export type FormResponseUpdateWithWhereUniqueWithoutJobApplicationInput = {
    where: FormResponseWhereUniqueInput
    data: XOR<FormResponseUpdateWithoutJobApplicationInput, FormResponseUncheckedUpdateWithoutJobApplicationInput>
  }

  export type FormResponseUpdateManyWithWhereWithoutJobApplicationInput = {
    where: FormResponseScalarWhereInput
    data: XOR<FormResponseUpdateManyMutationInput, FormResponseUncheckedUpdateManyWithoutJobApplicationInput>
  }

  export type FormResponseScalarWhereInput = {
    AND?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
    OR?: FormResponseScalarWhereInput[]
    NOT?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
    id?: StringFilter<"FormResponse"> | string
    candidateApplicationId?: StringFilter<"FormResponse"> | string
    jobApplicationId?: StringFilter<"FormResponse"> | string
    label?: StringFilter<"FormResponse"> | string
    value?: StringNullableFilter<"FormResponse"> | string | null
    createdAt?: DateTimeFilter<"FormResponse"> | Date | string
  }

  export type JobPostCreateWithoutCandidateApplicationInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutJobPostInput
    jobApplication?: JobApplicationCreateNestedManyWithoutJobPostInput
    jobStage?: JobStageCreateNestedManyWithoutJobPostInput
    jobPreview?: JobPreviewCreateNestedManyWithoutJobPostInput
    CandidateTimeline?: CandidateTimelineCreateNestedManyWithoutJobPostInput
    JobMailingTemplate?: JobMailingTemplateCreateNestedManyWithoutJobPostInput
  }

  export type JobPostUncheckedCreateWithoutCandidateApplicationInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    organizationId: string
    createdAt?: Date | string
    jobApplication?: JobApplicationUncheckedCreateNestedManyWithoutJobPostInput
    jobStage?: JobStageUncheckedCreateNestedManyWithoutJobPostInput
    jobPreview?: JobPreviewUncheckedCreateNestedManyWithoutJobPostInput
    CandidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutJobPostInput
    JobMailingTemplate?: JobMailingTemplateUncheckedCreateNestedManyWithoutJobPostInput
  }

  export type JobPostCreateOrConnectWithoutCandidateApplicationInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutCandidateApplicationInput, JobPostUncheckedCreateWithoutCandidateApplicationInput>
  }

  export type JobStageCreateWithoutCandidateStageInput = {
    id?: string
    name: string
    isDeletable?: boolean
    isDeleted?: boolean
    displayOrder: number
    createdAt?: Date | string
    jobPost: JobPostCreateNestedOneWithoutJobStageInput
  }

  export type JobStageUncheckedCreateWithoutCandidateStageInput = {
    id?: string
    name: string
    isDeletable?: boolean
    isDeleted?: boolean
    displayOrder: number
    jobId: string
    createdAt?: Date | string
  }

  export type JobStageCreateOrConnectWithoutCandidateStageInput = {
    where: JobStageWhereUniqueInput
    create: XOR<JobStageCreateWithoutCandidateStageInput, JobStageUncheckedCreateWithoutCandidateStageInput>
  }

  export type FormResponseCreateWithoutCandidateApplicationInput = {
    id?: string
    label: string
    value?: string | null
    createdAt?: Date | string
    jobApplication: JobApplicationCreateNestedOneWithoutFormResponseInput
  }

  export type FormResponseUncheckedCreateWithoutCandidateApplicationInput = {
    id?: string
    jobApplicationId: string
    label: string
    value?: string | null
    createdAt?: Date | string
  }

  export type FormResponseCreateOrConnectWithoutCandidateApplicationInput = {
    where: FormResponseWhereUniqueInput
    create: XOR<FormResponseCreateWithoutCandidateApplicationInput, FormResponseUncheckedCreateWithoutCandidateApplicationInput>
  }

  export type FormResponseCreateManyCandidateApplicationInputEnvelope = {
    data: FormResponseCreateManyCandidateApplicationInput | FormResponseCreateManyCandidateApplicationInput[]
    skipDuplicates?: boolean
  }

  export type EmailMessageCreateWithoutCandidateInput = {
    id?: string
    messageId: string
    sender: string
    recipient: string
    subject: string
    body: string
    s3Url?: string | null
    direction: $Enums.EmailDirection
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEmailMessageInput
    parentMessage?: EmailMessageCreateNestedOneWithoutRepliesInput
    replies?: EmailMessageCreateNestedManyWithoutParentMessageInput
  }

  export type EmailMessageUncheckedCreateWithoutCandidateInput = {
    id?: string
    messageId: string
    parentMessageId?: string | null
    sender: string
    recipient: string
    subject: string
    body: string
    s3Url?: string | null
    direction: $Enums.EmailDirection
    createdAt?: Date | string
    userId: string
    replies?: EmailMessageUncheckedCreateNestedManyWithoutParentMessageInput
  }

  export type EmailMessageCreateOrConnectWithoutCandidateInput = {
    where: EmailMessageWhereUniqueInput
    create: XOR<EmailMessageCreateWithoutCandidateInput, EmailMessageUncheckedCreateWithoutCandidateInput>
  }

  export type EmailMessageCreateManyCandidateInputEnvelope = {
    data: EmailMessageCreateManyCandidateInput | EmailMessageCreateManyCandidateInput[]
    skipDuplicates?: boolean
  }

  export type CandidateTimelineCreateWithoutCandidateApplicationInput = {
    id?: string
    createdAt?: Date | string
    actionType: string
    timelineText: string
    comment?: string | null
    candidateReview?: CandidateReviewCreateNestedOneWithoutCandidateTimelineInput
    jobPost: JobPostCreateNestedOneWithoutCandidateTimelineInput
    user?: UserCreateNestedOneWithoutCandidateTimelineInput
  }

  export type CandidateTimelineUncheckedCreateWithoutCandidateApplicationInput = {
    id?: string
    createdAt?: Date | string
    userId?: string | null
    actionType: string
    jobId: string
    timelineText: string
    comment?: string | null
    reviewId?: string | null
  }

  export type CandidateTimelineCreateOrConnectWithoutCandidateApplicationInput = {
    where: CandidateTimelineWhereUniqueInput
    create: XOR<CandidateTimelineCreateWithoutCandidateApplicationInput, CandidateTimelineUncheckedCreateWithoutCandidateApplicationInput>
  }

  export type CandidateTimelineCreateManyCandidateApplicationInputEnvelope = {
    data: CandidateTimelineCreateManyCandidateApplicationInput | CandidateTimelineCreateManyCandidateApplicationInput[]
    skipDuplicates?: boolean
  }

  export type JobPostUpsertWithoutCandidateApplicationInput = {
    update: XOR<JobPostUpdateWithoutCandidateApplicationInput, JobPostUncheckedUpdateWithoutCandidateApplicationInput>
    create: XOR<JobPostCreateWithoutCandidateApplicationInput, JobPostUncheckedCreateWithoutCandidateApplicationInput>
    where?: JobPostWhereInput
  }

  export type JobPostUpdateToOneWithWhereWithoutCandidateApplicationInput = {
    where?: JobPostWhereInput
    data: XOR<JobPostUpdateWithoutCandidateApplicationInput, JobPostUncheckedUpdateWithoutCandidateApplicationInput>
  }

  export type JobPostUpdateWithoutCandidateApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutJobPostNestedInput
    jobApplication?: JobApplicationUpdateManyWithoutJobPostNestedInput
    jobStage?: JobStageUpdateManyWithoutJobPostNestedInput
    jobPreview?: JobPreviewUpdateManyWithoutJobPostNestedInput
    CandidateTimeline?: CandidateTimelineUpdateManyWithoutJobPostNestedInput
    JobMailingTemplate?: JobMailingTemplateUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateWithoutCandidateApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobApplication?: JobApplicationUncheckedUpdateManyWithoutJobPostNestedInput
    jobStage?: JobStageUncheckedUpdateManyWithoutJobPostNestedInput
    jobPreview?: JobPreviewUncheckedUpdateManyWithoutJobPostNestedInput
    CandidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutJobPostNestedInput
    JobMailingTemplate?: JobMailingTemplateUncheckedUpdateManyWithoutJobPostNestedInput
  }

  export type JobStageUpsertWithoutCandidateStageInput = {
    update: XOR<JobStageUpdateWithoutCandidateStageInput, JobStageUncheckedUpdateWithoutCandidateStageInput>
    create: XOR<JobStageCreateWithoutCandidateStageInput, JobStageUncheckedCreateWithoutCandidateStageInput>
    where?: JobStageWhereInput
  }

  export type JobStageUpdateToOneWithWhereWithoutCandidateStageInput = {
    where?: JobStageWhereInput
    data: XOR<JobStageUpdateWithoutCandidateStageInput, JobStageUncheckedUpdateWithoutCandidateStageInput>
  }

  export type JobStageUpdateWithoutCandidateStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeletable?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobPost?: JobPostUpdateOneRequiredWithoutJobStageNestedInput
  }

  export type JobStageUncheckedUpdateWithoutCandidateStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeletable?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseUpsertWithWhereUniqueWithoutCandidateApplicationInput = {
    where: FormResponseWhereUniqueInput
    update: XOR<FormResponseUpdateWithoutCandidateApplicationInput, FormResponseUncheckedUpdateWithoutCandidateApplicationInput>
    create: XOR<FormResponseCreateWithoutCandidateApplicationInput, FormResponseUncheckedCreateWithoutCandidateApplicationInput>
  }

  export type FormResponseUpdateWithWhereUniqueWithoutCandidateApplicationInput = {
    where: FormResponseWhereUniqueInput
    data: XOR<FormResponseUpdateWithoutCandidateApplicationInput, FormResponseUncheckedUpdateWithoutCandidateApplicationInput>
  }

  export type FormResponseUpdateManyWithWhereWithoutCandidateApplicationInput = {
    where: FormResponseScalarWhereInput
    data: XOR<FormResponseUpdateManyMutationInput, FormResponseUncheckedUpdateManyWithoutCandidateApplicationInput>
  }

  export type EmailMessageUpsertWithWhereUniqueWithoutCandidateInput = {
    where: EmailMessageWhereUniqueInput
    update: XOR<EmailMessageUpdateWithoutCandidateInput, EmailMessageUncheckedUpdateWithoutCandidateInput>
    create: XOR<EmailMessageCreateWithoutCandidateInput, EmailMessageUncheckedCreateWithoutCandidateInput>
  }

  export type EmailMessageUpdateWithWhereUniqueWithoutCandidateInput = {
    where: EmailMessageWhereUniqueInput
    data: XOR<EmailMessageUpdateWithoutCandidateInput, EmailMessageUncheckedUpdateWithoutCandidateInput>
  }

  export type EmailMessageUpdateManyWithWhereWithoutCandidateInput = {
    where: EmailMessageScalarWhereInput
    data: XOR<EmailMessageUpdateManyMutationInput, EmailMessageUncheckedUpdateManyWithoutCandidateInput>
  }

  export type CandidateTimelineUpsertWithWhereUniqueWithoutCandidateApplicationInput = {
    where: CandidateTimelineWhereUniqueInput
    update: XOR<CandidateTimelineUpdateWithoutCandidateApplicationInput, CandidateTimelineUncheckedUpdateWithoutCandidateApplicationInput>
    create: XOR<CandidateTimelineCreateWithoutCandidateApplicationInput, CandidateTimelineUncheckedCreateWithoutCandidateApplicationInput>
  }

  export type CandidateTimelineUpdateWithWhereUniqueWithoutCandidateApplicationInput = {
    where: CandidateTimelineWhereUniqueInput
    data: XOR<CandidateTimelineUpdateWithoutCandidateApplicationInput, CandidateTimelineUncheckedUpdateWithoutCandidateApplicationInput>
  }

  export type CandidateTimelineUpdateManyWithWhereWithoutCandidateApplicationInput = {
    where: CandidateTimelineScalarWhereInput
    data: XOR<CandidateTimelineUpdateManyMutationInput, CandidateTimelineUncheckedUpdateManyWithoutCandidateApplicationInput>
  }

  export type CandidateTimelineCreateWithoutCandidateReviewInput = {
    id?: string
    createdAt?: Date | string
    actionType: string
    timelineText: string
    comment?: string | null
    candidateApplication: CandidateApplicationCreateNestedOneWithoutCandidateTimelineInput
    jobPost: JobPostCreateNestedOneWithoutCandidateTimelineInput
    user?: UserCreateNestedOneWithoutCandidateTimelineInput
  }

  export type CandidateTimelineUncheckedCreateWithoutCandidateReviewInput = {
    id?: string
    createdAt?: Date | string
    userId?: string | null
    actionType: string
    jobId: string
    timelineText: string
    comment?: string | null
    candidateId: string
  }

  export type CandidateTimelineCreateOrConnectWithoutCandidateReviewInput = {
    where: CandidateTimelineWhereUniqueInput
    create: XOR<CandidateTimelineCreateWithoutCandidateReviewInput, CandidateTimelineUncheckedCreateWithoutCandidateReviewInput>
  }

  export type CandidateTimelineCreateManyCandidateReviewInputEnvelope = {
    data: CandidateTimelineCreateManyCandidateReviewInput | CandidateTimelineCreateManyCandidateReviewInput[]
    skipDuplicates?: boolean
  }

  export type CandidateTimelineUpsertWithWhereUniqueWithoutCandidateReviewInput = {
    where: CandidateTimelineWhereUniqueInput
    update: XOR<CandidateTimelineUpdateWithoutCandidateReviewInput, CandidateTimelineUncheckedUpdateWithoutCandidateReviewInput>
    create: XOR<CandidateTimelineCreateWithoutCandidateReviewInput, CandidateTimelineUncheckedCreateWithoutCandidateReviewInput>
  }

  export type CandidateTimelineUpdateWithWhereUniqueWithoutCandidateReviewInput = {
    where: CandidateTimelineWhereUniqueInput
    data: XOR<CandidateTimelineUpdateWithoutCandidateReviewInput, CandidateTimelineUncheckedUpdateWithoutCandidateReviewInput>
  }

  export type CandidateTimelineUpdateManyWithWhereWithoutCandidateReviewInput = {
    where: CandidateTimelineScalarWhereInput
    data: XOR<CandidateTimelineUpdateManyMutationInput, CandidateTimelineUncheckedUpdateManyWithoutCandidateReviewInput>
  }

  export type CandidateReviewCreateWithoutCandidateTimelineInput = {
    id?: string
    description?: string | null
    verdict: string
    createdAt?: Date | string
  }

  export type CandidateReviewUncheckedCreateWithoutCandidateTimelineInput = {
    id?: string
    description?: string | null
    verdict: string
    createdAt?: Date | string
  }

  export type CandidateReviewCreateOrConnectWithoutCandidateTimelineInput = {
    where: CandidateReviewWhereUniqueInput
    create: XOR<CandidateReviewCreateWithoutCandidateTimelineInput, CandidateReviewUncheckedCreateWithoutCandidateTimelineInput>
  }

  export type CandidateApplicationCreateWithoutCandidateTimelineInput = {
    id?: string
    createdAt?: Date | string
    jobPost: JobPostCreateNestedOneWithoutCandidateApplicationInput
    jobStage: JobStageCreateNestedOneWithoutCandidateStageInput
    formResponses?: FormResponseCreateNestedManyWithoutCandidateApplicationInput
    emailMessage?: EmailMessageCreateNestedManyWithoutCandidateInput
  }

  export type CandidateApplicationUncheckedCreateWithoutCandidateTimelineInput = {
    id?: string
    jobId: string
    createdAt?: Date | string
    stageId: string
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutCandidateApplicationInput
    emailMessage?: EmailMessageUncheckedCreateNestedManyWithoutCandidateInput
  }

  export type CandidateApplicationCreateOrConnectWithoutCandidateTimelineInput = {
    where: CandidateApplicationWhereUniqueInput
    create: XOR<CandidateApplicationCreateWithoutCandidateTimelineInput, CandidateApplicationUncheckedCreateWithoutCandidateTimelineInput>
  }

  export type JobPostCreateWithoutCandidateTimelineInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutJobPostInput
    jobApplication?: JobApplicationCreateNestedManyWithoutJobPostInput
    jobStage?: JobStageCreateNestedManyWithoutJobPostInput
    jobPreview?: JobPreviewCreateNestedManyWithoutJobPostInput
    candidateApplication?: CandidateApplicationCreateNestedManyWithoutJobPostInput
    JobMailingTemplate?: JobMailingTemplateCreateNestedManyWithoutJobPostInput
  }

  export type JobPostUncheckedCreateWithoutCandidateTimelineInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    organizationId: string
    createdAt?: Date | string
    jobApplication?: JobApplicationUncheckedCreateNestedManyWithoutJobPostInput
    jobStage?: JobStageUncheckedCreateNestedManyWithoutJobPostInput
    jobPreview?: JobPreviewUncheckedCreateNestedManyWithoutJobPostInput
    candidateApplication?: CandidateApplicationUncheckedCreateNestedManyWithoutJobPostInput
    JobMailingTemplate?: JobMailingTemplateUncheckedCreateNestedManyWithoutJobPostInput
  }

  export type JobPostCreateOrConnectWithoutCandidateTimelineInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutCandidateTimelineInput, JobPostUncheckedCreateWithoutCandidateTimelineInput>
  }

  export type UserCreateWithoutCandidateTimelineInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizations?: OrganizationUserRoleCreateNestedManyWithoutUserInput
    twoFactorConfirmation?: TwoFactorConfirmationCreateNestedOneWithoutUserInput
    emailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    organizationSubscription?: OrganizationSubscriptionCreateNestedManyWithoutUserInput
    NotificationReceipt?: NotificationReceiptCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCandidateTimelineInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationUserRoleUncheckedCreateNestedManyWithoutUserInput
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInput
    emailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    organizationSubscription?: OrganizationSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationReceipt?: NotificationReceiptUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCandidateTimelineInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCandidateTimelineInput, UserUncheckedCreateWithoutCandidateTimelineInput>
  }

  export type CandidateReviewUpsertWithoutCandidateTimelineInput = {
    update: XOR<CandidateReviewUpdateWithoutCandidateTimelineInput, CandidateReviewUncheckedUpdateWithoutCandidateTimelineInput>
    create: XOR<CandidateReviewCreateWithoutCandidateTimelineInput, CandidateReviewUncheckedCreateWithoutCandidateTimelineInput>
    where?: CandidateReviewWhereInput
  }

  export type CandidateReviewUpdateToOneWithWhereWithoutCandidateTimelineInput = {
    where?: CandidateReviewWhereInput
    data: XOR<CandidateReviewUpdateWithoutCandidateTimelineInput, CandidateReviewUncheckedUpdateWithoutCandidateTimelineInput>
  }

  export type CandidateReviewUpdateWithoutCandidateTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verdict?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidateReviewUncheckedUpdateWithoutCandidateTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verdict?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidateApplicationUpsertWithoutCandidateTimelineInput = {
    update: XOR<CandidateApplicationUpdateWithoutCandidateTimelineInput, CandidateApplicationUncheckedUpdateWithoutCandidateTimelineInput>
    create: XOR<CandidateApplicationCreateWithoutCandidateTimelineInput, CandidateApplicationUncheckedCreateWithoutCandidateTimelineInput>
    where?: CandidateApplicationWhereInput
  }

  export type CandidateApplicationUpdateToOneWithWhereWithoutCandidateTimelineInput = {
    where?: CandidateApplicationWhereInput
    data: XOR<CandidateApplicationUpdateWithoutCandidateTimelineInput, CandidateApplicationUncheckedUpdateWithoutCandidateTimelineInput>
  }

  export type CandidateApplicationUpdateWithoutCandidateTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobPost?: JobPostUpdateOneRequiredWithoutCandidateApplicationNestedInput
    jobStage?: JobStageUpdateOneRequiredWithoutCandidateStageNestedInput
    formResponses?: FormResponseUpdateManyWithoutCandidateApplicationNestedInput
    emailMessage?: EmailMessageUpdateManyWithoutCandidateNestedInput
  }

  export type CandidateApplicationUncheckedUpdateWithoutCandidateTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stageId?: StringFieldUpdateOperationsInput | string
    formResponses?: FormResponseUncheckedUpdateManyWithoutCandidateApplicationNestedInput
    emailMessage?: EmailMessageUncheckedUpdateManyWithoutCandidateNestedInput
  }

  export type JobPostUpsertWithoutCandidateTimelineInput = {
    update: XOR<JobPostUpdateWithoutCandidateTimelineInput, JobPostUncheckedUpdateWithoutCandidateTimelineInput>
    create: XOR<JobPostCreateWithoutCandidateTimelineInput, JobPostUncheckedCreateWithoutCandidateTimelineInput>
    where?: JobPostWhereInput
  }

  export type JobPostUpdateToOneWithWhereWithoutCandidateTimelineInput = {
    where?: JobPostWhereInput
    data: XOR<JobPostUpdateWithoutCandidateTimelineInput, JobPostUncheckedUpdateWithoutCandidateTimelineInput>
  }

  export type JobPostUpdateWithoutCandidateTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutJobPostNestedInput
    jobApplication?: JobApplicationUpdateManyWithoutJobPostNestedInput
    jobStage?: JobStageUpdateManyWithoutJobPostNestedInput
    jobPreview?: JobPreviewUpdateManyWithoutJobPostNestedInput
    candidateApplication?: CandidateApplicationUpdateManyWithoutJobPostNestedInput
    JobMailingTemplate?: JobMailingTemplateUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateWithoutCandidateTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobApplication?: JobApplicationUncheckedUpdateManyWithoutJobPostNestedInput
    jobStage?: JobStageUncheckedUpdateManyWithoutJobPostNestedInput
    jobPreview?: JobPreviewUncheckedUpdateManyWithoutJobPostNestedInput
    candidateApplication?: CandidateApplicationUncheckedUpdateManyWithoutJobPostNestedInput
    JobMailingTemplate?: JobMailingTemplateUncheckedUpdateManyWithoutJobPostNestedInput
  }

  export type UserUpsertWithoutCandidateTimelineInput = {
    update: XOR<UserUpdateWithoutCandidateTimelineInput, UserUncheckedUpdateWithoutCandidateTimelineInput>
    create: XOR<UserCreateWithoutCandidateTimelineInput, UserUncheckedCreateWithoutCandidateTimelineInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCandidateTimelineInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCandidateTimelineInput, UserUncheckedUpdateWithoutCandidateTimelineInput>
  }

  export type UserUpdateWithoutCandidateTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizations?: OrganizationUserRoleUpdateManyWithoutUserNestedInput
    twoFactorConfirmation?: TwoFactorConfirmationUpdateOneWithoutUserNestedInput
    emailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    organizationSubscription?: OrganizationSubscriptionUpdateManyWithoutUserNestedInput
    NotificationReceipt?: NotificationReceiptUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCandidateTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationUserRoleUncheckedUpdateManyWithoutUserNestedInput
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInput
    emailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    organizationSubscription?: OrganizationSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationReceipt?: NotificationReceiptUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CandidateApplicationCreateWithoutFormResponsesInput = {
    id?: string
    createdAt?: Date | string
    jobPost: JobPostCreateNestedOneWithoutCandidateApplicationInput
    jobStage: JobStageCreateNestedOneWithoutCandidateStageInput
    emailMessage?: EmailMessageCreateNestedManyWithoutCandidateInput
    CandidateTimeline?: CandidateTimelineCreateNestedManyWithoutCandidateApplicationInput
  }

  export type CandidateApplicationUncheckedCreateWithoutFormResponsesInput = {
    id?: string
    jobId: string
    createdAt?: Date | string
    stageId: string
    emailMessage?: EmailMessageUncheckedCreateNestedManyWithoutCandidateInput
    CandidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutCandidateApplicationInput
  }

  export type CandidateApplicationCreateOrConnectWithoutFormResponsesInput = {
    where: CandidateApplicationWhereUniqueInput
    create: XOR<CandidateApplicationCreateWithoutFormResponsesInput, CandidateApplicationUncheckedCreateWithoutFormResponsesInput>
  }

  export type JobApplicationCreateWithoutFormResponseInput = {
    id?: string
    label: string
    dataType: string
    option?: JobApplicationCreateoptionInput | string[]
    rule?: string
    questionType?: string
    isDeleted?: boolean
    createdAt?: Date | string
    jobPost: JobPostCreateNestedOneWithoutJobApplicationInput
  }

  export type JobApplicationUncheckedCreateWithoutFormResponseInput = {
    id?: string
    label: string
    dataType: string
    option?: JobApplicationCreateoptionInput | string[]
    rule?: string
    questionType?: string
    isDeleted?: boolean
    jobId: string
    createdAt?: Date | string
  }

  export type JobApplicationCreateOrConnectWithoutFormResponseInput = {
    where: JobApplicationWhereUniqueInput
    create: XOR<JobApplicationCreateWithoutFormResponseInput, JobApplicationUncheckedCreateWithoutFormResponseInput>
  }

  export type CandidateApplicationUpsertWithoutFormResponsesInput = {
    update: XOR<CandidateApplicationUpdateWithoutFormResponsesInput, CandidateApplicationUncheckedUpdateWithoutFormResponsesInput>
    create: XOR<CandidateApplicationCreateWithoutFormResponsesInput, CandidateApplicationUncheckedCreateWithoutFormResponsesInput>
    where?: CandidateApplicationWhereInput
  }

  export type CandidateApplicationUpdateToOneWithWhereWithoutFormResponsesInput = {
    where?: CandidateApplicationWhereInput
    data: XOR<CandidateApplicationUpdateWithoutFormResponsesInput, CandidateApplicationUncheckedUpdateWithoutFormResponsesInput>
  }

  export type CandidateApplicationUpdateWithoutFormResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobPost?: JobPostUpdateOneRequiredWithoutCandidateApplicationNestedInput
    jobStage?: JobStageUpdateOneRequiredWithoutCandidateStageNestedInput
    emailMessage?: EmailMessageUpdateManyWithoutCandidateNestedInput
    CandidateTimeline?: CandidateTimelineUpdateManyWithoutCandidateApplicationNestedInput
  }

  export type CandidateApplicationUncheckedUpdateWithoutFormResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stageId?: StringFieldUpdateOperationsInput | string
    emailMessage?: EmailMessageUncheckedUpdateManyWithoutCandidateNestedInput
    CandidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutCandidateApplicationNestedInput
  }

  export type JobApplicationUpsertWithoutFormResponseInput = {
    update: XOR<JobApplicationUpdateWithoutFormResponseInput, JobApplicationUncheckedUpdateWithoutFormResponseInput>
    create: XOR<JobApplicationCreateWithoutFormResponseInput, JobApplicationUncheckedCreateWithoutFormResponseInput>
    where?: JobApplicationWhereInput
  }

  export type JobApplicationUpdateToOneWithWhereWithoutFormResponseInput = {
    where?: JobApplicationWhereInput
    data: XOR<JobApplicationUpdateWithoutFormResponseInput, JobApplicationUncheckedUpdateWithoutFormResponseInput>
  }

  export type JobApplicationUpdateWithoutFormResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    option?: JobApplicationUpdateoptionInput | string[]
    rule?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobPost?: JobPostUpdateOneRequiredWithoutJobApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateWithoutFormResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    option?: JobApplicationUpdateoptionInput | string[]
    rule?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateWithoutJobPreviewInput = {
    id?: string
    name: string
    url?: string | null
    logo?: string | null
    assignedDomain?: string | null
    customDomain?: string | null
    createdAt?: Date | string
    organizationRole?: OrganizationUserRoleCreateNestedManyWithoutOrganizationInput
    organizationActionLog?: OrganizationActivityLogCreateNestedManyWithoutOrganizationInput
    jobPost?: JobPostCreateNestedManyWithoutOrganizationInput
    payment?: PaymentCreateNestedManyWithoutOrganizationInput
    organizationSubscription?: OrganizationSubscriptionCreateNestedManyWithoutOrganizationInput
    Notification?: NotificationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutJobPreviewInput = {
    id?: string
    name: string
    url?: string | null
    logo?: string | null
    assignedDomain?: string | null
    customDomain?: string | null
    createdAt?: Date | string
    organizationRole?: OrganizationUserRoleUncheckedCreateNestedManyWithoutOrganizationInput
    organizationActionLog?: OrganizationActivityLogUncheckedCreateNestedManyWithoutOrganizationInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutOrganizationInput
    payment?: PaymentUncheckedCreateNestedManyWithoutOrganizationInput
    organizationSubscription?: OrganizationSubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutJobPreviewInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutJobPreviewInput, OrganizationUncheckedCreateWithoutJobPreviewInput>
  }

  export type JobPostCreateWithoutJobPreviewInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutJobPostInput
    jobApplication?: JobApplicationCreateNestedManyWithoutJobPostInput
    jobStage?: JobStageCreateNestedManyWithoutJobPostInput
    candidateApplication?: CandidateApplicationCreateNestedManyWithoutJobPostInput
    CandidateTimeline?: CandidateTimelineCreateNestedManyWithoutJobPostInput
    JobMailingTemplate?: JobMailingTemplateCreateNestedManyWithoutJobPostInput
  }

  export type JobPostUncheckedCreateWithoutJobPreviewInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    organizationId: string
    createdAt?: Date | string
    jobApplication?: JobApplicationUncheckedCreateNestedManyWithoutJobPostInput
    jobStage?: JobStageUncheckedCreateNestedManyWithoutJobPostInput
    candidateApplication?: CandidateApplicationUncheckedCreateNestedManyWithoutJobPostInput
    CandidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutJobPostInput
    JobMailingTemplate?: JobMailingTemplateUncheckedCreateNestedManyWithoutJobPostInput
  }

  export type JobPostCreateOrConnectWithoutJobPreviewInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutJobPreviewInput, JobPostUncheckedCreateWithoutJobPreviewInput>
  }

  export type OrganizationUpsertWithoutJobPreviewInput = {
    update: XOR<OrganizationUpdateWithoutJobPreviewInput, OrganizationUncheckedUpdateWithoutJobPreviewInput>
    create: XOR<OrganizationCreateWithoutJobPreviewInput, OrganizationUncheckedCreateWithoutJobPreviewInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutJobPreviewInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutJobPreviewInput, OrganizationUncheckedUpdateWithoutJobPreviewInput>
  }

  export type OrganizationUpdateWithoutJobPreviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationRole?: OrganizationUserRoleUpdateManyWithoutOrganizationNestedInput
    organizationActionLog?: OrganizationActivityLogUpdateManyWithoutOrganizationNestedInput
    jobPost?: JobPostUpdateManyWithoutOrganizationNestedInput
    payment?: PaymentUpdateManyWithoutOrganizationNestedInput
    organizationSubscription?: OrganizationSubscriptionUpdateManyWithoutOrganizationNestedInput
    Notification?: NotificationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutJobPreviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationRole?: OrganizationUserRoleUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationActionLog?: OrganizationActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutOrganizationNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationSubscription?: OrganizationSubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type JobPostUpsertWithoutJobPreviewInput = {
    update: XOR<JobPostUpdateWithoutJobPreviewInput, JobPostUncheckedUpdateWithoutJobPreviewInput>
    create: XOR<JobPostCreateWithoutJobPreviewInput, JobPostUncheckedCreateWithoutJobPreviewInput>
    where?: JobPostWhereInput
  }

  export type JobPostUpdateToOneWithWhereWithoutJobPreviewInput = {
    where?: JobPostWhereInput
    data: XOR<JobPostUpdateWithoutJobPreviewInput, JobPostUncheckedUpdateWithoutJobPreviewInput>
  }

  export type JobPostUpdateWithoutJobPreviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutJobPostNestedInput
    jobApplication?: JobApplicationUpdateManyWithoutJobPostNestedInput
    jobStage?: JobStageUpdateManyWithoutJobPostNestedInput
    candidateApplication?: CandidateApplicationUpdateManyWithoutJobPostNestedInput
    CandidateTimeline?: CandidateTimelineUpdateManyWithoutJobPostNestedInput
    JobMailingTemplate?: JobMailingTemplateUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateWithoutJobPreviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobApplication?: JobApplicationUncheckedUpdateManyWithoutJobPostNestedInput
    jobStage?: JobStageUncheckedUpdateManyWithoutJobPostNestedInput
    candidateApplication?: CandidateApplicationUncheckedUpdateManyWithoutJobPostNestedInput
    CandidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutJobPostNestedInput
    JobMailingTemplate?: JobMailingTemplateUncheckedUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostCreateWithoutJobStageInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutJobPostInput
    jobApplication?: JobApplicationCreateNestedManyWithoutJobPostInput
    jobPreview?: JobPreviewCreateNestedManyWithoutJobPostInput
    candidateApplication?: CandidateApplicationCreateNestedManyWithoutJobPostInput
    CandidateTimeline?: CandidateTimelineCreateNestedManyWithoutJobPostInput
    JobMailingTemplate?: JobMailingTemplateCreateNestedManyWithoutJobPostInput
  }

  export type JobPostUncheckedCreateWithoutJobStageInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    organizationId: string
    createdAt?: Date | string
    jobApplication?: JobApplicationUncheckedCreateNestedManyWithoutJobPostInput
    jobPreview?: JobPreviewUncheckedCreateNestedManyWithoutJobPostInput
    candidateApplication?: CandidateApplicationUncheckedCreateNestedManyWithoutJobPostInput
    CandidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutJobPostInput
    JobMailingTemplate?: JobMailingTemplateUncheckedCreateNestedManyWithoutJobPostInput
  }

  export type JobPostCreateOrConnectWithoutJobStageInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutJobStageInput, JobPostUncheckedCreateWithoutJobStageInput>
  }

  export type CandidateApplicationCreateWithoutJobStageInput = {
    id?: string
    createdAt?: Date | string
    jobPost: JobPostCreateNestedOneWithoutCandidateApplicationInput
    formResponses?: FormResponseCreateNestedManyWithoutCandidateApplicationInput
    emailMessage?: EmailMessageCreateNestedManyWithoutCandidateInput
    CandidateTimeline?: CandidateTimelineCreateNestedManyWithoutCandidateApplicationInput
  }

  export type CandidateApplicationUncheckedCreateWithoutJobStageInput = {
    id?: string
    jobId: string
    createdAt?: Date | string
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutCandidateApplicationInput
    emailMessage?: EmailMessageUncheckedCreateNestedManyWithoutCandidateInput
    CandidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutCandidateApplicationInput
  }

  export type CandidateApplicationCreateOrConnectWithoutJobStageInput = {
    where: CandidateApplicationWhereUniqueInput
    create: XOR<CandidateApplicationCreateWithoutJobStageInput, CandidateApplicationUncheckedCreateWithoutJobStageInput>
  }

  export type CandidateApplicationCreateManyJobStageInputEnvelope = {
    data: CandidateApplicationCreateManyJobStageInput | CandidateApplicationCreateManyJobStageInput[]
    skipDuplicates?: boolean
  }

  export type JobPostUpsertWithoutJobStageInput = {
    update: XOR<JobPostUpdateWithoutJobStageInput, JobPostUncheckedUpdateWithoutJobStageInput>
    create: XOR<JobPostCreateWithoutJobStageInput, JobPostUncheckedCreateWithoutJobStageInput>
    where?: JobPostWhereInput
  }

  export type JobPostUpdateToOneWithWhereWithoutJobStageInput = {
    where?: JobPostWhereInput
    data: XOR<JobPostUpdateWithoutJobStageInput, JobPostUncheckedUpdateWithoutJobStageInput>
  }

  export type JobPostUpdateWithoutJobStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutJobPostNestedInput
    jobApplication?: JobApplicationUpdateManyWithoutJobPostNestedInput
    jobPreview?: JobPreviewUpdateManyWithoutJobPostNestedInput
    candidateApplication?: CandidateApplicationUpdateManyWithoutJobPostNestedInput
    CandidateTimeline?: CandidateTimelineUpdateManyWithoutJobPostNestedInput
    JobMailingTemplate?: JobMailingTemplateUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateWithoutJobStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobApplication?: JobApplicationUncheckedUpdateManyWithoutJobPostNestedInput
    jobPreview?: JobPreviewUncheckedUpdateManyWithoutJobPostNestedInput
    candidateApplication?: CandidateApplicationUncheckedUpdateManyWithoutJobPostNestedInput
    CandidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutJobPostNestedInput
    JobMailingTemplate?: JobMailingTemplateUncheckedUpdateManyWithoutJobPostNestedInput
  }

  export type CandidateApplicationUpsertWithWhereUniqueWithoutJobStageInput = {
    where: CandidateApplicationWhereUniqueInput
    update: XOR<CandidateApplicationUpdateWithoutJobStageInput, CandidateApplicationUncheckedUpdateWithoutJobStageInput>
    create: XOR<CandidateApplicationCreateWithoutJobStageInput, CandidateApplicationUncheckedCreateWithoutJobStageInput>
  }

  export type CandidateApplicationUpdateWithWhereUniqueWithoutJobStageInput = {
    where: CandidateApplicationWhereUniqueInput
    data: XOR<CandidateApplicationUpdateWithoutJobStageInput, CandidateApplicationUncheckedUpdateWithoutJobStageInput>
  }

  export type CandidateApplicationUpdateManyWithWhereWithoutJobStageInput = {
    where: CandidateApplicationScalarWhereInput
    data: XOR<CandidateApplicationUpdateManyMutationInput, CandidateApplicationUncheckedUpdateManyWithoutJobStageInput>
  }

  export type JobPostCreateWithoutJobMailingTemplateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutJobPostInput
    jobApplication?: JobApplicationCreateNestedManyWithoutJobPostInput
    jobStage?: JobStageCreateNestedManyWithoutJobPostInput
    jobPreview?: JobPreviewCreateNestedManyWithoutJobPostInput
    candidateApplication?: CandidateApplicationCreateNestedManyWithoutJobPostInput
    CandidateTimeline?: CandidateTimelineCreateNestedManyWithoutJobPostInput
  }

  export type JobPostUncheckedCreateWithoutJobMailingTemplateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    organizationId: string
    createdAt?: Date | string
    jobApplication?: JobApplicationUncheckedCreateNestedManyWithoutJobPostInput
    jobStage?: JobStageUncheckedCreateNestedManyWithoutJobPostInput
    jobPreview?: JobPreviewUncheckedCreateNestedManyWithoutJobPostInput
    candidateApplication?: CandidateApplicationUncheckedCreateNestedManyWithoutJobPostInput
    CandidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutJobPostInput
  }

  export type JobPostCreateOrConnectWithoutJobMailingTemplateInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutJobMailingTemplateInput, JobPostUncheckedCreateWithoutJobMailingTemplateInput>
  }

  export type JobPostUpsertWithoutJobMailingTemplateInput = {
    update: XOR<JobPostUpdateWithoutJobMailingTemplateInput, JobPostUncheckedUpdateWithoutJobMailingTemplateInput>
    create: XOR<JobPostCreateWithoutJobMailingTemplateInput, JobPostUncheckedCreateWithoutJobMailingTemplateInput>
    where?: JobPostWhereInput
  }

  export type JobPostUpdateToOneWithWhereWithoutJobMailingTemplateInput = {
    where?: JobPostWhereInput
    data: XOR<JobPostUpdateWithoutJobMailingTemplateInput, JobPostUncheckedUpdateWithoutJobMailingTemplateInput>
  }

  export type JobPostUpdateWithoutJobMailingTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutJobPostNestedInput
    jobApplication?: JobApplicationUpdateManyWithoutJobPostNestedInput
    jobStage?: JobStageUpdateManyWithoutJobPostNestedInput
    jobPreview?: JobPreviewUpdateManyWithoutJobPostNestedInput
    candidateApplication?: CandidateApplicationUpdateManyWithoutJobPostNestedInput
    CandidateTimeline?: CandidateTimelineUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateWithoutJobMailingTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobApplication?: JobApplicationUncheckedUpdateManyWithoutJobPostNestedInput
    jobStage?: JobStageUncheckedUpdateManyWithoutJobPostNestedInput
    jobPreview?: JobPreviewUncheckedUpdateManyWithoutJobPostNestedInput
    candidateApplication?: CandidateApplicationUncheckedUpdateManyWithoutJobPostNestedInput
    CandidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutJobPostNestedInput
  }

  export type UserCreateWithoutEmailMessageInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizations?: OrganizationUserRoleCreateNestedManyWithoutUserInput
    twoFactorConfirmation?: TwoFactorConfirmationCreateNestedOneWithoutUserInput
    candidateTimeline?: CandidateTimelineCreateNestedManyWithoutUserInput
    organizationSubscription?: OrganizationSubscriptionCreateNestedManyWithoutUserInput
    NotificationReceipt?: NotificationReceiptCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailMessageInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationUserRoleUncheckedCreateNestedManyWithoutUserInput
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInput
    candidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutUserInput
    organizationSubscription?: OrganizationSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationReceipt?: NotificationReceiptUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailMessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailMessageInput, UserUncheckedCreateWithoutEmailMessageInput>
  }

  export type CandidateApplicationCreateWithoutEmailMessageInput = {
    id?: string
    createdAt?: Date | string
    jobPost: JobPostCreateNestedOneWithoutCandidateApplicationInput
    jobStage: JobStageCreateNestedOneWithoutCandidateStageInput
    formResponses?: FormResponseCreateNestedManyWithoutCandidateApplicationInput
    CandidateTimeline?: CandidateTimelineCreateNestedManyWithoutCandidateApplicationInput
  }

  export type CandidateApplicationUncheckedCreateWithoutEmailMessageInput = {
    id?: string
    jobId: string
    createdAt?: Date | string
    stageId: string
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutCandidateApplicationInput
    CandidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutCandidateApplicationInput
  }

  export type CandidateApplicationCreateOrConnectWithoutEmailMessageInput = {
    where: CandidateApplicationWhereUniqueInput
    create: XOR<CandidateApplicationCreateWithoutEmailMessageInput, CandidateApplicationUncheckedCreateWithoutEmailMessageInput>
  }

  export type EmailMessageCreateWithoutRepliesInput = {
    id?: string
    messageId: string
    sender: string
    recipient: string
    subject: string
    body: string
    s3Url?: string | null
    direction: $Enums.EmailDirection
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEmailMessageInput
    candidate: CandidateApplicationCreateNestedOneWithoutEmailMessageInput
    parentMessage?: EmailMessageCreateNestedOneWithoutRepliesInput
  }

  export type EmailMessageUncheckedCreateWithoutRepliesInput = {
    id?: string
    messageId: string
    parentMessageId?: string | null
    sender: string
    recipient: string
    subject: string
    body: string
    s3Url?: string | null
    direction: $Enums.EmailDirection
    createdAt?: Date | string
    userId: string
    candidateId: string
  }

  export type EmailMessageCreateOrConnectWithoutRepliesInput = {
    where: EmailMessageWhereUniqueInput
    create: XOR<EmailMessageCreateWithoutRepliesInput, EmailMessageUncheckedCreateWithoutRepliesInput>
  }

  export type EmailMessageCreateWithoutParentMessageInput = {
    id?: string
    messageId: string
    sender: string
    recipient: string
    subject: string
    body: string
    s3Url?: string | null
    direction: $Enums.EmailDirection
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEmailMessageInput
    candidate: CandidateApplicationCreateNestedOneWithoutEmailMessageInput
    replies?: EmailMessageCreateNestedManyWithoutParentMessageInput
  }

  export type EmailMessageUncheckedCreateWithoutParentMessageInput = {
    id?: string
    messageId: string
    sender: string
    recipient: string
    subject: string
    body: string
    s3Url?: string | null
    direction: $Enums.EmailDirection
    createdAt?: Date | string
    userId: string
    candidateId: string
    replies?: EmailMessageUncheckedCreateNestedManyWithoutParentMessageInput
  }

  export type EmailMessageCreateOrConnectWithoutParentMessageInput = {
    where: EmailMessageWhereUniqueInput
    create: XOR<EmailMessageCreateWithoutParentMessageInput, EmailMessageUncheckedCreateWithoutParentMessageInput>
  }

  export type EmailMessageCreateManyParentMessageInputEnvelope = {
    data: EmailMessageCreateManyParentMessageInput | EmailMessageCreateManyParentMessageInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEmailMessageInput = {
    update: XOR<UserUpdateWithoutEmailMessageInput, UserUncheckedUpdateWithoutEmailMessageInput>
    create: XOR<UserCreateWithoutEmailMessageInput, UserUncheckedCreateWithoutEmailMessageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailMessageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailMessageInput, UserUncheckedUpdateWithoutEmailMessageInput>
  }

  export type UserUpdateWithoutEmailMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizations?: OrganizationUserRoleUpdateManyWithoutUserNestedInput
    twoFactorConfirmation?: TwoFactorConfirmationUpdateOneWithoutUserNestedInput
    candidateTimeline?: CandidateTimelineUpdateManyWithoutUserNestedInput
    organizationSubscription?: OrganizationSubscriptionUpdateManyWithoutUserNestedInput
    NotificationReceipt?: NotificationReceiptUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationUserRoleUncheckedUpdateManyWithoutUserNestedInput
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInput
    candidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutUserNestedInput
    organizationSubscription?: OrganizationSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationReceipt?: NotificationReceiptUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CandidateApplicationUpsertWithoutEmailMessageInput = {
    update: XOR<CandidateApplicationUpdateWithoutEmailMessageInput, CandidateApplicationUncheckedUpdateWithoutEmailMessageInput>
    create: XOR<CandidateApplicationCreateWithoutEmailMessageInput, CandidateApplicationUncheckedCreateWithoutEmailMessageInput>
    where?: CandidateApplicationWhereInput
  }

  export type CandidateApplicationUpdateToOneWithWhereWithoutEmailMessageInput = {
    where?: CandidateApplicationWhereInput
    data: XOR<CandidateApplicationUpdateWithoutEmailMessageInput, CandidateApplicationUncheckedUpdateWithoutEmailMessageInput>
  }

  export type CandidateApplicationUpdateWithoutEmailMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobPost?: JobPostUpdateOneRequiredWithoutCandidateApplicationNestedInput
    jobStage?: JobStageUpdateOneRequiredWithoutCandidateStageNestedInput
    formResponses?: FormResponseUpdateManyWithoutCandidateApplicationNestedInput
    CandidateTimeline?: CandidateTimelineUpdateManyWithoutCandidateApplicationNestedInput
  }

  export type CandidateApplicationUncheckedUpdateWithoutEmailMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stageId?: StringFieldUpdateOperationsInput | string
    formResponses?: FormResponseUncheckedUpdateManyWithoutCandidateApplicationNestedInput
    CandidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutCandidateApplicationNestedInput
  }

  export type EmailMessageUpsertWithoutRepliesInput = {
    update: XOR<EmailMessageUpdateWithoutRepliesInput, EmailMessageUncheckedUpdateWithoutRepliesInput>
    create: XOR<EmailMessageCreateWithoutRepliesInput, EmailMessageUncheckedCreateWithoutRepliesInput>
    where?: EmailMessageWhereInput
  }

  export type EmailMessageUpdateToOneWithWhereWithoutRepliesInput = {
    where?: EmailMessageWhereInput
    data: XOR<EmailMessageUpdateWithoutRepliesInput, EmailMessageUncheckedUpdateWithoutRepliesInput>
  }

  export type EmailMessageUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    s3Url?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumEmailDirectionFieldUpdateOperationsInput | $Enums.EmailDirection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailMessageNestedInput
    candidate?: CandidateApplicationUpdateOneRequiredWithoutEmailMessageNestedInput
    parentMessage?: EmailMessageUpdateOneWithoutRepliesNestedInput
  }

  export type EmailMessageUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    s3Url?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumEmailDirectionFieldUpdateOperationsInput | $Enums.EmailDirection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    candidateId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailMessageUpsertWithWhereUniqueWithoutParentMessageInput = {
    where: EmailMessageWhereUniqueInput
    update: XOR<EmailMessageUpdateWithoutParentMessageInput, EmailMessageUncheckedUpdateWithoutParentMessageInput>
    create: XOR<EmailMessageCreateWithoutParentMessageInput, EmailMessageUncheckedCreateWithoutParentMessageInput>
  }

  export type EmailMessageUpdateWithWhereUniqueWithoutParentMessageInput = {
    where: EmailMessageWhereUniqueInput
    data: XOR<EmailMessageUpdateWithoutParentMessageInput, EmailMessageUncheckedUpdateWithoutParentMessageInput>
  }

  export type EmailMessageUpdateManyWithWhereWithoutParentMessageInput = {
    where: EmailMessageScalarWhereInput
    data: XOR<EmailMessageUpdateManyMutationInput, EmailMessageUncheckedUpdateManyWithoutParentMessageInput>
  }

  export type UserCreateWithoutNotificationInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizations?: OrganizationUserRoleCreateNestedManyWithoutUserInput
    twoFactorConfirmation?: TwoFactorConfirmationCreateNestedOneWithoutUserInput
    candidateTimeline?: CandidateTimelineCreateNestedManyWithoutUserInput
    emailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    organizationSubscription?: OrganizationSubscriptionCreateNestedManyWithoutUserInput
    NotificationReceipt?: NotificationReceiptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationUserRoleUncheckedCreateNestedManyWithoutUserInput
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInput
    candidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutUserInput
    emailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    organizationSubscription?: OrganizationSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationReceipt?: NotificationReceiptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type OrganizationCreateWithoutNotificationInput = {
    id?: string
    name: string
    url?: string | null
    logo?: string | null
    assignedDomain?: string | null
    customDomain?: string | null
    createdAt?: Date | string
    organizationRole?: OrganizationUserRoleCreateNestedManyWithoutOrganizationInput
    organizationActionLog?: OrganizationActivityLogCreateNestedManyWithoutOrganizationInput
    jobPost?: JobPostCreateNestedManyWithoutOrganizationInput
    payment?: PaymentCreateNestedManyWithoutOrganizationInput
    jobPreview?: JobPreviewCreateNestedManyWithoutOrganizationInput
    organizationSubscription?: OrganizationSubscriptionCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutNotificationInput = {
    id?: string
    name: string
    url?: string | null
    logo?: string | null
    assignedDomain?: string | null
    customDomain?: string | null
    createdAt?: Date | string
    organizationRole?: OrganizationUserRoleUncheckedCreateNestedManyWithoutOrganizationInput
    organizationActionLog?: OrganizationActivityLogUncheckedCreateNestedManyWithoutOrganizationInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutOrganizationInput
    payment?: PaymentUncheckedCreateNestedManyWithoutOrganizationInput
    jobPreview?: JobPreviewUncheckedCreateNestedManyWithoutOrganizationInput
    organizationSubscription?: OrganizationSubscriptionUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutNotificationInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutNotificationInput, OrganizationUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationReceiptCreateWithoutNotificationInput = {
    id?: string
    isRead?: boolean
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationReceiptInput
  }

  export type NotificationReceiptUncheckedCreateWithoutNotificationInput = {
    id?: string
    userId: string
    isRead?: boolean
    readAt?: Date | string | null
  }

  export type NotificationReceiptCreateOrConnectWithoutNotificationInput = {
    where: NotificationReceiptWhereUniqueInput
    create: XOR<NotificationReceiptCreateWithoutNotificationInput, NotificationReceiptUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationReceiptCreateManyNotificationInputEnvelope = {
    data: NotificationReceiptCreateManyNotificationInput | NotificationReceiptCreateManyNotificationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizations?: OrganizationUserRoleUpdateManyWithoutUserNestedInput
    twoFactorConfirmation?: TwoFactorConfirmationUpdateOneWithoutUserNestedInput
    candidateTimeline?: CandidateTimelineUpdateManyWithoutUserNestedInput
    emailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    organizationSubscription?: OrganizationSubscriptionUpdateManyWithoutUserNestedInput
    NotificationReceipt?: NotificationReceiptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationUserRoleUncheckedUpdateManyWithoutUserNestedInput
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInput
    candidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutUserNestedInput
    emailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    organizationSubscription?: OrganizationSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationReceipt?: NotificationReceiptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationUpsertWithoutNotificationInput = {
    update: XOR<OrganizationUpdateWithoutNotificationInput, OrganizationUncheckedUpdateWithoutNotificationInput>
    create: XOR<OrganizationCreateWithoutNotificationInput, OrganizationUncheckedCreateWithoutNotificationInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutNotificationInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutNotificationInput, OrganizationUncheckedUpdateWithoutNotificationInput>
  }

  export type OrganizationUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationRole?: OrganizationUserRoleUpdateManyWithoutOrganizationNestedInput
    organizationActionLog?: OrganizationActivityLogUpdateManyWithoutOrganizationNestedInput
    jobPost?: JobPostUpdateManyWithoutOrganizationNestedInput
    payment?: PaymentUpdateManyWithoutOrganizationNestedInput
    jobPreview?: JobPreviewUpdateManyWithoutOrganizationNestedInput
    organizationSubscription?: OrganizationSubscriptionUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationRole?: OrganizationUserRoleUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationActionLog?: OrganizationActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutOrganizationNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutOrganizationNestedInput
    jobPreview?: JobPreviewUncheckedUpdateManyWithoutOrganizationNestedInput
    organizationSubscription?: OrganizationSubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type NotificationReceiptUpsertWithWhereUniqueWithoutNotificationInput = {
    where: NotificationReceiptWhereUniqueInput
    update: XOR<NotificationReceiptUpdateWithoutNotificationInput, NotificationReceiptUncheckedUpdateWithoutNotificationInput>
    create: XOR<NotificationReceiptCreateWithoutNotificationInput, NotificationReceiptUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationReceiptUpdateWithWhereUniqueWithoutNotificationInput = {
    where: NotificationReceiptWhereUniqueInput
    data: XOR<NotificationReceiptUpdateWithoutNotificationInput, NotificationReceiptUncheckedUpdateWithoutNotificationInput>
  }

  export type NotificationReceiptUpdateManyWithWhereWithoutNotificationInput = {
    where: NotificationReceiptScalarWhereInput
    data: XOR<NotificationReceiptUpdateManyMutationInput, NotificationReceiptUncheckedUpdateManyWithoutNotificationInput>
  }

  export type NotificationCreateWithoutReceiptsInput = {
    id?: string
    message: string
    createdAt?: Date | string
    type?: string
    category?: string
    actionUrl?: string | null
    priority?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserCreateNestedOneWithoutNotificationInput
    organization?: OrganizationCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutReceiptsInput = {
    id?: string
    message: string
    createdAt?: Date | string
    type?: string
    category?: string
    actionUrl?: string | null
    priority?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    organizationId?: string | null
  }

  export type NotificationCreateOrConnectWithoutReceiptsInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutReceiptsInput, NotificationUncheckedCreateWithoutReceiptsInput>
  }

  export type UserCreateWithoutNotificationReceiptInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizations?: OrganizationUserRoleCreateNestedManyWithoutUserInput
    twoFactorConfirmation?: TwoFactorConfirmationCreateNestedOneWithoutUserInput
    candidateTimeline?: CandidateTimelineCreateNestedManyWithoutUserInput
    emailMessage?: EmailMessageCreateNestedManyWithoutUserInput
    organizationSubscription?: OrganizationSubscriptionCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationReceiptInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    isTwoFactorEnabled?: boolean
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationUserRoleUncheckedCreateNestedManyWithoutUserInput
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedCreateNestedOneWithoutUserInput
    candidateTimeline?: CandidateTimelineUncheckedCreateNestedManyWithoutUserInput
    emailMessage?: EmailMessageUncheckedCreateNestedManyWithoutUserInput
    organizationSubscription?: OrganizationSubscriptionUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationReceiptInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationReceiptInput, UserUncheckedCreateWithoutNotificationReceiptInput>
  }

  export type NotificationUpsertWithoutReceiptsInput = {
    update: XOR<NotificationUpdateWithoutReceiptsInput, NotificationUncheckedUpdateWithoutReceiptsInput>
    create: XOR<NotificationCreateWithoutReceiptsInput, NotificationUncheckedCreateWithoutReceiptsInput>
    where?: NotificationWhereInput
  }

  export type NotificationUpdateToOneWithWhereWithoutReceiptsInput = {
    where?: NotificationWhereInput
    data: XOR<NotificationUpdateWithoutReceiptsInput, NotificationUncheckedUpdateWithoutReceiptsInput>
  }

  export type NotificationUpdateWithoutReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneWithoutNotificationNestedInput
    organization?: OrganizationUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutNotificationReceiptInput = {
    update: XOR<UserUpdateWithoutNotificationReceiptInput, UserUncheckedUpdateWithoutNotificationReceiptInput>
    create: XOR<UserCreateWithoutNotificationReceiptInput, UserUncheckedCreateWithoutNotificationReceiptInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationReceiptInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationReceiptInput, UserUncheckedUpdateWithoutNotificationReceiptInput>
  }

  export type UserUpdateWithoutNotificationReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizations?: OrganizationUserRoleUpdateManyWithoutUserNestedInput
    twoFactorConfirmation?: TwoFactorConfirmationUpdateOneWithoutUserNestedInput
    candidateTimeline?: CandidateTimelineUpdateManyWithoutUserNestedInput
    emailMessage?: EmailMessageUpdateManyWithoutUserNestedInput
    organizationSubscription?: OrganizationSubscriptionUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationUserRoleUncheckedUpdateManyWithoutUserNestedInput
    twoFactorConfirmation?: TwoFactorConfirmationUncheckedUpdateOneWithoutUserNestedInput
    candidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutUserNestedInput
    emailMessage?: EmailMessageUncheckedUpdateManyWithoutUserNestedInput
    organizationSubscription?: OrganizationSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type OrganizationUserRoleCreateManyUserInput = {
    id?: string
    role: $Enums.OrganizationRole
    organizationId: string
    email: string
    status?: string
    createdAt?: Date | string
  }

  export type CandidateTimelineCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    actionType: string
    jobId: string
    timelineText: string
    comment?: string | null
    reviewId?: string | null
    candidateId: string
  }

  export type EmailMessageCreateManyUserInput = {
    id?: string
    messageId: string
    parentMessageId?: string | null
    sender: string
    recipient: string
    subject: string
    body: string
    s3Url?: string | null
    direction: $Enums.EmailDirection
    createdAt?: Date | string
    candidateId: string
  }

  export type OrganizationSubscriptionCreateManyUserInput = {
    id?: string
    referalId?: string | null
    paymentHandler: string
    organizationId: string
    status?: $Enums.SubscriptionStatus
    subscriptionType: string
    createdAt?: Date | string
    expiresOn: Date | string
  }

  export type NotificationReceiptCreateManyUserInput = {
    id?: string
    notificationId: string
    isRead?: boolean
    readAt?: Date | string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    message: string
    createdAt?: Date | string
    type?: string
    category?: string
    actionUrl?: string | null
    priority?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    organizationId?: string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationUserRoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutOrganizationRoleNestedInput
  }

  export type OrganizationUserRoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidateTimelineUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionType?: StringFieldUpdateOperationsInput | string
    timelineText?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    candidateReview?: CandidateReviewUpdateOneWithoutCandidateTimelineNestedInput
    candidateApplication?: CandidateApplicationUpdateOneRequiredWithoutCandidateTimelineNestedInput
    jobPost?: JobPostUpdateOneRequiredWithoutCandidateTimelineNestedInput
  }

  export type CandidateTimelineUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionType?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    timelineText?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateId?: StringFieldUpdateOperationsInput | string
  }

  export type CandidateTimelineUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionType?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    timelineText?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailMessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    s3Url?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumEmailDirectionFieldUpdateOperationsInput | $Enums.EmailDirection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidate?: CandidateApplicationUpdateOneRequiredWithoutEmailMessageNestedInput
    parentMessage?: EmailMessageUpdateOneWithoutRepliesNestedInput
    replies?: EmailMessageUpdateManyWithoutParentMessageNestedInput
  }

  export type EmailMessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    s3Url?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumEmailDirectionFieldUpdateOperationsInput | $Enums.EmailDirection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidateId?: StringFieldUpdateOperationsInput | string
    replies?: EmailMessageUncheckedUpdateManyWithoutParentMessageNestedInput
  }

  export type EmailMessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    s3Url?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumEmailDirectionFieldUpdateOperationsInput | $Enums.EmailDirection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidateId?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentHandler?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutOrganizationSubscriptionNestedInput
  }

  export type OrganizationSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentHandler?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentHandler?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationReceiptUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: NotificationUpdateOneRequiredWithoutReceiptsNestedInput
  }

  export type NotificationReceiptUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationReceiptUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    organization?: OrganizationUpdateOneWithoutNotificationNestedInput
    receipts?: NotificationReceiptUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    receipts?: NotificationReceiptUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationUserRoleCreateManyOrganizationInput = {
    id?: string
    role: $Enums.OrganizationRole
    email: string
    userId?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type OrganizationActivityLogCreateManyOrganizationInput = {
    id?: string
    action: string
    createdAt?: Date | string
  }

  export type JobPostCreateManyOrganizationInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    employmentType?: string | null
    country?: string | null
    city?: string | null
    remoteOption?: string | null
    countryResidence?: string | null
    countryListResidence?: JobPostCreatecountryListResidenceInput | string[]
    displaySalary?: string | null
    currency?: string | null
    salaryAmount?: number | null
    minimumAmount?: number | null
    maximumAmount?: number | null
    isPublished?: boolean
    isScheduled?: boolean
    isArchived?: boolean
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentCreateManyOrganizationInput = {
    id?: string
    paddlePaymentId: string
    amount: number
    currency: string
    status: $Enums.PaymentStatus
    createdAt?: Date | string
  }

  export type JobPreviewCreateManyOrganizationInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    isExpired?: boolean
    jobId: string
  }

  export type OrganizationSubscriptionCreateManyOrganizationInput = {
    id?: string
    referalId?: string | null
    paymentHandler: string
    status?: $Enums.SubscriptionStatus
    subscriptionType: string
    userId: string
    createdAt?: Date | string
    expiresOn: Date | string
  }

  export type NotificationCreateManyOrganizationInput = {
    id?: string
    message: string
    createdAt?: Date | string
    type?: string
    category?: string
    actionUrl?: string | null
    priority?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
  }

  export type OrganizationUserRoleUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutOrganizationsNestedInput
  }

  export type OrganizationUserRoleUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    email?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUserRoleUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrganizationRoleFieldUpdateOperationsInput | $Enums.OrganizationRole
    email?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationActivityLogUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationActivityLogUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationActivityLogUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPostUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobApplication?: JobApplicationUpdateManyWithoutJobPostNestedInput
    jobStage?: JobStageUpdateManyWithoutJobPostNestedInput
    jobPreview?: JobPreviewUpdateManyWithoutJobPostNestedInput
    candidateApplication?: CandidateApplicationUpdateManyWithoutJobPostNestedInput
    CandidateTimeline?: CandidateTimelineUpdateManyWithoutJobPostNestedInput
    JobMailingTemplate?: JobMailingTemplateUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobApplication?: JobApplicationUncheckedUpdateManyWithoutJobPostNestedInput
    jobStage?: JobStageUncheckedUpdateManyWithoutJobPostNestedInput
    jobPreview?: JobPreviewUncheckedUpdateManyWithoutJobPostNestedInput
    candidateApplication?: CandidateApplicationUncheckedUpdateManyWithoutJobPostNestedInput
    CandidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutJobPostNestedInput
    JobMailingTemplate?: JobMailingTemplateUncheckedUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    employmentType?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    remoteOption?: NullableStringFieldUpdateOperationsInput | string | null
    countryResidence?: NullableStringFieldUpdateOperationsInput | string | null
    countryListResidence?: JobPostUpdatecountryListResidenceInput | string[]
    displaySalary?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    salaryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    minimumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    maximumAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isScheduled?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paddlePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paddlePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paddlePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPreviewUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    jobPost?: JobPostUpdateOneRequiredWithoutJobPreviewNestedInput
  }

  export type JobPreviewUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    jobId?: StringFieldUpdateOperationsInput | string
  }

  export type JobPreviewUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    jobId?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationSubscriptionUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentHandler?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrganizationSubscriptionNestedInput
  }

  export type OrganizationSubscriptionUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentHandler?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationSubscriptionUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentHandler?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    subscriptionType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneWithoutNotificationNestedInput
    receipts?: NotificationReceiptUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    receipts?: NotificationReceiptUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobApplicationCreateManyJobPostInput = {
    id?: string
    label: string
    dataType: string
    option?: JobApplicationCreateoptionInput | string[]
    rule?: string
    questionType?: string
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type JobStageCreateManyJobPostInput = {
    id?: string
    name: string
    isDeletable?: boolean
    isDeleted?: boolean
    displayOrder: number
    createdAt?: Date | string
  }

  export type JobPreviewCreateManyJobPostInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    isExpired?: boolean
    organizationId?: string | null
  }

  export type CandidateApplicationCreateManyJobPostInput = {
    id?: string
    createdAt?: Date | string
    stageId: string
  }

  export type CandidateTimelineCreateManyJobPostInput = {
    id?: string
    createdAt?: Date | string
    userId?: string | null
    actionType: string
    timelineText: string
    comment?: string | null
    reviewId?: string | null
    candidateId: string
  }

  export type JobMailingTemplateCreateManyJobPostInput = {
    id?: string
    name: string
    subject: string
    body: string
    createdAt?: Date | string
  }

  export type JobApplicationUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    option?: JobApplicationUpdateoptionInput | string[]
    rule?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formResponse?: FormResponseUpdateManyWithoutJobApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    option?: JobApplicationUpdateoptionInput | string[]
    rule?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formResponse?: FormResponseUncheckedUpdateManyWithoutJobApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateManyWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    option?: JobApplicationUpdateoptionInput | string[]
    rule?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobStageUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeletable?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidateStage?: CandidateApplicationUpdateManyWithoutJobStageNestedInput
  }

  export type JobStageUncheckedUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeletable?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidateStage?: CandidateApplicationUncheckedUpdateManyWithoutJobStageNestedInput
  }

  export type JobStageUncheckedUpdateManyWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeletable?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPreviewUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneWithoutJobPreviewNestedInput
  }

  export type JobPreviewUncheckedUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobPreviewUncheckedUpdateManyWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CandidateApplicationUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobStage?: JobStageUpdateOneRequiredWithoutCandidateStageNestedInput
    formResponses?: FormResponseUpdateManyWithoutCandidateApplicationNestedInput
    emailMessage?: EmailMessageUpdateManyWithoutCandidateNestedInput
    CandidateTimeline?: CandidateTimelineUpdateManyWithoutCandidateApplicationNestedInput
  }

  export type CandidateApplicationUncheckedUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stageId?: StringFieldUpdateOperationsInput | string
    formResponses?: FormResponseUncheckedUpdateManyWithoutCandidateApplicationNestedInput
    emailMessage?: EmailMessageUncheckedUpdateManyWithoutCandidateNestedInput
    CandidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutCandidateApplicationNestedInput
  }

  export type CandidateApplicationUncheckedUpdateManyWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stageId?: StringFieldUpdateOperationsInput | string
  }

  export type CandidateTimelineUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionType?: StringFieldUpdateOperationsInput | string
    timelineText?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    candidateReview?: CandidateReviewUpdateOneWithoutCandidateTimelineNestedInput
    candidateApplication?: CandidateApplicationUpdateOneRequiredWithoutCandidateTimelineNestedInput
    user?: UserUpdateOneWithoutCandidateTimelineNestedInput
  }

  export type CandidateTimelineUncheckedUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    timelineText?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateId?: StringFieldUpdateOperationsInput | string
  }

  export type CandidateTimelineUncheckedUpdateManyWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    timelineText?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    candidateId?: StringFieldUpdateOperationsInput | string
  }

  export type JobMailingTemplateUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobMailingTemplateUncheckedUpdateWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobMailingTemplateUncheckedUpdateManyWithoutJobPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseCreateManyJobApplicationInput = {
    id?: string
    candidateApplicationId: string
    label: string
    value?: string | null
    createdAt?: Date | string
  }

  export type FormResponseUpdateWithoutJobApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    candidateApplication?: CandidateApplicationUpdateOneRequiredWithoutFormResponsesNestedInput
  }

  export type FormResponseUncheckedUpdateWithoutJobApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    candidateApplicationId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseUncheckedUpdateManyWithoutJobApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    candidateApplicationId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseCreateManyCandidateApplicationInput = {
    id?: string
    jobApplicationId: string
    label: string
    value?: string | null
    createdAt?: Date | string
  }

  export type EmailMessageCreateManyCandidateInput = {
    id?: string
    messageId: string
    parentMessageId?: string | null
    sender: string
    recipient: string
    subject: string
    body: string
    s3Url?: string | null
    direction: $Enums.EmailDirection
    createdAt?: Date | string
    userId: string
  }

  export type CandidateTimelineCreateManyCandidateApplicationInput = {
    id?: string
    createdAt?: Date | string
    userId?: string | null
    actionType: string
    jobId: string
    timelineText: string
    comment?: string | null
    reviewId?: string | null
  }

  export type FormResponseUpdateWithoutCandidateApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobApplication?: JobApplicationUpdateOneRequiredWithoutFormResponseNestedInput
  }

  export type FormResponseUncheckedUpdateWithoutCandidateApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobApplicationId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseUncheckedUpdateManyWithoutCandidateApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobApplicationId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailMessageUpdateWithoutCandidateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    s3Url?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumEmailDirectionFieldUpdateOperationsInput | $Enums.EmailDirection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailMessageNestedInput
    parentMessage?: EmailMessageUpdateOneWithoutRepliesNestedInput
    replies?: EmailMessageUpdateManyWithoutParentMessageNestedInput
  }

  export type EmailMessageUncheckedUpdateWithoutCandidateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    s3Url?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumEmailDirectionFieldUpdateOperationsInput | $Enums.EmailDirection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    replies?: EmailMessageUncheckedUpdateManyWithoutParentMessageNestedInput
  }

  export type EmailMessageUncheckedUpdateManyWithoutCandidateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    s3Url?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumEmailDirectionFieldUpdateOperationsInput | $Enums.EmailDirection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CandidateTimelineUpdateWithoutCandidateApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionType?: StringFieldUpdateOperationsInput | string
    timelineText?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    candidateReview?: CandidateReviewUpdateOneWithoutCandidateTimelineNestedInput
    jobPost?: JobPostUpdateOneRequiredWithoutCandidateTimelineNestedInput
    user?: UserUpdateOneWithoutCandidateTimelineNestedInput
  }

  export type CandidateTimelineUncheckedUpdateWithoutCandidateApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    timelineText?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CandidateTimelineUncheckedUpdateManyWithoutCandidateApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    timelineText?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CandidateTimelineCreateManyCandidateReviewInput = {
    id?: string
    createdAt?: Date | string
    userId?: string | null
    actionType: string
    jobId: string
    timelineText: string
    comment?: string | null
    candidateId: string
  }

  export type CandidateTimelineUpdateWithoutCandidateReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionType?: StringFieldUpdateOperationsInput | string
    timelineText?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    candidateApplication?: CandidateApplicationUpdateOneRequiredWithoutCandidateTimelineNestedInput
    jobPost?: JobPostUpdateOneRequiredWithoutCandidateTimelineNestedInput
    user?: UserUpdateOneWithoutCandidateTimelineNestedInput
  }

  export type CandidateTimelineUncheckedUpdateWithoutCandidateReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    timelineText?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    candidateId?: StringFieldUpdateOperationsInput | string
  }

  export type CandidateTimelineUncheckedUpdateManyWithoutCandidateReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    timelineText?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    candidateId?: StringFieldUpdateOperationsInput | string
  }

  export type CandidateApplicationCreateManyJobStageInput = {
    id?: string
    jobId: string
    createdAt?: Date | string
  }

  export type CandidateApplicationUpdateWithoutJobStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobPost?: JobPostUpdateOneRequiredWithoutCandidateApplicationNestedInput
    formResponses?: FormResponseUpdateManyWithoutCandidateApplicationNestedInput
    emailMessage?: EmailMessageUpdateManyWithoutCandidateNestedInput
    CandidateTimeline?: CandidateTimelineUpdateManyWithoutCandidateApplicationNestedInput
  }

  export type CandidateApplicationUncheckedUpdateWithoutJobStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formResponses?: FormResponseUncheckedUpdateManyWithoutCandidateApplicationNestedInput
    emailMessage?: EmailMessageUncheckedUpdateManyWithoutCandidateNestedInput
    CandidateTimeline?: CandidateTimelineUncheckedUpdateManyWithoutCandidateApplicationNestedInput
  }

  export type CandidateApplicationUncheckedUpdateManyWithoutJobStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailMessageCreateManyParentMessageInput = {
    id?: string
    messageId: string
    sender: string
    recipient: string
    subject: string
    body: string
    s3Url?: string | null
    direction: $Enums.EmailDirection
    createdAt?: Date | string
    userId: string
    candidateId: string
  }

  export type EmailMessageUpdateWithoutParentMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    s3Url?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumEmailDirectionFieldUpdateOperationsInput | $Enums.EmailDirection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailMessageNestedInput
    candidate?: CandidateApplicationUpdateOneRequiredWithoutEmailMessageNestedInput
    replies?: EmailMessageUpdateManyWithoutParentMessageNestedInput
  }

  export type EmailMessageUncheckedUpdateWithoutParentMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    s3Url?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumEmailDirectionFieldUpdateOperationsInput | $Enums.EmailDirection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    candidateId?: StringFieldUpdateOperationsInput | string
    replies?: EmailMessageUncheckedUpdateManyWithoutParentMessageNestedInput
  }

  export type EmailMessageUncheckedUpdateManyWithoutParentMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    s3Url?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumEmailDirectionFieldUpdateOperationsInput | $Enums.EmailDirection
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    candidateId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationReceiptCreateManyNotificationInput = {
    id?: string
    userId: string
    isRead?: boolean
    readAt?: Date | string | null
  }

  export type NotificationReceiptUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationReceiptNestedInput
  }

  export type NotificationReceiptUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationReceiptUncheckedUpdateManyWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationCountOutputTypeDefaultArgs instead
     */
    export type OrganizationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobPostCountOutputTypeDefaultArgs instead
     */
    export type JobPostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobPostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobApplicationCountOutputTypeDefaultArgs instead
     */
    export type JobApplicationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobApplicationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CandidateApplicationCountOutputTypeDefaultArgs instead
     */
    export type CandidateApplicationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CandidateApplicationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CandidateReviewCountOutputTypeDefaultArgs instead
     */
    export type CandidateReviewCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CandidateReviewCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobStageCountOutputTypeDefaultArgs instead
     */
    export type JobStageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobStageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailMessageCountOutputTypeDefaultArgs instead
     */
    export type EmailMessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailMessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationCountOutputTypeDefaultArgs instead
     */
    export type NotificationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationUserRoleDefaultArgs instead
     */
    export type OrganizationUserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationUserRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationTokenDefaultArgs instead
     */
    export type VerificationTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PasswordResetTokenDefaultArgs instead
     */
    export type PasswordResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PasswordResetTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TwoFactorTokenDefaultArgs instead
     */
    export type TwoFactorTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TwoFactorTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TwoFactorConfirmationDefaultArgs instead
     */
    export type TwoFactorConfirmationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TwoFactorConfirmationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationDefaultArgs instead
     */
    export type OrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationSubscriptionDefaultArgs instead
     */
    export type OrganizationSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationSubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationActivityLogDefaultArgs instead
     */
    export type OrganizationActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationActivityLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobPostDefaultArgs instead
     */
    export type JobPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobApplicationDefaultArgs instead
     */
    export type JobApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CandidateApplicationDefaultArgs instead
     */
    export type CandidateApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CandidateApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CandidateReviewDefaultArgs instead
     */
    export type CandidateReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CandidateReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CandidateTimelineDefaultArgs instead
     */
    export type CandidateTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CandidateTimelineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormResponseDefaultArgs instead
     */
    export type FormResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormResponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobPreviewDefaultArgs instead
     */
    export type JobPreviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobPreviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobStageDefaultArgs instead
     */
    export type JobStageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobStageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobMailingTemplateDefaultArgs instead
     */
    export type JobMailingTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobMailingTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailMessageDefaultArgs instead
     */
    export type EmailMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationReceiptDefaultArgs instead
     */
    export type NotificationReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationReceiptDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}